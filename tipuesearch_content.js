var tipuesearch = {"pages":[{"title":"About Me","text":"Skill Programming Language : Python Data Engineering : Snowflake, Redis, MySQL, PostgreSQL, Redshift MLOps : Apache Airflow, DVC, dbt, Great Expectations Backend Development : flask, Django, FastAPI DevOps tools and others : Docker, Kubernetes, Jenkins, GitHub Actions, Git, AWS Services Work Experience [Apr 2017 - Present] Machine Leraning Engineer, Rakuten USA Productionize machine learning projects Implemented an SQS service and gRPC services for grouping emails with similar structures and extracting user-sensitive data to increase the amount of training data without violating customer privacy regulations. Designed and Implemented a two-stage labeling system that automatically communicates between Amazon Mechanical Turk and in-house experts to generate high-quality labeled data and enhance merchandise taxonomy to increase customer conversion rate. Migrated and automated the deployment process of AWS Lambda procedures that process customer lifetime value, reducing the effort of maintenance and deployment. Build and maintain data pipelines on Apache Airflow Implemented a pipeline that processes data larger than 10 GB to infer personalized preferences to help increase customer satisfaction. Migrated legacy 1.x Airflow server on AWS EC2 to 2.0.2 Airflow on AWS MWAA, saving developers' effort on dealing with legacy dependencies issues, and created a development airflow environment for doing experiments without affecting the production pipeline. Refactored data writing mechanism and reduced the data write time and AWS S3 cost. Built alerts and dashboards to monitor pipelines metrics to minimize the effort of troubleshooting using DataDog, Prometheus, and Kibana. Standardize and maintain software engineering practices Created and maintain the project templates, with automatic code quality check, testing, containerization, project versioning, releasing, and deployment, and a standard workflow for existing projects to update tools, which reduced project creation time, the communication overhead during code review and provided an easy way for developers to introduce new standards. Implemented a life-cycle configuration management tool and a workflow for creating Amazon Sagemaker notebook instances which saves data scientists' time on handling engineering problems. Improved container build time and reduced execution time by 70\\% for Jenkins CI/CD pipelines. Maintain core package that's used among most existing projects Optimized SQL in a data pipeline and reduced the execution time from infeasible to within half a day. Cooperate with overseas teams in US, Ukraine, and India [Jan 2019 - March 2019] Project Manager, DLT Lab Containerized and fixed legacy projects in The Mosquito Man Introduced code review culture to a newly formed team Set up a drone CI/CD server and created CI pipelines for two ongoing projects [May 2018 - Nov 2018] Chief Teaching Assistant, X-Village Managed the executive team with 16 members Organized two months of full-time courses and a one-semester 3 credit course Reviewed the teaching proposal of the Python course, \"Programming Design Foundation\" Designed exercises for \"Data Structure,\" the first section of \"Computer Science Foundations\" Lectured \"Web Programming, Database/Cloud Computing,\" the fourth section of \"Computer Science Foundations\" X-Village is an experimental education program aiming to equip students not major in computer science with computational thinking and to enhance future cooperation between computer science and other areas. I was the executor of the program and the leader of the teaching assistant team. Besides, I designed a half-day exercise for Data Structure and lectured a four-hour web backend course for Web Programming, Database/Cloud Computing . Website Facebook Fan Page [July 2015 - July 2016] Substitute Military Service, K-12 Education Administration, Ministry of Education Maintained legacy systems implemented in multiple languages, including C# , VBScript , PHP , etc. Developed automation programs for generating reports which save 80% of human labor time Delivered a human resource management system using django Community Involvement [Nov 2021 - Present] Vice-Chairperson, PyCon APAC 2022 Coordinated 3 squads, including planning, sponsorship, and social media Hosted the first Ask Me Anything event for promoting Call for Proposals [Oct 2020 - Nov 2021] Chairperson, PyCon Taiwan 2021 Coordinated 9 teams and hosted the first online PyCon TW with 550 participants [Dec 2019 - Sep 2020] Program Chair, PyCon Taiwan 2020 Coordinated around 20 team members and introduced community tracks and a speaker-dispatch program to increase the interaction between local communities. [Jul 2019 – Nov 2019] Program Committee Member, PyCon Taiwan 2019 Contact keynote speakers and financial aid applicants Contribute to the post-event report generator Talk and Tutorial Python Table Manners 2020/11/7 Taichung.py : slide 2020/10/16 Hualien.py : slide 2020/08/31 Kaohsiung.py : slide 2020/07/24 Euro Python 2020 slide video 2019/11/17 PyCon CA 2019 : slide 2019/10/24 Taipei.py commitizen-tools: What can we gain from crafting a git message convention? 2020/06/18 Taipei.py : slide 2020/04/25 Remote Python Pizza 2020 : slide How to get more than PyCon in a PyCon 2019/09/16 PyCon JP 2019 - Peer Reviewed Lightning Talk : slide X-Village - 用不到兩個月準備兩個月的課程 2019/03/24 SITCON 2019 slide video Intro to Python Data Science Tools 2018/03/12 NCKU CSIE - Competitions in Data Sciences and Artificial Intelligence: slide 2018/2/27 NCKU CSIE - Competitions in Data Sciences and Artificial Intelligence: slide CRUD in Flask 2018/8/16 X-Village - Web Course: slide 資管講座 (一場工資管營的演講) 2017/01/22 2018成大工資管營: slide Bot Development 2016/12/08 NCKU CSIE - Introduction to Knowledge Discovery and Data Engineering: slide Keras Demo 2016/11/03 深度之夜 : slide For more slides, please check my Speaker Deck . Award Honorable Mention, 2013 Railway Application Section Problem Solving Competition Publication Wei Lee, Chien-Wei Chang, Po-An Yang, Chi-Hsuan Huang, Ming-Kuang Wu, Chu-Cheng Hsieh, Kun-Ta Chuang \"Effective Quality Assurance for Data Labels through Crowdsourcing and Domain Expert Collaboration\" 21st International Conference on Extending Database Technology, Demo Track (EDBT-2018) I-Lin Wang, Wei Lee, Chiao-Yu Liao \"Effective Heuristics for Scheduling Hump and Pullback Engines in Railroad Yard Operational Plans\" Proceedings of the 10th Annual Conference of the Operations Research Society at Taiwan (ORSTW 2013) Education [2016-2018] Master, Computer Science and Information Engineering National Cheng Kung University, Tainan GPA: 4.16/4.3 [2011-2015] Bachelor, Industrial and Information Management Double Major: Computer Science and Information Engineering National Cheng Kung University, Tainan GPA: 3.77/4.0 (CSIE GA: 3.87/4.0) Additional Experience Open Source Contributions commitizen-tools : Maintainer commitizen commitizen_cz_template git-extras pycontw mail_handler : Author pycontw-postevent-report-generator : Maintainer beeeware batavia toga podium flask open-edx edx-platform edx-documentation wtforms-json pipreqs pip-check pelican-clean-blog templater Update templater to Python3 and release templater3 Web Service SITW 二手網 (Backend Development) Chat Bot Dengue Line Bot Server Telegram EchoBot Line EchoBot Utility pelican-stat Flickr Album Downloader PttCraweler wayback-machine-saver bahamut_ani_stat Tutorial and Study Note Slide Git Tutorial Sample: Git-Tutorial-Sample Books Learning Python 5e Note Python Cookbook The Clean Code The Clean Coder MOOCs Machine Learning (Coursera) Intro to Machine Learning Intro to Data Science Udacity Assignments for Udacity Deep Learning class with TensorFlow","tags":"pages","url":"https://wei-lee.me/pages/about-me.html","loc":"https://wei-lee.me/pages/about-me.html"},{"title":"Utterances - 用 GitHub Issues 當文章留言區","text":"之前看到有人用 GitHub Issues 當部落格的留言區，一直讓我想從 Disqus 搬走 想了很久，終於在過年期間弄好了，弄起來比想像的簡單許多 除了這裡，我還有經營 Meet people around the world （原本想寫遊記，結果現在都在記錄料理或影評 😅） 總之，它們都是透過 pelican 產生的部落格 分別使用了客製化的 elegant 和 attila 主題 目前看到要加上 GitHub Issues 最簡單的做法是使用 utterances 🔮 由於 elegant 本身就支援 utterances ，設定起來非常簡單 而 attila 則是需要改 jinja2 template 本文會聊聊怎麼在 elegant 設定 utterances 接著看 elegant 是如何在 template 中加入 utterances，並將同樣的概念搬到 attila 上 如何在 elegant 設定 utterances 根據 Comments — Enable Utterances ， pelican 這端只要在 pelicanconf.py 加入 UTTERANCES_REPO # [username]/[repo name] UTTERANCES_REPO = \"Lee-W/Lee-W.github.io\" 注意前面不能加上 https://github.com/ 我因為這個愚蠢的錯誤卡了超久...... 如果想為留言產生的 issue 加上特定的標籤，則可以設定 UTTERANCES_LABEL UTTERANCES_LABEL = \"comment\" 使用的標籤本身必須要已經存在 如果沒有的話，可以到先到 repo 的 Issues 頁面建立 下一步要為你的 GitHub 帳號安裝 utterances 的 GitHub App ，並賦予部落格 repo 讀寫 issues 的權限 設定完成後就能在文章的最下面看到留言的區塊 完成留言後，就會出現在 GitHub Issues 上了 攥寫這篇文章的時候是用 localhost 測試，所以屆時裡面的連結會無效 但實際部署到 GitHub Pages 後，它就會寫入實際的網址 如果覺得用文章的 URL 當 issue 的標題很醜，可以在文章的 metadata 中加入 comment_id e.g., Title: Utterances - 用 GitHub Issues 作為文章留言區 Date: 2022-02-23 10:40 Category: Tech Tags: Pelican, blog Slug: use-github-issues-as-comment-system comment_id: use-github-issues-as-comment-system Authors: Lee-W 再留言一次就會產生以 comment_id 為標題的 issue 我會建議可以的話為每篇文章加上 commend_id 除了比較好看以外，也能避免換網域，評論全都不見的問題 但像我這種沒什麼人留言的就沒差了 😭 elegant 是怎麼做到的？ 為了能更容易在 attlia 加入 utterances，我稍微研究了 elgant 是怎麼加的 以下的程式碼都是使用 elegnat @ v5.4.0 在 elegant 中全域搜尋 utterances，會先找到 elegant/templates/_includes/utterances_scripts.html {% macro comments_script_utterances ( repo , id , label , theme ) %} <script src= \"https://utteranc.es/client.js\" data-repo= \" {{ repo }} \" data-issue-term= \" {{ id }} \" data-label= \" {{ label }} \" data-theme= \" {{ theme }} \" crossorigin= \"anonymous\" async > </script> {% endmacro %} 這段 jinja2 macro 會產生的 JavaScript 程式碼會跟手動在 utterances 🔮 產生的小有不同 差別是在 repo , issue-term , label , theme 前面的 data- 前綴 不過不太會影響實際的使用 詳細可以參考 👉 Update index.html #334 再來能找到 macro comments_script_utterances 會在 templates/_includes/comments.html#L55 被用到 { % if use_utterances % } { % from '_includes/utterances_scripts.html' import comments_script_utterances with context % } {{ comments_script_utterances ( UTTERANCES_REPO , identifier , UTTERANCES_LABEL , UTTERANCES_THEME ) }} { % endif % } 其中參數 UTTERANCES_REPO , UTTERANCES_LABEL , UTTERANCES_THEME 都是能透過 pelicanconf.py 被設定的 而 identifier 則可以往上在 templates/_includes/comments.html#L11 找到 如果沒有在文章的 metadata 加入 comment_id，則預設值是 SITEURL + '/' + article.url （就是一開始比較醜的 issue 標題） {% set identifier = SITEURL + '/' + article.url %} {% if article.comment_id %} {% set identifier = article.comment_id %} {% elif article.disqus_identifier %} {% set identifier = article.disqus_identifier %} {% endif %} 如何為其他主題加入 utterances 我將 attila 的改動細節記錄在 commit 236706 流程大致如下 關閉或取代預設的評論系統 templates/base.html static/js/script.js 加入 macro comments_script_utterances templates/partials/utterances_scripts.html 在 render每篇文章的 template 中使用 comments_script_utterances templates/article.html#L222 確保 macro 用到的參數，即使在 peliconconf.py 沒有正確設定的狀況下，依然有適當的預設值 templates/partials/_defaults.html templates/article.html#L212 如果沒興趣看的話也可以直接使用我改的 attila @ add-utterances-support 雜談 雖然一直都想從 disqus 移出，但我佛系經營的部落格平常根本就不會有人留言 尤其是 Meet people around the world 根本就不是只寫給工程師的文章，要留言還要登入 GitHub 原本留言的動機就夠低了，現在一口氣降到冰點 📉 不過往另一個方向想，反正也沒什麼人留言，我搬來 GitHub Issues 的成本根本超低 🤔 Reference 在 Hexo 的 Next 樣板中引入 utterances 的留言區 | GitHub Issue","tags":"Tech","url":"https://wei-lee.me/posts/tech/2022/02/use-github-issues-as-comment-system","loc":"https://wei-lee.me/posts/tech/2022/02/use-github-issues-as-comment-system"},{"title":"[Book] 真相製造","text":"一言以蔽之，這是關於假新聞，關於真相如何在這個時代被製造的書 在閱讀本書前，聽到朋友分享部分內容，就覺得有些似曾相識 後來發現作者劉致昕是 TEDx Tainan 2016 的講者，當時剛好分享了同樣的內容 本書由六段他對不同國家的假新聞現象的觀察所組成 從離比較遠的國家說起，最後收於台灣 至於看完能不能讓我們從假新聞免疫，我的答案是否定的 我認爲也許也沒有人能真的做到，人的大腦始終是習慣輕鬆好理解的事物 本書的最後這麼說 把這本書看到最後的你，或許，也有強烈的動機想「解決」或「擺脫」不實資訊造成的問題。壞消息是，我們可能沒辦法真的完全做到。我們能做的，除了學如何自保，還有從不實資訊這張「試紙」的顯影中，辨認出背後真正的問題。 但我認為它能讓我們對潛在的假新聞多一份警覺 至少不致於被太粗糙的假新聞騙 本書多次提到了 Cofacts , g0v ，讓我倍感熟悉 相較於其他資訊來源，我還是比較願意相信這種開放討論的地方 Note Ch1 - 2016@比利時 實體與線上的 Ghetto 人走上極端的關鍵 對於身處的社會失望、認為自己不被認同，這包括種族歧視的經驗、被霸凌、家庭裡的爭執、缺乏教育或工作機會等 人格特質中的積極性，包括對正義、榮譽感、自由、卓越的尋求，或想幫助貧窮、弱勢等，試圖讓社會變得更好的意念 因為膚色、宗教或各種不同身分認同元素而成為少數的群體，在偏見、媒體的嗜血之下，如何「被沉默」，我們或許不知不覺中都成為助長極端主義築牆者 Ch 3 - 2019@印尼 當民主成為 online game 網路謠言靠人們的恐懼、憤怒而生存 核實，便是一種衝突：與被騙者的認知衝突，與散布者的利益衝突 Nurhadi-Aldo 的選舉標語是： 做為被喜愛的候選人，我不能承諾你任何事情，我們就是一起經歷這些。 我承諾我不貪汙，但如果我打破承諾，我會另外再想一個。 農夫們會前途無量，他們的孩子不用再進城了，因為農夫會變成公務員。 📓 Wei Note: Nurhadi-Aldo 是 2019 印尼總統大選的虛擬候選人 二十一歲的艾德溫說：「我們的確想對全國、全世界的年輕人發出邀請，你們為什麼不跟我們一樣，開心、好笑地一起討論政治呢？我們不要恨，我們要一起想像；我邀請所有人，包括印尼之外的人，創造你們自己的候選人。」 📓 Wei Note: 艾德溫是 Nurhadi-Aldo 背後的中之人（？）之一 Ch 4 - 2019@德國 統一三十年，德國能否再次讓高牆倒下 在開放的情境下面對面 人們不會像網路上一樣極端 人們也自然而然「代表」自己所屬的認同群體跟對方說話，彰顯自己的良善面 透過公共空間互動，艾揚格也提出更積極的做法，他認為如果人們已因特定議題陷入對立，不妨丟出一個各方都還沒有定論的新題目，或許就能打開對話 📓 Wei Note: 「時代線上」試著透過類似交友平台的軟體，讓異溫層的人們面對面對話。我記得之前公視好像也有做過類似的事 🤔 那是在西德那側，人們寫在柏林圍牆上的塗鴉，「看著你逐漸斑駁、出現洞，是多麽令人開心的事。」原來，當牆如此具體可見、限制人們的自由與視線時，人們反而如此急於讓它倒下，就算僅憑著雙手都要鑿洞、都想當穿牆人 Ch 5 - 2020@中國 官民一體，網路牆國向全球撒下宣傳天網 K 觀察，Truth HK 網站甚至提供英文版本影片，以英文口述搭配中文字幕，點名所有不支持警方說法的媒體為亂源 →「它的作用不是要有影響力或是改變他人想法，只是提出另一個說法，讓人們疑惑，你就不知道以後要怎麼判斷了，讓海外華人覺得香港都是暴民。」 在國防部的調查報告、民間智庫臺灣民主實驗室、IORG（Information Operations Research Group）的報告中，中國在臺灣發動的資訊操縱，「在地協力者」皆是其中的關鍵角色 Ch 6 - Now@臺灣 平行世界的間的資訓攻防站 民主國家政府如果還對社會溝通抱有願景，應該去思考、發展在社群時代完整呈現資訊的做法，才有可能進一步討論政策與公共議題 訴說 「事實」 ，是在拚聲量的政治現實下民主國家政府該守住的底線 面對境外敵對勢力時最大的資產，正是對民主制度的信任 「行政機關最重要的一件事，不管做什麼東西一定要以事實為基礎，如果做這件事是為了幫某個政策、某個政黨辯護，但你卻扭曲它的事實基礎或去變造一些資料，只講好的那一面，不告訴大家它的代價是什麼，我覺得這樣是不好的……不能因為特定的立場、政黨、顏色或是價值信仰而去造假。」 人喜歡激烈的批判，喜歡一錘定音的東西，喜歡看完後，不用再想這個問題了，最輕鬆！ 如果有側翼給他們這個答案，給他們一個酸人的快感，人們就會隨著側翼把同溫層建構起來，同溫層才有能力去打贏選戰 所謂假新聞的亂象，正是因為大家都覺得自己是正義的一方，是在分享真正的真相 臺灣民眾傾向從兩大黨的論述中，找到認同的依據，做為判斷的標準，對錯只是其次，大部分只是從兩邊的論述裡，強化、補充自己信念 藍綠的分野，加上封閉群組的使用，更強化了認知簡化與習慣性貼標籤所造成的對立和矛盾 對許多長輩來說遠不只是討論政策，他們的個人認同與政黨綁在一起，也有長輩不知如何面對世界的變化，每個人不同的成長經驗，遇上全新的數位溝通工具，讓政治相關對話充滿考驗 對話前必須要有「信任存款」 存款來自於日常的關心與彼此瞭解，以日常話題建立信任和安全的對話環境 存款足夠前，先避開如政治、選舉、不實資訊等會大量扣款的題目，慢慢從可以加分的對話開始 衝突和意見不一致的情況其實在所難免，實用的建議 不要害怕意見不一致或衝突，當遇上了，不要陷入「拚輸贏」的困局，可以先以田野調查的心態，理解對方的認知、態度、立場從何而來，從中找到可能有交集的地方，進而建立對話基礎 衝突即將發生，或對話進入緊張時，逃避雖可恥但有效，先離開現場，讓雙方情緒平緩，再繼續溝通，如此可避免陷入意氣之爭 保留自己犯錯的可能，千萬不要自以為是，或因為資訊較充足而傲慢，否則即使自己是正確的，也會成為一個無人想對話的人 📓 Wei Note: 最近在看的書「華頓商學院最受歡迎的談判課：上完這堂課，世界都會聽你的」也有提到類似信任存款的概念 如何避開謠言的傷害？ 追蹤專門闢謠的粉專 e.g., Mygopen、假新聞清潔劑Fakenews、TFC臺灣事實查核中心 增加多元閱聽管道 👉 接觸同溫層外的文章，讓自己不容易被蒙蔽 刪除內容農場粉絲頁 選擇可信賴的媒體 多元化自己的媒體選擇 看電視時，不同台輪流替換 看網路媒體時，參酌各家消息 一分鐘清單，檢查資訊真偽 確認連結是否偽造許多散播不實資訊的網站 假新聞常常故意仿冒知名新聞來源的網址 e.g., 「.co」結尾的網站，可能就是某個「.com」網站的仿冒版 確定文章來源是具有公信力的網站或媒體，而非來路不明的內容農場 把網站名丟上 Google 搜尋 點開 Facebook 連結右下角的「關於」區塊 注意文章格式，如果發現充滿錯字或奇怪的排版，就要小心 檢查圖片是否假造許多不實資訊網站會使用舊照片、或竄改過的照片扭曲真相，或盜用其他真實照片放在文章中誤導讀者 Google以圖搜圖，確認原始出處 下載下來，確認圖片紀錄檔（EXIF）中的日期、情報 注意文章中的日期、年代、時間序是否符合邏輯，是否有事件年代遭到竄改 確認作者背景是否不明作者是誰？ 是否為相關領域具有公信力的學者，或能代表發言的人？ 資料來源是否清楚 如果都是匿名、或是沒有註明，就要小心很可能是不實資訊 有沒有其他相似的報導 如果沒有其他任何有公信力的媒體報導，請抱持懷疑態度進行查證，很可能是不實資訊 特別附錄 - 那些真相製造商人們 面對假新聞的建議 真相永遠不是非黑即白的 確保資訊來源的多元化 多讀書 人們要接受並給予自己及他人犯錯的空間，知道資訊操縱跟造假的技術每天都在進化，每個人都有脆弱和判斷失準的時刻，有了這樣的認知，或許，我們就有機會看見不實資訊背後，個人、人際和這個社會真正遇上的挑戰。衷心希望，關於假新聞的討論，除了誰對誰錯、有何居心等等，更多是關於如何補起社會中的裂縫。","tags":"Book","url":"https://wei-lee.me/posts/book/2022/02/reality-is-business","loc":"https://wei-lee.me/posts/book/2022/02/reality-is-business"},{"title":"Podcast 聽什麼","text":"之前跟朋友聊到在聽什麼 podcast 就一直想寫文章整理 最近又被茶魚飯厚的故事感動了 決定來推薦一下我平常有在聽的 podcast 也歡迎大家推薦平常在聽的 podcast ~ 我平時在運動跟煮飯的時候才會聽，頂多再加上走路的時間 所以比較偏好聽到一半中斷下次再聽也沒影響的節目 技術 PyCast Firstory 技術類當然還是要先推 PyCon TW 熱血志工做的 PyCast 🤩 雖然目前為止沒幾集真的在討論 Python 本身 🤔 不過正因為如此，即使你沒寫 Python，PyCast 也很適合你 現在就五星好評、訂閱、分享吧！ 初期我也有亂入錄了一集 隨時徵求有故事分享的大大，歡迎投稿到 pycast@python.tw 📫 話說在寫這篇文章的時候，發現最新的一集剛好更新了 剛剛才聽完，真是有夠精彩 不愧是大大，跟我只是胡說八道的就是不一樣 大家快去聽 Kir 大大的分享吧！ 👉 #7 | FAANG 工作環境跟外面有什麼不一樣？想進入 FAANG 就要聽這集！- Kir Chou Python Bytes Official Site Michael Kennedy 跟 Brian Okken 邀請各路來賓來聊聊最近Python 圈發生的事情或是有趣的小工具 一集原本大概半小時，現在不知道為什麼加長到一個小時了 通常可以聽到 5 ~ 8 小主題 雖然內容的深度不會太深，但很適合增加廣度 不時會聽到有趣的小工具可以來玩 在 190 集，我曾經投稿過 commitizen 👉 Episode #190: You will now be notified if the Python zipper is broken 同樣也歡迎各路大大們投稿（？） 讓我在節目中可以聽到更多有趣的東西 Talk Python To Me Official Site 同樣是 Michael Kennedy 主持 通常一集只會挑一個主題跟來賓細聊 是比較注重深度的 podcast 聽起來稍微吃力一點，所以我通常也只聽主題有興趣的 不像 Python Bytes 反正有出就可以聽 最近比較有印象的是訪談 Guido 非技術、 非ACG 尼爾喝牛奶：你的次文化指南 Firstory 這是所有 podcast 中我最喜歡的 一更新我就是聽爆！ 聽一遍不夠，我就再聽第二遍！！ 之所以沒有最先介紹是因為我想推廣 PyCast 主題是各種次文化，最近比較注重在影視、戲劇上，但也不時會有一些生活品味的內容 光是聽著尼爾跟 Woffy 閒聊就覺得很有趣 即使主題我沒那麼感興趣的集數，都還是讓我從不同的角度看原本不感興趣的事物 同時也推薦追蹤他們的 Instagram 我時不時會被他們的限動推薦好作品 不管是之前看的 Redline 或是魏斯·安德森的作品，都是因為他們的推薦我才會去看 很喜歡他們在 IG 寫的這句話 只要不是所有人喜歡 任何事物都可以是次文化 總之，我就推爆！！！ 茶魚飯厚︱人生有聲書 Firstory 當初是因為志祺七七的廣告注意到這個節目 不過真的很吸引我聽下去好像是從「做工的人」的作者立青那集開始 👉 EP.37 監工男神_上| 茶魚飯厚起點!!工地人生遭遇戰 feat.林立青 是我聽的 podcast 中，最有溫度的 從節目中能聽到人生百態 不同生活樣貌的人到底有什麼樣的想法？在做著什麼事？ 讓我們能從不同的角度認識這個社會的各個面向 是個相當有趣的節目 不過疫情爆發後級數都有點太長了 😆 最近也是挑有興趣的才聽 不過長規長，節目的內容還是相當的精彩 最近印象最深的是 EP112 思覺失調_上| 先嘴砲再開始走蠻荒 feat.國國 也是我開頭說我被茶魚飯厚感動催生出這篇文章的那集 Gooaye 股癌 Apple Podcast 雖然最近剛進股票市場當韭菜給大家宰割 但我比較以聽身體健康的態度來聽股癌 也許潛移默化對我投資還是有幫助 但我還沒那麼積極、有意識地做這件事 反正謝孟恭講話很有趣，聽著也開心 蒼藍鴿的醫學通識 Firstory 這應該也能算聽身體健康的吧 😆 平時有關注他的 YouTube 才來聽的 反正一週一集，每集也不長，聽起來毫無壓力 蒼藍鴿講話也蠻有趣的，就繼續聽下去了 烏托邦計畫：邁向美好城市的備忘錄 Apple Podcast 強者我朋友做的 podcast 主要在聊都市營造（希望我沒有用錯術語） 算是我平常沒在碰的議題，不過也覺得蠻有趣的 最有印象的果然還是 Ep.02 迎接 2020 東京奧運 │ 奧運是城市的良藥或毒藥？ 但最近停更一段時間惹 希望這篇文發出來不會對她造成的壓力 時間的女兒：八卦歷史 Firstory 朋友推薦給我的 podcast 中唯一我還有繼續聽的 聽了幾集還蠻喜歡的，覺得以前學歷史這麼有趣就好了 入坑 FGO 後，覺得自己應該要更了解歷史才能更享受它的世界觀 不過因為它講的故事有時序性，好像得從最舊播到最新 但 Apple Podcast 的播放順序是相反的 我每次聽完下一集，他又跑回去播前一集...... 讓我覺得有點煩躁，所以聽的進度很慢 總有一天會想辦法跟到最新進度 應該吧... 純 ACG A Jie 宅漫慢說 Apple Podcast 這也是因為有在追 A Jie 的 YouTube 才來聽的 雖然他看作品的品味跟我稍微不太一樣 但不時還是會推薦出我原本不感興趣，但後來很驚艷的作品 這個節目主要分 ACG 新聞跟主題閒聊兩個部分 啊，還有沒工商時間 雖然新聞有時候不太新，但還是蠻喜歡聽他對這些事的看法 因為真的很閒聊，聽起來非常的輕鬆 也是更新我很快就會聽的的節目 坑谷Life Apple Podcast 推薦動漫畫作品的節目 一開始聽覺得頻率不太對，但也不知道為什麼就繼續聽下去了 也許是想多聽聽看對作品不同的觀點？ 是個雖然只有普通喜歡，但我還是會繼續聽下去的節目","tags":"Gossiping","url":"https://wei-lee.me/posts/gossiping/2021/12/podcast-i-listen-to","loc":"https://wei-lee.me/posts/gossiping/2021/12/podcast-i-listen-to"},{"title":"[Book] 為什麼Google、LinkedIn、波音、高通、迪士尼都找他合作？","text":"這本書的中文書名真的有夠長，又沒有記憶點... 反倒是英文 Pitch Anything ，一看就不會忘 果然有跟著讀書會就比較有動力好好看書 不然上一本看完的非小說已經是半年前了... 如同書名所說的，這本書就是在講 pitch 簡單總結本書就是 不要覺得買賣的決定權在買方，你就得卑躬屈膝，這樣的 pitch 已經先失敗一半了 掌握當下的「框架」，保持高姿態，讓對方覺得非得跟你合作不可 雖然它說 pitch 可以被應用在各種情境，但敘述還是圍繞在商業提案上 所以情境離日常應用可能比較遠一點 但書中提到的各種框架分析，還是有助於自己在不同的場合中不要被別人帶著走 至於要怎麼帶著別人走，就真的需要靠實戰來累積了 Note Keywords of this book 框架支配權 權力瓦解框架 框架碰撞 祭出大獎 B 咖陷阱 掌握人際地位 當下明星魅力 推/拉 A咖 熱認知 鱷魚腦 新皮質 Ch 1 - Pitch 必勝心法 為什麼 Pitch 很困難？ 人腦依以下順序吸收訊息 原始腦（鱷魚腦） 初步過濾腦中訊息，主導戰或逃的反應 能產生強烈的基本情緒 中腦 決定事物與人際互動的意義 新皮質 可以思考複雜的問題，並利用推理找答案 你用新皮質推銷點子，但對方用鱷魚腦來接受 鱷魚腦怎麼接受訊息 無聊就忽略 只會宏觀（遺失細節）思考 ← 需要高對比、差異清晰的選項 對所見有情緒反應 只在乎當下、專注力短且渴望新奇 需要具體事實 ← 用確切證據，而不是抽象概念 Pitch 必勝心法 STRONG Setting the frame Telling the story Revealing the intrigue Offering the prize Nailing the hookpoint Getting the decision Ch 2 - 框架支配 框架： 人用來包裝自己影響、權威、實力、資訊和地位的工具 → 無論何時都要掌握話語權 對方框架 應對框架 針對衝動的人（權利框架） 權力瓦解框架 注重分析、錙銖必較（分析師框架） 吊胃口框架 人多勢眾、情況不樂觀 時間框架、大獎框架 時間約束框架 時間框架 隨時 大獎框架 其他應用 提到自己時間不多 → 強化時間、大獎框架 對方提出問題，但太細節 ← 用權利框架四兩撥千斤 權力框架（敵對框架） what 對方表現得態度傲慢、興趣缺缺 乖乖順從權威者只會鞏固對方的權利框架 權力瓦解框架 how 用略微出人意表但不討人厭的行為引起注意力，提升你的地位 e.g., 倔強的態度或淡淡的幽默 detailed in Ch 3 在小處拒絕對方 時間框架（敵對框架） 當聽眾注意力潰散，就表示快要衝撞時間框架了 e.g., 時間差不多了，該收尾了吧？ 如何應對 聽眾注意力下滑 → 好好掌握時間直接收尾，不要帶戲拖棚讓觀眾繼續失去注意力 對方提出不合理的時程要求 → 反過來要求對方要造原定的合理時程 分析師框架（敵對框架） what 對方不斷詢問細節 why 用這四點來弱化你的話術 只看冷冰冰的事實 認為美感或創意缺乏價值 一切必須有數字作證 認為理念和人際關係缺乏價值 如何應對 → 吊胃口框架 when: 重點在於 說故事的時機 ，而不是故事本身 發現對方持續詢問時，用故事讓對方脫離分析的思維 why 劫持對方高度認知的能力，喚起大腦的原始機制 熱認知和冷認知無法在人腦共存 熱認知： 慾望或興奮的感覺（故事） 冷認知： 分析和解決問題的過程（對方的分析師框架） 將對方注意力從細節拉回主講者上，並造原先的議程、時間、主題完成提案 how 分享切身並涉及主題的小故事（ 必須事前準備 ），並且只講一半（製造懸疑感） 吊人胃口的故事 簡短扼要 主題與當前相關 你是故事主角 涉及危險和不確定因素 時間壓力 → 必須立即採取行動 個人焦慮 → 你想行動卻因某阻力受挫 失敗後果不堪設想 被提問時應該如何回覆 回答精要資訊，再把聽眾注意力拉回提案本身 大獎框架 when: 對付快速接近的敵對框架，尤其你的地位可能處於劣勢時 what: 提高自己在對方眼中的價值 e.g., 很高興我終於有時間跟各位碰面了，不過會議結束，我還有下一場會議，話不多說，開始正題吧 why so effective? 人類行為三大基本模式 追逐失去的東西 想要得不到的東西 只在乎難得到的東西 how? 要買家證明自己夠格 e.g., 介紹一下你自己吧？為什麼我非得跟你談生意？ 捍衛自身地位，別讓買家更動討論，只要對方強行改動就退出 ❌ 不要用「成交試探」，只會讓人覺得你很急，進而交出主導權 聽到現在你有什麼想法 叫對方達成某項合理的任務才能敲定生意 e.g., BMW 特別車款會要求對方簽約維持車子清潔、定期保養特殊烤漆 Ch 3 - 人際地位 人際地位直接奠定的 pitch 的基礎 發號施令的 A 咖或唯命是從的 B 咖 到別人的地盤簡報 準時 → 遲到會失去更多掌控權 選好框架在最佳時機碰撞，而且越早越好，時間越長會越強化對方地位 避免鞏固對方地位的社交禮俗 樂在其中 → 吸引群眾，讓你打造並維持強大的框架 掌握情境地位 禮貌地無視彰顯權力的 B 咖陷阱 不受客戶固有地位動搖 在小處拒絕或倔強 → 強化框架、提升地位 奪得掌控權後，立即將討論導向專業領域，讓對方無法質疑 拉抬自身價值以建構大獎框架 確認你在 A 咖地位 → 讓客戶主動認可你的地位 Ch 4 / Ch 5 - 任何好點子都能賣 時間約束模式： 直接讓對方知道提案不會過長 → 減少對方排斥 提案跟簡報階段 介紹自己與好點子（5 mins） 說明開支與秘訣（10 mins） 提出合作條件（2 mins） 框架疊加和促進熱認知（3 mins） Phase 1 - 介紹自己與好點子 介紹自己只要講到重點成功經驗，千萬不要細數以往的經驗 機不可失框架（\"Why not\" Frame） 「變動」是框架最重要的元素 描述產品時要提供清楚的脈絡 → 三大市場力量 經濟： 因應哪些金融市場變化 社會： 因應哪些消費行為模式的變化 科技： 科技變革如何影響現有商業模式和消費需求 一分鐘介紹好點子 e.g, 對於 目標客戶 而言， 市場現有方案 差強人意。我的點子是 全新的點子 ，提供了 關鍵解決方案 。與 同類別服務 不同的是，我的點子 描述重要特點 Phase 2 - 說明開支與秘訣 注意力： 人感到慾望和壓迫的時候，就會專注於眼前的事物 慾望（多巴胺）→ 祭出獎賞 壓迫（去甲腎上腺素）→ 吊人胃口 Pitch 核心 數據和財測 競爭對手 新進怎麼搶生意 顧客為什麼要買新產品 獨門秘方 Phase 3 - 提出合作條件 清楚跟客戶說明雙方合作可帶來的好處，不用談到細節 給客戶的承諾、實現的時間和方法 如果對方也有參與，要交代對方的角色與責任 Phase 4 - 框架疊加和熱認知 (Ch 5) 為什麼熱認知重要？ 絕大多數針對不同選項搜集資料，並不是做決定的基準，而是用來合理化我們的決定 喚起熱認知的框架疊加技巧 吊胃口框架 進入故事模式 大腦討厭抽象概念，抽象概念都會進到新皮質，進行緩慢又辛苦的分析 要用人情故事（human narrative） 做類比說明 故事結構 把某人丟到叢林裡 讓他遭到攻擊 他能逃離險境嗎？ 讓他接近叢林邊緣，卻不讓他逃出 → 懸而未決的故事 祭出大獎 e.g. 領養動物時，你以為你是動物的大獎，反而被領養輔導員確認你有資格領養 自我認知： 我是大獎，你要努力取悅我，你要贏得我的肯定 時間框架 對決策施加時間壓力會影響決策品質， 但要給對方合理的時間 在公平和壓力間取得平衡 道德權威 Ch 6 - 別當纏人精 纏人會引發恐懼和不確定感，導致對方的鱷魚腦接管決策 反制自己渴求認同（開始纏人）的行為 無欲無求 專注自身長處 表明先行離開： 在別人以為你會窮追不捨的關鍵時刻抽身 Ch 7 - 魔王級案例研究：十億美元機場改建案 這章整篇都是案例研究，算是前面提到的所有技巧的應用 像是在看故事，稍微有點難筆記 不過還是記錄幾個我覺得蠻有意思的點 推拉範本 推力 「這個計畫很大膽嗎？這個好點子確實很大膽，我們認為膽試很重要。如果你不喜歡大膽的計畫，那我們可能無法合作，因為我的團隊就像新創企業，工作節奏明快，你們若像大公司那樣，做事一板一眼。這樣要怎麼合作呢？總之，我承認我們的計畫很大膽，彼此合作不來也沒關係。」 拉力 「不過話說回來，假如這個提案最後沒獲選，我們還是可以結合彼此的優勢，做一番了不起的事業。想像一下，各位的飛航經驗和熱情，搭配我們的策略和金融知識，簡直就像獲得超能力一樣，隨辦鎖定一個投資人，都能挑起對方內心的慾望 道德框架 開發機場的同事也照顧當地超過十萬名居民 大獎框架 「所以假如各位很愛「美國國歷史遺產」...... 歡迎前來我們公司開會，討論日後合作細節 」 Ch 8 - 正式投身 Pitch 戰局 七大步驟搞定 pitch 辨認與避開 B 咖陷阱 繞過 B 咖陷阱 辨認不同的社交框架，並留意生活中遇到的框架 挑安全目標下手，並展開框架碰撞 從小處拒絕，展現倔強態度 先退後拉，舉動必須不失柔軟 若遇到困難可能是態度太強硬，要適時休兵 Enjoy it 跟其他框架大師訓練","tags":"Book","url":"https://wei-lee.me/posts/book/2021/12/pitch-anyting","loc":"https://wei-lee.me/posts/book/2021/12/pitch-anyting"},{"title":"[Book] 讀懂一本書","text":"這本書我大概在三月就看完了 沒想到拖到現在才有時間好好做筆記 一些細節都忘得差不多了... 樊登讀書是中國很有名的講書平台 會注意到這個平台是很早期聽 podcast 聽到的，而且還聽到很多次 就不禁讓我好奇到底是什麼 當初買這本書的目的也很簡單 既然他這麼會講書，在如何輸入和輸出知識一定也有他的一套辦法 整本書看下來談的是樊登的讀書哲學跟講書經驗 跟原本預期會提供明確讀懂書的方法有些落差 但依然還是本蠻有趣的書 Note 閱讀的時候隨時問自己 能不能準確地把握這本書真正的含義，理解這本書？ 能不能用自己的語言表達出這本書真正的含義，且表達清楚？資訊效度和信度如何？ 表達出來的內容能不能讓沒有讀過這本書的人無障礙地理解？語言風格是否通俗易懂，能否被二次傳播？ 講書的五種必備能力 邏輯思維 ＊ e.g., 歸納法帶出的結論是需要警惕的 → 小心黑天鵝、倖存者偏差 大局觀 首先掌握書的大框架 接著分析 它要解決什麼問題？ 它的使命是什麼？ 麼論證這個使命？ 提出了什麼樣的假設？ 怎麼驗證假設？ 推理的過程是什麼？ 怎麼獲得這個證據？ 最後我們能得出一個什麼樣的結論？ 這個結論對我們每個人有什麼意義？ 語言能力 簡潔 幽默 說服力 語言表達怎麼更有力量，更有信服力？ 看優秀的電影，學習裡主角的表達方式 閱讀好的文字作品 同理心 你講的東西在別人身上會產生什麼樣的作用嗎？ 你知道對方關心什麼嗎？ 愛 講每一本書的時候都充滿了熱情 讀書的誤解 讀書只為了有用？ 有些書讀了不會有立竿見影的效果，但會潛移默化的改變你的想法 這本書我看不懂，還要看嗎？ 讀不懂並非沒有收穫，未來讀了更多書回來看可能就懂了 → 可以先讀其他接近的書 讀書是一件私事？自己讀的效果最好？ 跟人分享有機會得到比你理解力更高的人的回饋 選書原則 - TIPS原則 T（Tools）工具： 教給聽眾一套方法 I（Ideas）新的理念： 帶來一些新的理念、發現、想法 P（Practicability）實用性： 可以應用在日常生活 S（Scientificity）科學性： 經歷了科學性的驗證 如何快速閱讀抓住重點 → 提高基礎理解力的池子 理解力的池子有多大，你就能夠讀懂多難的書 經濟學 心理學 國學 管理學 邏輯學 哲學 作者推薦 看穿假象、理智發聲，從問對問題開始 活哲學：12位大師的「生命復甦術」 思辨與立場 人生經驗 畫線：什麼才是精華？ 概念被清晰界定的時候 問題很嚴重的時候 某種解釋令你很意外的時候 看出遞進關係的時候 看出轉折關係的時候，要留意轉折後的內容 不同面向彰顯書籍內在價值 當閱讀的時候感受到心靈衝擊 書中的奇聞逸事，增添講書的趣味性（就為了好玩）","tags":"Book","url":"https://wei-lee.me/posts/book/2021/11/understand-a-book","loc":"https://wei-lee.me/posts/book/2021/11/understand-a-book"},{"title":"DVC - Pipeline Versioning","text":"We've versioned our data in the previous post. This article will demonstrate how we could define a data pipeline and version it through DVC. Pipeline versioning We'll continue using dvc_example . You can checkout to tag v3-remove-2-rows to follow along. Split training logic into different stages In the original design, we use pipenv run python digit_recognizer/digit_recognizer.py to run the whole training process. We'll split them into process-data , train , and report stages. def main (): ...... if args . command == \"process-data\" : X , y = load_data ( \"data/digit_data.csv\" , \"data/digit_target.csv\" ) X_train , X_test , y_train , y_test = process_data ( X , y ) export_processed_data (( X_train , y_train ), \"output/training_data.pkl\" ) export_processed_data (( X_test , y_test ), \"output/testing_data.pkl\" ) elif args . command == \"train\" : X_train , y_train = load_processed_data ( \"output/training_data.pkl\" ) model = train_model ( X_train , y_train ) export_model ( model , \"output/model.pkl\" ) elif args . command == \"report\" : X_test , y_test = load_processed_data ( \"output/testing_data.pkl\" ) model = load_model ( \"output/model.pkl\" ) predicted_y = model . predict ( X_test ) output_test_data_results ( y_test , predicted_y ) output_metrics ( y_test , predicted_y ) You can view the complete code change on v3-remove-2-rows...v4-split-pipeline-logic . After these changes, we'll use the following 3 commands to run the pipeline. pipenv run python digit_recognizer/digit_recognizer.py process-data pipenv run python digit_recognizer/digit_recognizer.py train pipenv run python digit_recognizer/digit_recognizer.py report Add the first stage in our pipeline to DVC We add stages through dvc run command. Let's add our first stage process-data . # add process-data stage $ pipenv run dvc run --name process-data \\ -d digit_recognizer/digit_recognizer.py \\ -d data/digit_data.csv \\ -d data/digit_target.csv \\ -o output/training_data.pkl \\ -o output/testing_data.pkl \\ \"pipenv run python digit_recognizer/digit_recognizer.py process-data\" Running stage 'process-data' : > pipenv run python digit_recognizer/digit_recognizer.py process-data Creating 'dvc.yaml' Adding stage 'process-data' in 'dvc.yaml' Generating lock file 'dvc.lock' Updating lock file 'dvc.lock' To track the changes with git, run: git add dvc.yaml output/.gitignore dvc.lock Next, we add these DVC files into git to track. # add DVC configuration to git and commit $ git add dvc.yaml dvc.lock output/.gitignore $ pipenv run cz commit See what's composed of this command --name : the name of this stage It must be unique throughout the project. -d : the dependencies of this stage All the files related to running this stage should be counted as dependencies. DVC won't these dependency files into it storage but only store the hashes of them. In this example, we need digit_recognizer/digit_recognizer.py to load data/digit_data.csv and data/digit_target.csv to process the data. Thus, these 3 files are added as dependencies. -o : the output files of this stage DVC stores these files in its storage. If you want to track it through git or simply don't want to track it, you can use -O instead. dvc run runs the stage right after adding it. If you don't want DVC to run it, you can add --no-exec flag or dvc stage add with the same arguments After adding a stage, DVC updates dvc.yaml , output/.gitignore and dvc.lock dvc.yaml : the definition of stages stages : process-data : cmd : pipenv run python digit_recognizer/digit_recognizer.py process-data deps : - data/digit_data.csv - data/digit_target.csv - digit_recognizer/digit_recognizer.py outs : - output/testing_data.pkl - output/training_data.pkl DVC transforms what we defined in dvc run to a human-readable format and store it. But if you already know how to define the stage, you can edit dvc.yaml directly. In addition, there're advanced techniques like Templating and foreach stages that can help us define complicated stages. dvc.lock : the hashes of dependencies and outputs schema : '2.0' stages : process-data : cmd : pipenv run python digit_recognizer/digit_recognizer.py process-data deps : - path : data/digit_data.csv md5 : 942481fce846fb9750b7b8023c80a5ef size : 490582 - path : data/digit_target.csv md5 : 2a6cfa13365ac9b3af5146133aca6789 size : 3590 - path : digit_recognizer/digit_recognizer.py md5 : 65ecf27479538a74ade42462b1566db1 size : 3629 outs : - path : output/testing_data.pkl md5 : 78be1761d227f71b1a8f858fed766982 size : 529016 - path : output/training_data.pkl md5 : f95e8f978a05395ba23479ff60eda076 size : 528427 DVC uses these hashes to know whether there's any modification on our stages. Therefore, we only add deterministic files. Randomness might make this lock file meaningless. Take a look at the \"Avoiding unexpected behavior\" in dvc run - Description could save your time debugging unexpected failure. output/.gitignore : Add files that DVC should track to gitignore Define the whole pipeline With similar command, we can add train and report stages to our pipeline. # add train stage pipenv run dvc run --name train \\ -d digit_recognizer/digit_recognizer.py \\ -d output/training_data.pkl \\ -o output/model.pkl \\ \"pipenv run python digit_recognizer/digit_recognizer.py train\" # add report stage pipenv run dvc run --name report \\ -d digit_recognizer/digit_recognizer.py \\ -d output/testing_data.pkl \\ -d output/model.pkl \\ -o output/metrics.json \\ -o output/test_data_results.csv \\ \"pipenv run python digit_recognizer/digit_recognizer.py report\" # add DVC configuration to git and commit git add dvc.yaml dvc.lock model/.gitignore pipenv run cz commit Similar to our previous step, DVC updates dvc.yaml , dvc.lock and output/.gitignore . $ cat dvc.yaml ... train : cmd : pipenv run python digit_recognizer/digit_recognizer.py train deps : - digit_recognizer/digit_recognizer.py - output/training_data.pkl outs : - output/model.pkl report : cmd : pipenv run python digit_recognizer/digit_recognizer.py report deps : - digit_recognizer/digit_recognizer.py - output/model.pkl - output/testing_data.pkl outs : - output/metrics.json - output/test_data_results.csv We can visualize the pipeline through dvc dag $ pipenv run dvc dag +----------+ | data.dvc | +----------+ * * * +--------------+ | process-data | +--------------+ ** ** ** * * ** +-------+ * | train | ** +-------+ * ** ** ** ** * * +--------+ | report | +--------+ If you pay attention to each parameter passes to dvc run , you might have noticed that train stage depends on the output output/training_data.pkl from process-data stage. This is how DVC decides the order of each stage in our pipeline. Run the pipeline Contradict to its naming, dvc run is only used for defining the stage and run it for the first time. dvc repro (reproduce) is what we use to run the pipeline, $ pipenv run dvc repro 'data.dvc' didn 't change, skipping Stage ' train ' didn' t change, skipping Data and pipelines are up to date. Because we've not yet made any changes since we define our pipeline, DVC won't waste time and resources to generate results it has already known. However, you can add a -f flag to force DVC to rerun the pipeline. Next, we'll change gamma to 0.01 to see how dvc repro works. def train_model ( X_train , y_train , params ): ... clf = svm . SVC ( gamma = 0.01 ) ... Because our dependency digit_recognizer/digit_recognizer.py has been modified, DVC expects the result might be different. Therefore, we can now run dvc repro . $ pipenv run dvc repro 'data.dvc' didn 't change, skipping Running stage ' process-data ': > pipenv run python digit_recognizer/digit_recognizer.py process-data Updating lock file ' dvc.lock ' Running stage ' train ': > pipenv run python digit_recognizer/digit_recognizer.py train Updating lock file ' dvc.lock ' Running stage ' report ': > pipenv run python digit_recognizer/digit_recognizer.py report Updating lock file ' dvc.lock ' To track the changes with git, run: git add dvc.lock Use ` dvc push ` to send your updates to remote storage. By running git diff , you'll find out that the hashes of digit_recognizer/digit_recognizer.py , output/model.pkl , output/metrics.json , output/test_data_results.csv inside dvc.lock has been changed. Track parameters In the previous section, even though we change only the parameter related to the train stage, DVC still reruns the whole pipeline. To make DVC runs only the stages affect by the changed parameters, we can refactor our code to load parameters from a separate file params.yaml . def main (): params = load_params ( \"params.yaml\" ) X , y = load_data ( \"data/digit_data.csv\" , \"data/digit_target.csv\" ) X_train , X_test , y_train , y_test = process_data ( X , y , params [ \"process_data\" ] ) model = train_model ( X_train , y_train , params [ \"train\" ]) export_model ( model ) ...... This is how params.yaml looks like. process_data : test_size : 0.5 shuffle : false train : gamma : 0.01 Full code changes can be found on v5-parameters-in-separate-file . To add parameters to a stage, we'll need to run the previous dvc run command again with -f and -p flag. -f : overwrite the stage with the same name -p : parameters Use \",\" to separate parameters # Add parameters process_data.test_size and process_data.shuffle to process-data stage pipenv run dvc run -f --name process-data \\ -d digit_recognizer/digit_recognizer.py \\ -d data/digit_data.csv \\ -d data/digit_target.csv \\ -o output/training_data.pkl \\ -o output/testing_data.pkl \\ -p process_data.test_size,process_data.shuffle \\ \"pipenv run python digit_recognizer/digit_recognizer.py process-data\" # Add parameters train.gamma to train stage pipenv run dvc run -f --name train \\ -d digit_recognizer/digit_recognizer.py \\ -d output/training_data.pkl \\ -o output/model.pkl \\ -p train.gamma \\ \"pipenv run python digit_recognizer/digit_recognizer.py train\" # add DVC configuration to git and commit git add dvc.yaml dvc.lock model/.gitignore pipenv run cz commit DVC adds params key to both process-data and train stages in dvc.yaml . stages: process-data: ...... params: - process_data.shuffle - process_data.test_size train: ...... params: - train.gamma params.yaml is the default parameter file name, but DVC also supports YAML, JSON, TOML, and Python files . We only need to add the file name as an additional layer to params to use it. e.g., # this is an example of using different parameter file name # we don't need to make changes to our code train : ...... params : - params.json - train.gamma Let's change gamma to 0.1. We can check this change through dvc params diff . By providing git reference, we can even see parameters difference between different git commits. (e.g., dvc params diff HEAD~1 ) $ pipenv run dvc params diff Path Param Old New params.yaml train.gamma 0 .01 0 .1 If we run dvc repro now, DVC reruns only train and report stages. train stage is affected by train.gamma change. Due to this change, the output file from the train stage has been updated. Thus, DVC reruns report stages as well. $ pipenv run dvc repro 'data.dvc' didn 't change, skipping Stage ' process-data ' didn' t change, skipping Running stage 'train' : > pipenv run python digit_recognizer/digit_recognizer.py train Updating lock file 'dvc.lock' Running stage 'report' : > pipenv run python digit_recognizer/digit_recognizer.py report Updating lock file 'dvc.lock' To track the changes with git, run: git add dvc.lock Use ` dvc push ` to send your updates to remote storage. # reset gamma back to 0.01 $ git checkout dvc.lock params.yaml We're not going to store this parameter change. Run git checkout out params.yaml dvc.lock to restore the previous state. Track metrics We now know how to track parameters. Next, we'll see how changing these parameters affect the performance of our models. You may have already noticed that we've outputted a output/metrics.json file. Although we could track it as the output file, DVC has better support for metrics files. Like adding parameters, we add -m flag for DVC to recognize the output as metrics. Instead of using -M as the official tutorial did, I use -m because I prefer tracking metrics through DVC remote storage instead of saving it to git as part of our source code. # Add output/metrics.json as metrics to report stage $ pipenv run dvc run -f --name report \\ -d digit_recognizer/digit_recognizer.py \\ -d output/testing_data.pkl \\ -d output/model.pkl \\ -o output/test_data_results.csv \\ -m output/metrics.json \\ \"pipenv run python digit_recognizer/digit_recognizer.py report\" # add DVC configuration to git and commit $ git add dvc.yaml dvc.lock model/.gitignore $ pipenv run cz commit # metrics have been added to the report stage as expected $ cat dvc.yaml ... report: ...... metrics: - metrics.json: Use dvc metrics show to see how well our model performs Note that values are not calculated through DVC. DVC only provides a way to display values in file organized as tree hierarchies and compare them throughout different git commits. $ pipenv run dvc metrics show Path accuracy_score weighted_f1_score weighted_precision weighted_recall output/metrics.json 0 .69265 0 .74567 0 .91941 0 .69265 Change gamma to 0.1 again and use dvc metrics diff to see if model performance is improved after this change. # reruns the pipeline with new parameters $ pipenv run dvc repro # check metrics differences between unstaged and HEAD $ pipenv run dvc metrics diff Path Metric Old New Change output/metrics.json accuracy_score 0 .69265 0 .10134 -0.59131 output/metrics.json weighted_f1_score 0 .74567 0 .01865 -0.72702 output/metrics.json weighted_precision 0 .91941 0 .01027 -0.90914 output/metrics.json weighted_recall 0 .69265 0 .10134 -0.59131 # reset gamma back to 0.01 $ git checkout dvc.lock params.yaml We don't need this change either. Reset gamma back to 0.01 through git checkout plotting There's only one left output output/test_data_results.csv that has not yet been used. This file stores the ground truth and the predicted result from our model. We're going to use it to see how DVC plots our data. Before plotting, let's change gamma to 0.001 first and run dvc repro . Otherwise, the output plot will look a bit odd due to the low model performance. $ cat output/test_data_results.csv actual,predicted 4 .0,4.0 8 .0,8.0 ...... Add --plots flag and specify output/test_data_results.csv as the file to plot # add output/test_data_results.csv as the file to plot to report stage $ pipenv run dvc run -f --name report \\ -d digit_recognizer/digit_recognizer.py \\ -d output/testing_data.pkl \\ -d output/model.pkl \\ -o output/test_data_results.csv \\ -m output/metrics.json \\ --plots output/test_data_results.csv \\ \"pipenv run python digit_recognizer/digit_recognizer.py report\" # plots have been added to dvc.yaml $ cat dvc.yaml ...... plots: - output/test_data_results.csv DVC generates plots through Vega , a declarative grammar that can define interactive graph in JSON format. It supports linear plot, scatter plot, and confusion matrix by default. These templates are stored in .dvc/plots . We can also define our plots. (Read dvc plots - Custom templates to find out more) In the following example, we'll plot a confusion matrix through dvc plots show . $ pipenv run dvc plots show output/test_data_results.csv --template confusion -x actual -y predicted --out confusion_matrix.html file:///....../confusion_matrix.html --template : name of the plot template -x : field name of the data for the X-axis -y : field name of the data for the y axis --out : output file name The following is a screenshot of the generated plot. As of now, DVC does not track our plot (i.e. confusion-matrix.jpg ) but only our data to plot (i.e., output/test_data_results.csv ). Let's add plot as the final stage of our pipeline. # Add stage plot pipenv run dvc run -f --name plot \\ -d output/test_data_results.csv \\ -o confusion_matrix.html \\ \"pipenv run dvc plots show output/test_data_results.csv --template confusion -x actual -y predicted --out confusion_matrix.html\" Conclusion In this post, we create a data pipeline that process data, train the model, generate the report and visualize it. $ pipenv run dvc dag +----------+ | data.dvc | +----------+ * * * +--------------+ | process-data | +--------------+ * * ** * * ** +-------+ * | train | ** +-------+ * * * ** ** * * +--------+ | report | +--------+ * * * +------+ | plot | +------+ We also see how to use DVC to track each component and provide an easy way to run the pipeline. In the following article, we will discuss how to run experiments with different parameters and compare the results in an even more convenient way. One more thing: When should we save files to DVC instead of git? Short answer: It depends. When defining pipeline we can decide whether to save our outputs ( -o / -O ), metrics ( -m / -M ) and plots ( --plots / --plots-no-cache ) to DVC storage. DVC document suggests not storing metrics and plots to DVC as they are typically small enough for git to track. But I'd prefer storing only thing relates to our logic to git. That's why I use -m and --plots in the examples. If you don't want to track these, you could just pass -O , -M , or --plots-no-cache and add them to both .gitignore and .dvcignore . Reference DVC CS 329S: Machine Learning Systems Design","tags":"Tech","url":"https://wei-lee.me/posts/tech/2021/06/dvc-pipeline-versioning","loc":"https://wei-lee.me/posts/tech/2021/06/dvc-pipeline-versioning"},{"title":"DVC - Data Versioning","text":"About DVC (Data Version Control) What's DVC? version control system for data science and machine learning compatible with git (it's based on git) What can DVC do? track data model pipeline metrics use storage directly no external services needed Who are the targeted users of DVC? ML research / engineer DevOps & Engineers Why DVC? It links your data, model, and pipelines with your metrics. reproducibility trackable Read DVC - Versioning Data and Models for more use cases How to use DVC? Install DVC globally I suggest using pipx if you're to install DVC globally. However, an even better way is to install it inside the virtual environment within your project. $ pip install pipx $ pipx install dvc $ dvc --version 2 .3.0 DVC also provides Shell Completion and Syntax Highlighting Plugins for popular editors. Take a look at the example project I'll use dvc_example to demonstrate how I applied DVC to an existing machine learning project. The example is based on Recognizing hand-written digits from scikit-learn documentation. All the DVC parts start from v1-base . You can git checkout to the tag to follow along. $ git clone https://github.com/Lee-W/dvc_example/ --branch v1-base $ cd dvc_example $ tree . ├── LICENSE ├── Pipfile ├── Pipfile.lock ├── digit_recognizer │ ├── __init__.py │ └── digit_recognizer.py ├── docs │ └── README.md ├── mkdocs.yml ├── output └── tasks.py To set up the development environment, you'll need pipenv and invoke . If you run into an error when running pipenv install , you can run export SYSTEM_VERSION_COMPAT=1 before it. It's an open issue ( Issue with NumPy, macOS 11 Big Sur, Python 3.9.1 Does pipenv not use the latest pip? #4564 ) of pipenv as of now. Or, you can just run the following commands. # install needed tools pipx install pipenv invoke # set up environments invoke init-dev We'll use digit_recognizer/digit_recognizer.py for training a model that can recognize handwritten digits. def main (): X , y = load_data () X_train , X_test , y_train , y_test = process_data ( X , y ) model = train_model ( X_train , y_train ) predicted_y = model . predict ( X_test ) output_results ( y_test , predicted_y ) output_metrics ( y_test , predicted_y ) Install DVC into the virtual environment pipenv install dvc If you're to save data to remote storage, you might need to install extra dependencies. (e.g., pipenv install dvc[s3] ) Supported types [s3] [azure] [gdrive] [gs] [oss] [ssh] Or, use pipenv install dvc[all] to install them all Read dvc remote for more information Initialize DVC # initialize DVC configurations $ pipenv run dvc init # see what's created by DVC $ tree .dvc .dvc ├── config └── plots ├── confusion.json ├── confusion_normalized.json ├── default.json ├── linear.json ├── scatter.json └── smooth.json # track DVC configuration through git $ git add .dvc # git commit $ pipenv run cz commit Add DVC remote I'll use another local directory ../dvc_remote as our remote storage. You can change it to s3 or other remote storage. mkdir ../dvc_remote dvc remote add --default local ../dvc_remote Through --default flag, we can push/pull from local remote without specifying remote name. Let see what's changed in .dvc/config . $ cat .dvc/config [core] remote = local ['remote \"local\"'] url = ../../dvc_remote The url is ../../dvc_remote instead of ../dvc_remote because it's the relative path to .dvc . As we've not yet push anything to our pseudo remote, ../dvc_remote is still empty. Track data through DVC By this time, the data is loaded through sklearn.datasets.load_digits . We're going to change it to read from static file in data/ . def load_data (): # Load data digits = datasets . load_digits () ... We can use the following script to output the digit data into data/ . Note that it's a one-time use script. We won't add it into git. import os import pandas as pd from sklearn import datasets os . mkdir ( \"data\" ) digits = datasets . load_digits () df = pd . DataFrame ( digits . data ) df . to_csv ( \"data/digit_data.csv\" , header = False , index = False ) df = pd . DataFrame ( digits . target ) df . to_csv ( \"data/digit_target.csv\" , header = False , index = False ) We'll need to make changes to load_data and main functions to read data from these files. def load_data ( X_path , y_path ): with open ( X_path ) as input_file : csv_reader = csv . reader ( input_file , quoting = csv . QUOTE_NONNUMERIC ) X = list ( csv_reader ) with open ( y_path ) as input_file : csv_reader = csv . reader ( input_file , quoting = csv . QUOTE_NONNUMERIC ) y = [ row [ 0 ] for row in csv_reader ] return X , y ...... def main (): X , y = load_data ( \"data/digit_data.csv\" , \"data/digit_target.csv\" ) ...... Run pipenv run python digit_recognizer/digit_recognizer.py to check whether everything works as we expected. If so, add these code changes into git. Next, add data/ to DVC. $ pipenv run dvc add data 100 % Add | ████████████████ | 1 /1 [ 00 :00, 2 .14file/s ] To track the changes with git, run: git add data.dvc .gitignore dvc add creates a data.dvc file to track data/ and add it into .gitignore so that data/ will only be tracked through DVC but not git. # Add DVC files into git track git add .gitignore data.dvc # git commit pipenv run cz commit In data.dvc , we can see 2 files ( digit_data.csv and digit_target.csv ) are tracked. $ cat data.dvc outs: - md5: b8d81f4964ecb86739c79c833fb491f3.dir size: 494728 nfiles: 2 path: data Push these tracked data into DVC remote dvc push See what's changed in our repo storage ../dvc_remote $ tree ../dvc_remote ../dvc_remote ├── 02 │ └── b861b6dc8e08da6d66547860f69277 ├── 8c │ └── ba569595920d230ade453b150f372b └── b8 └── d81f4964ecb86739c79c833fb491f3.dir 3 directories, 3 files The md5 value of our tracked data is b8d81f4964ecb86739c79c833fb491f3.dir . There's also a corresponding file in ../dvc_remote/b8/d81f4964ecb86739c79c833fb491f3.dir . $ cat ../dvc_remote/b8/d81f4964ecb86739c79c833fb491f3.dir [{ \"md5\" : \"02b861b6dc8e08da6d66547860f69277\" , \"relpath\" : \"digit_data.csv\" } , { \"md5\" : \"8cba569595920d230ade453b150f372b\" , \"relpath\" : \"digit_target.csv\" }] % This file indicates where the actual data sources are stored in ../dvc_remote . In conclusion, if we want to know how data is stored through DVC, find the md5 value in *.dvc in our project find the path that matches this md5 value in our remote storage use the md5 value specified in the previous step to find the data sources in our remote storage But most of the time, we don't need to do so. We can leave the tracking work to DVC. Fetch data from DVC remote storage # temporary delete our data locally $ rm -rf data # check whether DVC actually tracks our data $ dvc status data.dvc: changed outs: deleted: data # bring our data back from remote storage $ dvc checkout data data ├── digit_data.csv └── digit_target.csv Add data changes into DVC To demonstrate how DVC track data changes, let's remove the last 2 rows from data/digit_data.csv and data/digit_target.csv . # check what's changed $ dvc status data.dvc: changed outs: modified: data # Add these changes to DVC and git $ dvc add $ git add data.dvc # git commit $ pipenv run cz commit # Push these changes to our remote storage $ dvc push The md5 value has been changed, and the size of our data is smaller than our previous record, 494728. $ cat data.dvc outs: - md5: a333e114a49194e823ab9a4fa9e33ee9.dir size: 494172 nfiles: 2 path: data More files are added to ../dvc_remote due to the data changes. You can follow the steps in the previous section to see what're actually store. $ tree ../dvc_remote ../dvc_remote ├── 02 │ └── b861b6dc8e08da6d66547860f69277 ├── 2a │ └── 6cfa13365ac9b3af5146133aca6789 ├── 8c │ └── ba569595920d230ade453b150f372b ├── 94 │ └── 2481fce846fb9750b7b8023c80a5ef ├── a3 │ └── 33e114a49194e823ab9a4fa9e33ee9.dir └── b8 └── d81f4964ecb86739c79c833fb491f3.dir 6 directories, 6 files Let's git checkout to the previous git commit to see what happens if we only revert the changes in data.dvc . # or \"git checkout v2-track-data\" git checkout HEAD~1 After running wc -l data/digit_data.csv , we'll still find 1795 rows instead of 1797 rows in the previous stage. That's because we need to run dvc checkout as well. We might easily forget this step. Thus, DVC implements a git-hook that can trigger dvc checkout right after git checkout . You can install these git-hooks through dvc install . These hooks are added into .git/hooks . If you want to know the detail of what's added, read dvc install . Test these steps again. There should be an additional line after running git checkout . This is the output message of dvc checkout . M data/ Push our code to a remote git repository git remote add origin <REMOTE GIT REPO> git push origin main Fetch code and data changes from remote We've already pushed all the code and data changes to remote. Let's see how we could reproduce in another environment. # check what's in our repo $ dvc list <REMOTE GIT REPO> .dvcignore .github .gitignore LICENSE Pipfile Pipfile.lock data data.dvc digit_recognizer docs mkdocs.yml output tasks.py Although git does not track data/ , we can still list it through DVC. Because we use relative path ../dvc_remote as DVC remote storage, we need to create the new project in the same layer as dvc_example . We'll clone the project into ../dvc_example_on_another_machine . # Clone repo git repo $ git clone <YOUR REMOTE GIT REPO> ../dvc_example_on_another_machine $ cd ../dvc_example_on_another_machine $ tree . . ├── LICENSE ├── Pipfile ├── Pipfile.lock ├── data.dvc ├── digit_recognizer │ ├── __init__.py │ └── digit_recognizer.py ├── docs │ └── README.md ├── mkdocs.yml ├── output └── tasks.py 3 directories, 9 files As you can see, data/ has not yet been added to the project. We can now pull data from our DVC remote storage. # pull data from default DVC remote storage $ dvc pull A data/ 1 file added and 2 files fetched # `data` has now been added to the project $ tree . . ├── LICENSE ├── Pipfile ├── Pipfile.lock ├── data │ ├── digit_data.csv │ └── digit_target.csv ├── data.dvc ├── digit_recognizer │ ├── __init__.py │ └── digit_recognizer.py ├── docs │ └── README.md ├── mkdocs.yml ├── output └── tasks.py 4 directories, 11 files That's all for data versioning in DVC. In the next post, We'll continue on versioning a data pipeline, tracking parameters and metrics. We won't need dvc_example_on_another_machine for the following steps. Feel free to remove it and change directory back to dvc_example . Reference DVC CS 329S: Machine Learning Systems Design","tags":"Tech","url":"https://wei-lee.me/posts/tech/2021/06/dvc-data-versioning","loc":"https://wei-lee.me/posts/tech/2021/06/dvc-data-versioning"},{"title":"[Book] 最高學以致用法","text":"這也是去年參加 MOPCON 聽大大推薦的書之一 主要講如何透過輸出（e.g., 分享、寫文章）來學習 它提供了 80 個不同面向，可以直接運用到生活中的做法 對於看過很多如何學習的書，卻不知如何下手的人也許會有幫助 整體來說有點過度正向，稍微有點雞湯感（笑 這次我蠻大幅度的重新編排看完的筆記 所以順序會跟書有一點不同 Note 輸出基本法則 兩週內運用超過三次的情報，就會轉為長期記憶 成長的螺旋梯： 輸入 → 再輸出 → 再繼續輸入 輸入和輸出的黃金比例為 3：7 檢視輸出結果，將經驗活用在下一次 關於溝通與討論 委婉而確實的說話術 Yes But 先提出正面情報，接著再提出壞消息 Yes And 正面情報後，再提出正面情報 e.g., 最近銷售業績有進步，做得很好。如果再做到遵守時間，就更完美了 Yes How 不直接提出壞消息，而是以疑問句的方式，激發對方的反思 e.g., 最近銷售業績有進步，做得很好。我們來想想，怎麼做可以變得更好 我怎麼覺得舉例聽起來有點像反諷 🤔 拒絕公式： 「道歉（感謝）＋ 理由 ＋ 拒絕 ＋ 替代方法」 沒有人生來就善於討論 事前準備 擬定「假設問答」或「Q&A集」 第一個提出意見 心理學實驗發現，會議流程會受「最先提出的意見」很大的影響 E-mail 一早收發e-mail的時間，控制在五分鐘內 集中收信（大部分的人，檢查信箱的次數太多了） 「當下」立即回信 避免待回訊息分散注意力 讀完信馬上回覆已讀訊息 e.g., 我會在三天內給您詳細回覆 等負責的同事回來之後，會再給您回覆 尊重對方的時間 把 e-mail 和訊息（IM）分開使用 放空的重要性已經獲得證實 放空、發呆的狀態下，大腦的預設模式網絡（default mode network，簡稱DMN）會活動頻繁 大腦會模擬接下來身體可能發生的事，或是針對過去的經驗、記憶做整理、統合，或是對自己目前的狀況做分析。透過這些各種推想和記憶，在腦內做好「接下來讓自己變得更好的準備」 很多人覺得「放空」浪費時間，所以把時間用來滑手機、玩電玩、看電視。這樣不斷使用大腦，會阻礙預設模式網絡的運作，導致大腦疲憊 這點還蠻有意思的 🤔 不過我留下來很大的主因是想提醒自己花太多時間滑手機 😆 關於目標 設定具體目標 難易度定在「稍微困難」 設下期限 加上「TO DO」 找到客觀評價的方法 分成小目標 實現目標 每天再回頭檢視目標 宣告自己的目標 定期做反饋 做筆記 看書時，邊看邊記錄想法 → 加深對內容的理解 如何做筆記 不要寫得過於詳細 已經知道的事，不必再做筆記，有所發現、重要的部分才做筆記 一場兩個小時的講座 → 兩頁 三個覺察 三點TO DO 用 140 個字鍛鍊「摘要能力」=「思考力」 看完書或電影後，把內容感想做成摘要，貼到推特上 可以要求自己要在五分鐘之內完成 用 Twitter 訓練筆記能力 😆 沒有時間輸出？ → 善用零碎時間 短時間也沒關係，先決定好時限再開始做 → 提升效率 可以利用馬表或計時器來計時 → 提升專注力 e.g., 告訴自己「在十五分鐘內寫好讀後感想」 寫什麼？ 寫日記 - 最簡單、效果最好的輸出訓練法 養成輸出的習慣 鍛鍊自我洞察力 → 提升自省能力 排解壓力 寫日記 - 具體寫法 先從花「五分鐘」寫「三行」開始 針對整天發生的事，選「三件事」來寫 不要求質和量，重點是「每天寫」 事先決定時限 記錄健康狀態 早上量體重 → 激勵自己健身以及注意飲食 早上紀錄一醒來的狀態 e.g., -5 ～ +5 共11分，來評估當天的狀態，普通是「0」 睡眠時間 → 確保七個小時以上 為了做到睡眠管理，就必須每天記錄睡眠時間 寫讀後感想 - 讀後感想的範本 「Before」＋「發現」＋「TO DO」 Before： 讀書前有什麼疑惑、困擾 After： 原本的問題，透過讀完書，獲得什麼樣的解決 發現 TO DO 發送情報 得不到正確的反饋，成長速度慢 提升寫作力，鍛鍊輸出力 吸引情報和眾人靠近 透過網路，會得到許多抱持肯定態度的讀者給予的情報，包含自己不知道、或是不可能得知的情報 寫部落格 Write a Blog 成為「人氣部落客」的三大祕訣 一定要有獨立網域 每天更新 100－300－1000法則 > 100篇： 每天都會有固定的人來看部落格 > 300篇： 文章會顯示在搜尋引擎結果的前幾頁當中 > 1000篇： 顯示在搜尋引擎第一頁的文章愈來愈多 現在我是每兩週更新，每天更新實在太難了...... 寫興趣 - 針對自己擅長的主題寫 愈專精的內容愈好 愈是在意多數讀者，只是「寫一般讓大家看得懂的內容」，反而反應會變得冷淡 寫出「感想」、「意見」、「發現」 e.g., 讀者認同的不是看過電影的事實，而是看完電影的感想 喚醒讀者的「感情」和「行動」 如何持之以恆 用愉快的心情實踐 從中發現快樂 把目標做細分 記錄結果 做出結果就犒賞自己 如果達成目標就能獲得犒賞，可以刺激多巴胺分泌","tags":"Book","url":"https://wei-lee.me/posts/book/2021/02/the-power-of-output","loc":"https://wei-lee.me/posts/book/2021/02/the-power-of-output"},{"title":"2020 發文頻率分析 - 回顧 2020 我所寫的文章","text":"為了方便的嵌入下面的幾張圖（它們是可互動的哦！） 這我第一次使用 reStructuredText 寫文章 雖然產生的格式應該大同小異就是了 完整歷史資訊 我從 2013 年底開始寫文章 第一篇文章是 [C++] 如何 create thread 應該是整理別人寫好的文章，變成自己看得懂的內容 畢竟當初寫部落格的初衷，只是寫給自己的筆記 反正都寫了，不如就分享出來吧 包含這篇文章，在兩個部落格總共寫了 163 篇文章 平均每年寫 20 篇文章 其中 2017 ~ 2018 整年連一篇文章都沒有 有一半的文章是在 2018 八月以後才寫的 那之後的第一篇文章是 從 Andromoney 到 MOZE 還不小心釣到 MOZE 的作者（笑 我寫的內容有一半被我歸類在 Tech（我把扯得上技術的東西都歸在這了） 曾經有一度懷疑，我是不是把這個部落格變成書摘部落格 不過看來書摘的文章數從來沒有超過技術文 總共整理了 39 則書摘 目前最推薦的書還是前期看的 為什麼我們這樣生活，那樣工作 ? 跟 少，但是更好 2019 後期，我又開了另一個部落格 Meet people around the world 那段時間遊牧了一些國家，想寫遊記才創的 但到現在跟旅遊相關的文章 恩... 2 篇...... 都是我去 Galaxy's Edge 的紀錄 其實有蠻多旅遊的內容想寫，但一直沒提起勁好好寫 所以現在就變成動畫評跟料理紀錄了 😆 2020 年 2020 總共寫了 41 篇文章，大約是總文章數的 1/4 自從六月下旬加入 PyCon TW 的讀書會，我每兩週都得產出一篇文章 就這張圖來看，有同儕督促的效果還蠻不錯的 所以我說「好志工，不當嗎？」 👉 PyCon Taiwan 志工招募 年末時，我沈迷於重現「衛宮家今日的餐桌風景」的料理（最近好像更沈迷了） 剛好又遇到聖誕節年假，才會導致後面的文章數飆升 二月多的飆升則是因為寫了 Python Table Manners 系列 還好有 Python Table Manners 系列 即使後期我都在寫其他文章，技術相關文章還是多一點 這系列的文章，我到現在還是常常回來翻，有新的東西也都有更新上去 今年希望能寫更多的技術文章 因為去年強者我同事寫了 Airflow 動手玩 ， airflow 2.0 又出了 今年可能會寫跟 airflow 比較相關的文章吧 🤔 原本 Review 類的文章，是想看完什麼作品就寫一篇 但我發現實在沒那麼多時間 文筆也沒好到每部作品都能寫得夠長 所以就變成每一季會紀錄我看了什麼作品 啊...倒是去年寫的書摘，竟然只有 6 篇 真的是太少了@@ 今年也要多花點時間看書 總之，既然都開發了 [pelican-stat]( https://github.com/Lee-W/pelican-stat ) 我應該之後年初都會寫一篇這樣的文章吧 😆","tags":"Gossiping","url":"https://wei-lee.me/posts/gossiping/2021/02/post-frequency-analysis","loc":"https://wei-lee.me/posts/gossiping/2021/02/post-frequency-analysis"},{"title":"2020 發文頻率分析 - 如何在 pelican 頁面中嵌入 HTML","text":"因為不想在文章裡面直接寫 HTML（主要是不想自己去調大小、風格什麼的） 我花了點時間研究要怎麼樣正確且優雅（？）的在 pelican 中嵌入 HTML 不過當我把它們放到 pelican 的專案目錄下後 就會因為這些 HTML 沒有 title 造成錯誤 ERROR : Skipping .../ content /static/post-static/2021-post-frequency/ all . html : could not find information about 'title' WARNING : Meta tag in file .../ content /static/post-static/2021-post-frequency/ 2020 - by - category . html does not have a 'name' attribute , skipping . Attributes : charset = \"utf-8\" 看起來是 pelican 把它們也當作文章 ERROR: Skipping extra/XXXXX.html: could not find information about 'title' 中也有人遇到同樣的問題 只要在 pelicanconf.py 加上設定，讓 pelican 不要去讀 HTML READERS = { \"html\" : None } pelican 的文件 including-other-files 有提到 reStructuredText 有原生支援 如果是 markdown 就得安裝 mdx_include 沒想到這個套件用下去我的建置時間從幾秒鐘飆升到幾分鐘... 最後我只好妥協用 reStructuredText 來寫下一篇文章 .. raw :: html :file: ../../../static/post-static/2021-post-frequency/all.html","tags":"Tech","url":"https://wei-lee.me/posts/tech/2021/01/post-frequency-analysis-how-to-embed-html-in-pelican","loc":"https://wei-lee.me/posts/tech/2021/01/post-frequency-analysis-how-to-embed-html-in-pelican"},{"title":"2020 發文頻率分析 - 如何得到 pelican 文章資訊並用來做圖","text":"原本只打算發篇文簡單回顧 2020 年我寫了什麼文章 沒想到就慢慢演變成開發 pelican-stat ...... 原本只打算寫一篇的回顧文，就莫名其妙變成了三篇文章的系列文 如何得到 pelican 文章資訊並用來做圖 ： 就是本文，主要會聊開發 pelican-stat 的過程 如何在 pelican 頁面中嵌入 HTML ： 將產生的互動式趨勢圖嵌入 pelican 的文章中，遇到的各種雷 2020 過去了，我寫了什麼文章 ： 2020 主要發了什麼文章，並聊聊當初為什麼會想寫這些文章 什麼是 pelican-stat pelican 是用來產生靜態網頁的工具，最常見的用途應該是寫部落格 你所看到的這個部落格就是透過這套工具產生的 pelican-stat 則是我這次開發來蒐集pelican 文章資料並作圖的工具 如何使用 pelican-stat 安裝 因為我把 pelican 的版本定在 4.5.4 為了避免跟你的 pelican 版本打架，強烈建議使用 pipx 安裝 pipx install pelican-stat pelican-stat 目前支援 collect 和 plot 兩種指令 Usage: pelican-stat [ OPTIONS ] COMMAND [ ARGS ] ... Options: --help Show this message and exit. Commands: collect Collect data from pelican project and export article metadata plot Draw trend plot based on the frequency of new posts collect 將文章的資訊整理並輸出成 json 檔 e.g., [ ... , { \"timestamp\" : 1560308220.0 , \"category\" : \"Travel\" , \"authors\" : [ \"Lee-W\" ], \"reader\" : \"markdown\" , \"status\" : \"published\" , \"tags\" : [ \"Star Wars\" , \"Galaxy's Edge\" ], \"timezone\" : \"Asia/Taipei\" , \"title\" : \"Star Wars: Galaxy's Edge - First Peek\" } ] 第一個參數吃的是 pelican 的設定檔，第二個則是輸出的位置 plot 就如同指令的名稱，它就是拿來做圖用的 目前只支援趨勢圖 使用上比 collect 複雜一點，有 5 個可以設定的參數 --pelican-conf-path [PATH] ： pelican 設定檔的路徑 --articles-metadata-path [PATH] ： 用 collect 指令所產生的文章資料 json 檔的路徑 上面兩個一定要有一個有值，不然 pelican-stat 不知道要去哪抓文章資料 --output-path [PATH] ： 輸出檔名 --year [YEAR] ： 篩選特定年份的文章 --groupby-category ： 作圖是否要根據文章類別分群 最後就能做出像這樣的圖 產生的會是可以互動的 HTML 檔案 設計 pelican-stat 在開始寫 pelican-stat 前，我有找到類似的工具 👉 panorama 不過它是作為 pelican-plug 來使用，而不是獨立的指令列工具 所以就只好自己來寫了 collect 第一個收集文章資訊的想法是寫 parser 去解析這些文章 但是這麼做的話，這個工具可能就很難被其他人使用 每個人指定 metadata 、放置文章的方式可能都不同 甚至有人根本是用 reStructuredText 寫的 （pelican 支援 reStructuredText 跟 markdown） 不過有個工具一定有辦法抓到這些資訊 沒錯💡 那就是 pelican 本身！ 所以第二個想法是觀察 pelican 怎麼去解析這些文章 如果能的話，直接呼叫它的函式，不要重造輪子 從使用 pelican 指令到產生文章，會用這個順序追朔程式碼 pelican/__main__.py#L9 pelican/__init__.py#L491 pelican/__init__.py#L501 pelican/__init__.py#L403-418 這就是為什麼我的 _get_pelican_instance 會這樣寫 而我額外多做了兩個處理 settings [ \"PLUGINS\" ] = [] settings [ \"MARKDOWN\" ] = {} 原因是 MARKDOWN 跟 PLUGINS 都有可能有額外的相依套件 尤其是 pelican 自從 4.5.0 之後開始支援從 pip 安裝的 pelican-plugins 但它們對文章的 metadata 大多不會有影響 所以將他們從設定中清掉可以避免遇到相依套件沒裝的問題 接著繼續追程式碼 pelican/__init__.py#L527 pelican/__init__.py#L85-100 我透過 pdb 看到 generators[0] 是 ArticlesGenerator 看起來透過它就有很大的機會能取得文章資訊 它也會對應到我所寫的 pelican_stat/collector.py#L29-L43 這裡也是我會把 pelican-stat 相依的 pelican 釘在 4.5.4 的主因 _get_generator_classes 在 4.5.2 以前是 get_generator_classes 雖然可以用 getattr(pelican_instance, \"get_generator_classes\") 來支援不同的版本 但難保 pelican 什麼時候又會改 API 而且即使 pelican 的版本不同，對於文章 metadata 的格式應該都不會有改變 所以作為一個工具，使用特定版本的 pelican 應該就足夠了 最後在 pelican/__init__.py#L111-L113 執行完 generate_context() 就能從 article_generator.aricles 取得文章 而每篇文章都是 pelican.context.Article 的 instance 所以只要看裡面有哪些資訊是我要的，在進行輸出就可以了 👉 pelican_stat/collector.py#L47 plot 最初版測試用的 script，先了用我比較熟悉的 bokeh 寫 但上次有朋友安利我 ploty 很好用，就決定來玩玩看 使用上覺得兩個函式庫都還蠻直覺的 但 ploty 可以不用多做設定就有 hover tool ，還蠻方便的 因為這部分的程式碼大多都是看文件就能找到，就不特別聊了","tags":"Tech","url":"https://wei-lee.me/posts/tech/2021/01/post-frequency-analysis-how-i-get-pelican-article-data-and-plot","loc":"https://wei-lee.me/posts/tech/2021/01/post-frequency-analysis-how-i-get-pelican-article-data-and-plot"},{"title":"Python Table Manners 番外 - 編輯器","text":"在最開始的規劃中，並沒有想要寫編輯器 不過半年前（可能更久以前...），朋友有建議可以寫這個主題 上次去 Taichung.py 分享也有人提問 就稍微整理我在用的編輯器 我主要用的編輯器是 neovim 有時候會稍微用一下 Visual Studio Code 需要輸入中文或只是快速瀏覽會開 sublime IDE 如果是習慣用 IDE 的人，我推薦用 Visual Studio Code 看完官方的 Python in Visual Studio Code 應該就能弄懂大部分的功能了 文字編輯器 文字編輯器，我推薦 neovim，用起來跟 vim 差不多 至於要看我怎麼設定 vim 的話，可以參考 vim-setting 另外推薦 Real Python 寫的 VIM and Python – A Match Made in Heaven 好用的 vim 套件 這裡整理一些我很推薦的套件們，其他套件要不要用就看個人習慣了 Python 相關 python-mode Python 相關功能的集大成，裝了這個大概就有八成的功能了 black 在 vim 內執行 black vim-isort 在 vim 內執行 isort 通用 vim-test 在 vim 內執行測試（支援 20 種以上的程式語言） vim-easymotion 快速在 vim 內跳轉，點進去看文件的動畫更容易知道這個工具在幹嘛，它好用到我會為了用它在瀏覽器裝 vim 套件 Firefox 🦊 套件： Vimium-FF fzf： 快速在 vim 內做文字、檔案搜尋 需要同時安裝 fzf 和 fzf.vim","tags":"Tech","url":"https://wei-lee.me/posts/tech/2021/01/python-table-manner-editor","loc":"https://wei-lee.me/posts/tech/2021/01/python-table-manner-editor"},{"title":"Python Table Manners - Cookiecutter 專案模板","text":"Python Table Manners 系列 整理了各種開發 Python 專案能用到的工具們 如果每次重新開啟新專案都得重複設定的步驟就很浪費時間 所以我將它們整理成專案模板 cookiecutter-python-template 下次創立新專案的時候，只要透過這個模板就能快速產生已經設定好的空白專案 這篇文章會跟大家聊聊如何使用這個專案模板和如何建立自己的專案模板 什麼是 Cookiecutter？ Cookiecutter 是以 Python 撰寫，透過已有的專案模板產生新專案的工具 雖然是用 Python 撰寫，但不限於只能使用在 Python 專案 甚至也不太需要會寫 Python，就能製作屬於自己的專案模板 目前在 Github 上，已經有超過 5,000 個已經製作好的 cookiecutter 模板 相較於每次都從前一個專案或空專案複製設定的做法 Cookiecutter 能確保我們不會少代換掉舊的設定（e.g., 舊專案名稱） 並減少需要代換這些內容的人力 如何使用 Cookiecutter 模板？ 以我製作的模板 cookiecutter-python-template 為例 首先要安裝 cookiecutter ，建議使用 pipx pipx install cookiecutter 再來要指定產生新專案要用的模板 cookiecutter https://github.com/Lee-W/cookiecutter-python-template 接著會進入互動式介面，詢問專案相關的設定 每個問題依序會以 值 [預設值]: 使用者輸入 的形式出現 有的 值 會因為前面的回答不同，而產生對應的預設值 值 (e.g., python_table_manners) 會被帶回專案模板去取代模板中的變數 (e.g., project_slug) project_name [ Python Project ] : python table manners project_slug [ python_table_manners ] : project_description [ Short Descirption for Python Project ] : example for cookiecutter template github_username [ Lee - W ] : github_url [ http : //github.com/Lee-W/python_table_manners]: author_name [ Wei Lee ] : author_email [ weilee . rx @ gmail . com ] : test @ test . com python_version [ 3.7 ] : 3.9 Select dependency_management_tool : 1 - pipenv 2 - poetry Choose from 1 , 2 [ 1 ] : 2 use_strict_mypy_config [ n ] : n Select open_source_license : 1 - MIT license 2 - BSD license 3 - ISC license 4 - Apache Software License 2.0 5 - GNU General Public License v3 6 - Not open source Choose from 1 , 2 , 3 , 4 , 5 , 6 [ 1 ] : 1 所有問題都回答完之後就會出現新的資料夾 python_table_manners （模板以 project_slug 作為產生的資料夾名稱） 可以看到資料夾裡面已經有前幾篇提到會用到的相關檔案 $ tree python_table_manners . ├── CHANGELOG.md ├── LICENSE ├── docs │ ├── README.md │ └── contributing.md ├── mkdocs.yml ├── pyproject.toml ├── python_table_manners │ ├── __init__.py │ └── python_table_manners.py ├── setup.cfg ├── tasks │ ├── __init__.py │ ├── build.py │ ├── common.py │ ├── doc.py │ ├── env.py │ ├── git.py │ ├── secure.py │ ├── style.py │ └── test.py └── tests ├── __init__.py └── test_python_table_manners.py 4 directories, 20 files 如何製作 Cookiecutter 模板？ 在新的專案內，先開個名稱為 {{ cookiecutter.project_slug }} 的資料夾 所有模板的內容都將放在這裡 e.g., cookiecutter-python-template/{{ cookiecutter.project_slug }} 接著將想問使用者的問題寫進 cookiecutter.json 可以參考 cookiecutter-python-template/cookiecutter.json key 就是詢問使用者的問題，value 就是預設值 對 jinja2 熟悉的讀者，可能看到 {{ }} 就發現了 cookiecutter 背後是透過 jinja2 來取代這些值 模板中所有 {{ cookiecutter.key_from_cookiecutter_json }} 都會被代換成 cookiecutter.json 裡面的值 因為是使用 jinja2 ，當然也能運用它方便的語法 並且不限定於模板內才能使用，甚至在 cookiecutter.json 裡面都能使用 e.g., { \"project_name\" : \"Python Project\" , \"project_slug\" : \"{{ cookiecutter.project_name.lower().replace(' ', '_').replace('-', '_') }}\" , ... , \"_template_version\" : \"0.6.1\" } （from cookiecutter-python-template/cookiecutter.json @ 0.6.1 ） 如果有一些值不想問使用者，可以在 key 的最前面加上 _ (e.g., _template_version ) 當然也能使用 jinja2 的 if/else 語法，針對使用者的回答產生不同的模板內容 以下的範例就是使用者選擇不同的 dependency_management_tool 時，env.py 的指令內容會跟著改變 @task def init ( ctx ): \"\"\"Install production dependencies\"\"\" { % if cookiecutter . dependency_management_tool == 'pipenv' -% } ctx . run ( \"pipenv install --deploy\" ) { %- elif cookiecutter . dependency_management_tool == 'poetry' -% } ctx . run ( \"poetry install --no-dev\" ) { %- endif % } （from cookiecutter-python-template/{{cookiecutter.project_slug}}/tasks/env.py @ 0.6.1 ） 除了預設基本的 jinja2 語法外， cookiecutter 還提供了常用的 jinja2 extensions 這些可以在 Template Extensions 找到 比較可惜的是 Cookiecutter 並不支援追加問答 假設你想在使用者回答 dependency_management_tool 後 因為使用者選擇了 poetry，接續問要用哪個 poetry 版本 但當使用者選 pipenv 則不問這個問題 這樣的設計在 cookiecutter 是做不到的 （Read the discussion 👉 Conditional follow-up questions based on prior answers #913 ） hook 如果有嘗試用我的專案模板產生專案，並且選擇不同的 dependency_management_tool 你會發現在選擇 pipenv 的時候會有 Pipfile，但選 poetry 的時候不會有 這就是透過 post_gen_project.py 做到的 cookiecutter-python-template/hooks/ 中，可以看到以下兩個檔案 pre_gen_project.py : 建立專案前要執行的內容 post_gen_project.py : 建立專案後要執行的內容 在 post_gen_project.py 中會做判斷，只要使用者不是選 pipenv ，就會把 Pipfile 刪除 def main (): if \"{{ cookiecutter.dependency_management_tool }}\" != \"pipenv\" : remove_pipfile () （from cookiecutter-python-template/hooks/post_gen_project.py ） （Read more 👉 Using Pre/Post-Generate Hooks (0.7.0+) ） Reference Python Application Layouts: A Reference audreyr/cookiecutter-pypackage wemake-services/wemake-python-package How to set up a perfect Python project Understanding Best Practice Python Tooling by Comparing Popular Project Templates","tags":"Tech","url":"https://wei-lee.me/posts/tech/2021/01/python-table-manners-cookiecutter","loc":"https://wei-lee.me/posts/tech/2021/01/python-table-manners-cookiecutter"},{"title":"Python Table Manners - 持續整合/部署","text":"這篇好像真的拖得很久... 原本預定的發表時間還是 2020-03-04 呢 ...... 總之，剛好年假就趁機補一下 在使用 GitHub Actions 前，這篇原本要寫 drone 的使用方式 不過既然是放在 GitHub 上的開源專案，好像沒理由不用 GitHub Actions （但其實只是我當時想玩玩沒碰過的新東西） 同樣會延續之前舉例的專案 pycontw-postevent-report-generator (以下會簡稱 rg-cli）來講為什麼要用、如何使用 GitHub Actions 想解決的問題 先從這樣的工具能解決什麼問題開始聊起 假設你是某開源專案的維護者，設定好專案程式碼風格檢查跟自動化測試 有個貢獻者提交了一個 pull request 給你審核 審核完準備要 merge 的時候，才發現他的 pull request 測試跑不過 這可能就會浪費你前面大部分審核的時間 如果能在貢獻者 push 完，自動就做檢查 確認已經通過基本的檢查，才讓人工介入（維護者審核） 那就能省下你很多時間 當這個 pull request 通過所有測試和人工審核，merge 回 master 分支之後 接下來就要讓服務上線或是發佈套件，而這些步驟通常都很重複性且繁瑣 如果自動化這些步驟就能省下人工成本，並減少人為失誤 如何套用到 rg-cli ? 簡單先將想做的事分為三個步驟 前一步通過才可以執行下一步 當貢獻者提交 pull request 後，自動執行風格檢查、跑測試 當 pull request 被維護者 merge 回 master 分支之後，根據 git commit 更新版本號並產生 git tag ，最後再將 git tag 推回 master 分支 （如果不太知道這段在做什麼，可以參考 Commitizen: 規格化 commit message ) 當 master 分支偵測到新的版本號（git tag）產生後，自動將新的套件上傳到 PyPI GitHub Actions 實例 接下來看 pycontw-postevent-report-generator/.github/workflows/ @ 3ff174 中的三個檔案，分別對應到前面所提的三個步驟 python-check.yaml merge-into-master.yaml python-publish.yaml Python Check 每個 GitHub Actions 的 workflow 都需要有一個名稱 name : python check 這會顯示在 Actions > Workflows 中 接著要指定哪些事件發生時要執行這個 workflow (See more 👉 Events that trigger workflows ) on : [ push , pull_request ] 再來則是要在哪執行、執行什麼 jobs ： workflow 要執行的 job ，可以有超過一個 job。每個 job 都必須給它一個 job id (e.g., check) run-on ： 要跑在哪種機器上 （More option 👉 jobs. .runs-on ） steps : 要執行的 step name : step 的名稱 use : step 要使用哪個 action，可以用在 GitHub Marketplace · Actions 找看看有沒有別人已經寫好的 action 不用重造輪子 with : 輸入 actions 的參數 run : 要執行的指令（ | 是 yaml 的斷行） jobs : check : runs-on : ubuntu-latest steps : - name : Check out uses : actions/checkout@v2 - name : Set up Python uses : actions/setup-python@v1 with : python-version : \"3.7\" - name : Install dependencies run : | python -m pip install pipenv invoke inv env.init-dev -w ...... 當這個 workflow 被執行的時候，可以在 GitHub Actions 看到細節 Merge into master 上個 workflow 只要偵測到任何 push 或 pull request 就會執行 而這個 workflow 則是在 master 分支有改動時執行 這時就可以在 on 的後面針對特定的事件做判斷 on : push : branches : - master # another branch could be specified here 除了 workflow 能偵測事件以外，也能依造不同的事件內容執行不同的 job 下面的狀況是只有「開頭不是 \"bump:\" 的 commit」 才執行 bump-version jobs : bump-version : if : \"!startsWith(github.event.head_commit.message, 'bump:')\" runs-on : ubuntu-latest 因為 commitizen 自動跳版本號的時候，會 push 一個 commit 回 master 分支 所以要給 GitHub Actions 適當的權限 那就需要設定密碼或 token 來做到 因為它們不適合被公開，所以要設定在 secret 裡面 設定 secret 的頁面可以從 Settings > Secrets > New repository secret (右上角) 找到 在 job 取出 secret 的方式則是如下使用 ${{ secrets.secret_id }} 這樣的語法 - name : Check out uses : actions/checkout@v2 with : fetch-depth : 0 token : '${{ secrets.PERSONAL_ACCESS_TOKEN }}' Python Publish 跟 GitHub Actions 比較相關的內容，在上面兩個 workflow 都寫得差不多的 那這裡就來聊聊跟 PyPI 相關的 從去年七月起，PyPI 就有支援使用 API token 上傳 （See more 👉 PyPI now supports uploading via API token ） 所以建議使用 API token 而不是個人的 PyPI 帳號密碼 產生 PyPI token 的方式可以在上面的文章找到，我就不贅述 使用的方式則是把原本帳號的欄位改成 __token__ （就是這個字串，不用代換成任何東西) 密碼改成 PyPI 給你的 token 在串 GitHub Actions 時，我踩到一個很有趣（？）的雷 假設你的取得的 token 是 pypi-thisisrandomestringrepresentingyourapitoken 在 workflow 中用 password: ${{ secrets.pypi_password }} 取得 secret 那在 secret 就要設定 \"pypi-thisisrandomestringrepresentingyourapitoken\" 而不是 pypi-thisisrandomestringrepresentingyourapitoken 不過也許將 workflow 的內容改成 password: \"${{ secrets.pypi_password }}\" 也能解決 總之，要記得加 \"\" Reference GitHub Actions Python in GitHub Actions","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/12/python-table-manner-continuous-integration","loc":"https://wei-lee.me/posts/tech/2020/12/python-table-manner-continuous-integration"},{"title":"snowflake-connector-python: 你的 pyarrow 不是你的 pyarrow","text":"這是個不好好看文件，胡亂嘗試、多繞了一圈才解決問題的經驗 最近剛好接手了別人弄到一半的專案 在嘗試把專案跑起來的時候，遇到了這個問題 Optional dependency : 'pyarrow' is not installed , please see the following link for install instructions : https : // docs . snowflake . com / en / user - guide / python - connector - pandas . html # installation 看起來是 pyarrow 沒有裝起來，所以可以先嘗試 pip install pyarrow 但很不幸的，這麼做並不會解決問題 snowflake-connector-python v2.3.7 需要的 pyarrow 版本必須是 >=0.17.0, < 0.18.0 這也不是什麼大問題，只要改成 pip install pyarrow==0.17.0 就可以解決 不過如果每個套件遇到類似的問題都要這樣試，可能會花上不少的時間 對 pip 稍有概念的人看到 Optional dependency: 'pyarrow' is not installed 可能會聯想到沒裝 extra requirement 所以我第一個嘗試其實是 pip install snowflake-connector-python[pyarrow] 但安裝完以後，還是跳出了同樣的錯誤訊息 而且進到虛擬環境中會發現連 pyarrow 都沒有被安裝 這時也只好點進它的文件，看是不是有需要額外設定什麼 👉 Using Pandas DataFrames with the Python Connector 點進文件馬上就會看到的指令是 pip install snowflake-connector-python[pandas] 因為我要裝 pyarrow 所以我將後面的 pandas 改成 pyarrow 不過這其實就跟前次嘗試的指令是一樣的，同樣不能解決問題 就在我百思不得其解時，我隨意測試了跟文件上一模一樣的指令 (i.e., pip install snowflake-connector-python[pandas] ) 然後一切的問題就解決了...... 既然解決了，就要回去思考為什麼能解決 回去看 snowflake-python-connector @ v2.3.7 的 setup.py 在 44行 可以找到 'pyarrow>=0.17.0,<0.18.0' pandas_requirements = [ # Must be kept in sync with pyproject.toml 'pyarrow>=0.17.0,<0.18.0' , 'pandas>=1.0.0,<1.2.0' , ] 接著可以看到 pandas_requirements 在 240行 被用到 ... extras_require = { \"secure-local-storage\" : [ 'keyring<22.0.0,!=16.1.0' , ], \"pandas\" : pandas_requirements , ... 原來 pip install snowflake-connector-python[pandas] 同時會安裝 pandas_requirements 中的 pandas 跟 pyarrow snowflake-connector-python 並不會單獨裝 pyarrow，這也難怪前面的嘗試會失敗 但其實這個問題只要都造著文件做就能解決，就是因為自作聰明才繞了一大圈 所以我說文件還是要好好的看啊！","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/12/snowflake-python-connector-install-extra-pyarrow-will-not-solve-your-problem","loc":"https://wei-lee.me/posts/tech/2020/12/snowflake-python-connector-install-extra-pyarrow-will-not-solve-your-problem"},{"title":"[Book] Deep Work深度工作力","text":"最近覺得自己的工作效率開始下降了 剛好在 MOPCON 聽到大大推薦這本書，就下訂了 看看能不能提升自己的生產力 這是我近期最快看完的書，但我對它的評價蠻微妙的 我認同它所提到的「深度工作」這個概念 認同部分它所提出的做法 但關於為什麼這些做法有用跟深度工作有用的論點卻沒有很說服我 不過如果想參考它提供的做法的話，還是有幫助的 看完這本書讓我想起以前看過的 增強你的意志力 諸如頻繁收訊息、電子郵件、滑臉書、玩手遊可能都是會讓自己養成想分心的習慣 反之，長時間做高專注的事情（不一定要是工作），對於深度工作能力都能有所提升 最近在工作時有更積極地開啟 Do not disturb 雖然有時候還是會想分心，但效率有比之前又提升了不少 概念 1 - 深度工作力，創造價值的關鍵能力 轉換任務時造成的注意力殘留可能導致下一個任務表現不佳 e.g., 每隔十分鐘瀏覽收件匣，看起來沒什麼害處 留下未完結的次要任務造成的注意力殘留，無法專注 概念 2 - 當「深度」越稀有，就越值得你投入 分心的原因 度量黑洞： 破壞深度工作造成的影響不易測量 最小阻力原則： 缺乏對產出的即時反饋，因此傾向採取當時最容易的行動 以忙碌代表生產力： 沒有明確指標證明工作有生產力，最簡單的方式就是以明顯可見的方式做很多事，但它們不見得有價值 網際網路狂熱教派 概念 3 - 深度工作力，美好生活的必要條件 這章很沒有說服我... 就不做筆記了 原則 1 - 培養深度工作力 策略1： 確立工作哲學 雙模式的深度工作時間安排 深度時段： 尋求高度且不被打斷的專注 淺薄時段： 處理次要事務 節奏式的深度工作時間安排 把進行深度工作變成簡單而規律的習慣（e.g., 固定在某個時段全力工作） 策略2： 建立深度工作的儀式 在何處工作，工作多久？ 指定一個進行深度工作的地點 一旦開始工作，怎麼做？ 規範和程序，讓努力有架構 e.g., 禁止使用網際網路，或設定每二十分鐘寫作的字數 如果缺少架構，容易把意志力消耗在思考這個時段該做什麼，並且評估自己是否夠努力 如何支持深度工作？ 確保大腦獲得必要的支持，以保持高水準的運作 e.g., 喝杯好咖啡、合適的食物以維持精力、納入散步等緩和的運動以保持頭腦清晰 策略3： 大動作投入深度工作 由激進的改變平常的環境，加上大手筆投資金錢或精力，提高任務的重要感 策略5： 像經營企業般執行 專注在最重要的事情 根據領先指標行動 以如何讓未來更好，而不是如何改善過去失誤的角度來思考 設置醒目的計分板 定期檢討成效 養成每週檢討的習慣，並事先計畫好一週的工作 策略6： 在職業生活中安排充足的休閒時間 在工作日結束時，停止思考工作上的問題 高度專注的能力是訓練出來的技術 只要有足夠的動機，就能在一夜之間把工作生活從分心轉變成專注 反之，一旦大腦習慣隨時回應，習慣分心，即使在需要專注時也會難以抗拒分心的誘惑 原則 2 - 學會擁抱無聊 策略1： 安排分心的時間 讓大腦自如的抗拒分心，並不表示必須斷絕分心，只要有能力抵擋這類行為綁架注意力 策略2： 像老羅斯福那樣工作 確認一項排在優先清單前面的深度任務 估計正常情況需要的時間，然後給自己比這個時間短很多的時限 可能的話，公開承諾會在時限前完成 策略3： 練習生產性冥想 目標: 花一段會用上體力、但不用腦力的時間 (e.g., 散步、慢跑、淋浴)，並集中注意力在單一而明確的工作問題上 目的並非為了生產效益，而是改善深度思考的能力 不斷抗拒分心和把注意力拉回明確的問題，強化抗拒分心的能力 把注意力推向單一問題的更深處，磨利專注力 策略4： 練習記憶一副牌 記憶力訓練可以附帶增強專注力 原則3 - 拒絕任何好處心態 策略2: 利用「斷線實驗」篩選社群媒體 斷線三十天後，問自己 過去三十天，如果我使用這項服務，我的生活會明顯更好嗎？ 人們在乎我不使用這項服務嗎？ 如果這兩個問題的答案都是「不」，那就永遠放棄那項服務 策略3: 別用網際網路來娛樂自己 休閒時，先想好如何利用晚上和週末的時間，別自動把時間花在吸引注意的東西 原則4 - 排除淺薄事務 策略1: 安排工作日的每一分鐘 把工作日切出數個時段，指定每個時段的工作 如果時間表被打亂，應該一有機會就更新 先認清「你永遠會在一開始低估大部分事情需要花的時間」 溢位方塊： 如果不確定要花多少時間，先畫上預期的時間方塊，再增添一個額外的方塊 時間表不但容許、還鼓勵即興的改變 策略2: 量化每一種活動的深度 淺薄工作: 非高認知需求、偏向後勤的工作，往往在注意力分散中執行 策略3: 確認淺薄工作的時間比率 策略4: 在五點半前結束你的工作 固定時間表: 在某個時間以後就不工作，然後以回溯的方式，尋找可以達成這個目標的生產力策略 如何避免過度使用危險用語：「好」 明確的拒絕，但模糊的解釋拒絕的原因 避免提供太多細節，讓對方有機會化解它 策略5: 讓自己難以連絡 要訣2：在寄發或回覆電子郵件時多下點工夫 回信應該描述最有效的流程，指出目前的步驟，並強調下一個步驟 如果擔心流程導向郵件太正式，可以在信件中增添較長的談話式開場白 要訣3：別回信 如果符合下列任何一種情況，就別回信 內容模稜兩可，難以回覆 不是你感興趣的問題或提議 回覆對你不會有好處，或不回覆不會對你有壞處 這些情況中，會有許多明顯的例外，例如，一封模稜兩可的信，談論的是你不感興趣的專案，但來自你公司的執行長，你就必須回覆","tags":"Book","url":"https://wei-lee.me/posts/book/2020/11/deep-work","loc":"https://wei-lee.me/posts/book/2020/11/deep-work"},{"title":"[Book] 為什麼要睡覺","text":"這本書除了提供關於有用的睡眠建議外，它也是一本相當有趣的書 探討各種人類跟睡眠有關的行爲、迷思 讓人會不禁想一直看下去（雖然我還是看得有點慢... 但這應該是我今年看最快的書了） 睡前喝酒真的有用嗎？ 睡覺真的需要睡滿八小時嗎？ 咖啡因又會如何影響我們的睡眠？ 作者透過各種睡眠相關研究，討論這些行為背後可能的原因 並提出在這個睡眠不友善的社會中，該怎麼透過增進有效的睡眠來增加生產力 某種程度上看起來有點像是研究報告，但又不會無聊 調性跟 為什麼我們這樣生活，那樣工作 ? 接近，但更加的平易近人 如果沒有時間看完整本書，想直接看結論的話，我推薦看閱讀前哨站的書摘 《為什麼要睡覺》讀書心得：殿堂級睡眠寶典打破11個迷思 這篇文章紀錄了書中附錄 1 的健康睡眠的12項守則，造著它執行應該就能對睡眠有所改善 整個筆記整理完，覺得我在 kindle 上少畫了不少重點 像是快速眼動睡眠對創意所帶來的好處，且它們只集中在睡眠的後期（e.g., 第 6 ~ 8 小時） 所以損失了 1 小時的睡眠並非損失 1/8 睡眠的價值，很可能是損失掉將近一半的價值 或者是做夢能對情緒所帶來的修復效果 也許等下次有機會再重看的時候，可以把這部分再補充到筆記中 睡眠是什麼？ Ch 1 - 睡吧…… 睡眠不足，保證體重增加 人類是唯一會在無益的情況下故意剝奪自己睡眠的生物 Ch 2 - 咖啡因、時差、褪黑激素 近日節律 當移除外在的日光影響時，每個人內在產生的「一天」並不是正好二十四小時，而是比二十四小時稍微長一點 生物有近日節律的可能理由 與地球每天自轉的機制同步，不管是內在活動（如體溫）或外在活動（如攝食），都能協調於地球自轉造成的規律明亮（面對太陽）與黑暗（背對太陽） 晨型人 vs 夜型人 晨型人（占人口比例約40%）： 清醒的高峰在早上，睏倦則在入夜不久後 夜型人（30%）： 偏好晚睡，也因此第二天會晚起，甚至過了中午才醒來 剩下（30%）： 介於之間的不同地帶，稍微往夜型人的方向偏 往東飛比往西飛的時差更難調適 往東時必須提前睡覺，在生物學上來說是非常艱巨的任務 頻繁經歷時差可能會傷腦 咖啡因會遮蓋睡眠訊號 咖啡因的作用在於搶奪了腦中本該接收腺苷的位置（受體） 一旦占據受體後，咖啡因擋住這些受體，使受體不活躍 喝下咖啡後的三十分鐘左右，在體內循環的咖啡因濃度達到高峰 咖啡因的半衰期平均為五到七小時 假設你在晚餐後喝了一杯咖啡，時間約為晚間七點半，這表示到了凌晨一點半，還有約50%的咖啡因在你的腦部組織中循環作用 年紀愈大，要從身體裡去除咖啡因愈花時間 為什麼熬夜後精神會更好？ 在原本應該清醒的時段，近日節奏會讓你有比較好的精神，但實際上你並沒有休息到 和睡眠壓力不同，近日節律並不理會實際上有沒有睡覺 我的睡眠足夠嗎？ 早上起床後，你是否能在上午十點或十一點左右回頭繼續睡覺？ 是 → 很可能睡不夠或睡眠品質不佳，或兩種都有 你是否可以在沒有咖啡因的情況下，在中午前以理想狀態運作？ 否 → 很可能是靠著咖啡因之類的藥物，來應付自己長期睡眠不足的狀態 如果不設鬧鐘，你會睡過頭嗎？ 是 → 你需要更多的睡眠量 你發現自己坐在電腦螢幕前，會重讀或甚至再三讀過同一個句子嗎？ 是 → 腦部疲勞、睡眠不足 睡不夠的後果 腺苷濃度仍然太高 昨天的腺苷還有部分留著，於是帶著這份想睡的債務度過一整天，和拖欠金錢債款一樣，這筆睡眠債會持續累積 Ch 3 - 在你睡著時，大腦依然忙碌 怎麼判斷自己睡過覺了？ 對外界失去覺察力 → 停止接收外在世界的訊息 時間扭曲的感覺 非快速動眼睡眠（non-rapid eye movement sleep，簡稱為NREM睡眠） 快速動眼睡眠（rapid eye movement sleep，簡稱為REM睡眠） 快速動眼睡眠又稱作矛盾睡眠（paradoxical sleep）：腦像是清醒著，然而身體卻很明顯是在睡覺 Ch 4 - 誰會睡覺？我們該怎麼睡？ 我們該怎麼睡覺？ 現況： 已開發國家，多數成人採「一段式」睡眠且平均長度少於七小時 正確： 兩段式睡眠模式，是一段連續長時間的夜間睡眠，加上一段較短的午睡 人類天生適合「兩段式睡眠」: 兩段式睡眠並非源自文化，而根植於生物特性 不管文化背景或地理位置，每個人在下午都有一個清醒度低落的時段 如果你需要上臺報告時，盡可能避免下午的中段時段 → 避免你和聽眾注意力渙散的時間 好的快速動眼睡眠 → 辨識及理解能力更為敏銳 → 冷靜掌握情緒的能力 如果你忽然想起不太冷靜的人，你可以合理懷疑與他們一天的睡眠時數有關，特別是有沒有獲得早晨時分富含快速動眼睡眠的階段 Ch 5 - 我們一生中的睡眠變化 快速動眼睡眠在人類生命早期是必要的 阻礙或減少新生動物的快速動眼睡眠，會妨礙和扭曲這些寶寶的腦部發育，導致成年後的社會關係異常 迷思： 長者的睡眠需求較少 年長者所需的睡眠應該與中年時差不多，只是較難產生同樣分量的睡眠 隨著年紀漸長，睡眠有三項主要的改變 量與質的降低 睡眠效率的降低 睡眠的時機受干擾 為什麼我們該睡覺？ Ch 6 - 你媽媽和莎士比亞早就知道 睡覺時的大腦使用清醒大腦絕不會嘗試的方式，把完全不同的知識連結起來，產生出令人驚豔的問題解決能力。這發生在做夢的階段，也就是快速動眼睡眠 Ch 7 - 超越金氏世界紀錄的極限 當你睡眠不足時，無法評估自己的狀況有多糟 每晚睡六小時，連續十天之後，表現失常的程度就和連續二十四小時沒睡的人一樣 四小時和六小時實驗組所累積的表現缺失也和完全沒睡組一樣，沒有趨於平緩的跡象 在一整段即將發生的睡眠剝奪的開端就小睡，可以有一些緩衝；儘管這種效果只是暫時的，也不完全，這段緩衝仍可保護大腦免於可能造成災難的專注力缺失 如果你發現開車時感到睏倦，請停下車，找地方過夜 如果你真的一定得趕路，而且審慎考慮過，即使冒著生命危險也一定要繼續，那麼請把車子開到路邊安全的停車處，小睡片刻（二十到三十分鐘） 醒來後，不要立刻開車，因為那時你會有睡眠慣性（sleep inertia），也就是剛醒來時覺得還沒完全清醒的效應。請再等二十到三十分鐘，如果需要，或許先喝杯咖啡，然後才上路 這只能讓你維持到下一次需要休息的時候，而且效果會愈來愈差 Ch 8 - 癌症、心臟病，以及壽命變短 不管你現在處於哪種免疫狀態，如果你正準備接受疫苗來提高免疫力，或正在動員強大的適應性免疫反應來對抗病毒攻擊，那麼你需要睡覺，而且是整晚充分的睡眠，這是不容妥協的 為什麼會做夢？ Ch 10 - 做夢是一種夜間治療 只要去睡覺，或許就會得到療癒 快速動眼睡眠的做夢狀態，以及反應出夢中腦內壓力化學物質降低的特定電活動模式，決定了每個人夜間治療的成功程度 並非時間療癒了傷痛，而是花在做夢睡眠的時間提供了情緒修復 從安眠藥到翻轉社會 Ch 12 - 不安的夜晚 睡眠剝奪 vs 失眠症 睡眠剝奪 有適當的睡眠能力 沒有給自己適當的睡眠機會 失眠症 缺乏適當的睡眠能力 有適當的睡眠機會。也就是說，失眠的人即使給自己足夠的時間（七到九小時），也無法產生足夠的睡眠量和睡眠品質 睡眠時間 vs 睡眠機會 現代社會中有很多人只給自己 5 到 6.5 小時的睡眠機會，這通常表示實際上只得到 4.5 到 6 小時的睡眠 死亡風險和睡眠時間的關係有點像個鉤子，超過九小時後會往上勾 疾病會促進睡眠，特別是引發活躍免疫反應的疾病 因此病得愈重的人，應該睡得愈久，以利用睡眠提供的健康工具來對抗病症 有些疾病的威力太強，不管睡多久也無法克服，例如癌症，結果造成睡太多導致早死的假象，而不是「更合理」的結論：某些病症太過嚴重，不管加長多少睡眠帶來的好處，都無法扭轉病情 「更合理」而不是「同樣合理」 → 因為還沒發現任何生物機制顯示睡眠有任何壞處 Ch 13 - 讓你無法睡覺的是…… 五項重要的因子強烈影響我們睡眠的長度和品質： 持續的燈光和LED光 固定的室溫 咖啡因（在第2章討論過） 飲酒 上班打卡的傳統 可能的解決方案 光源 在夜裡採用較暗的室內燈光 比較堅持的人甚至會在下午和夜晚於室內戴上黃色眼鏡，濾除壓抑褪黑激素的有害藍光 使用完全遮光窗簾 → 整夜維持黑暗 在電腦、手機和平板電腦等裝置上安裝軟體，夜晚時逐漸降低有害藍光LED的飽和度 室溫 在一般的寢具和睡衣條件下，大約攝氏18.3度的臥室溫度，對多數人來說是理想 要成功啟動睡眠，你的核心體溫必須降低約攝氏一度 人類演化出雙手捧水洗臉的習慣 因為手和臉的表面都布滿血管，不管是冷水或熱水，都能幫助熱從皮膚表面散失，以降低體內溫度 或許有人覺得臉上的潔淨感可以幫助睡眠，但臉部的乾淨與否對睡覺並沒有影響 為什麼我們有時會在夜裡把手或腳從棉被底下伸出去？ 透過四肢散熱 睡前的熱水澡對健康成人來說，可以使深度非快速動眼睡眠增加，程度達10%到15% 原因可能和想像的相反。會較快入睡的原因並不是因為全身暖呼呼的，而是因為泡過熱水後讓血液流到體表，這些擴張的體表血管會很快把體內的熱散發出去，於是你的核心體溫突然下墜，身體核心變得較冷，會讓你更快睡著 飲酒 拒絕夜間小酌，酒精不能助眠 酒精如何破壞睡眠？ 睡眠的片段化，讓人在夜裡醒來數次 酒後的睡眠是不連續的，因此缺乏修復效果。且當事人通常不記得自己曾醒來 酒精是已知抑制快速動眼睡眠最有力的物質之一 當身體代謝酒精時，產生的副產品是醛類和酮類，醛類會阻礙腦產生快速動眼睡眠 即使只是在下午或晚上喝下不多的酒，也足以剝奪睡眠中的做夢階段 鬧鐘 如果恐嚇你的心臟（事實如此）還不夠糟，使用貪睡裝置，表示你每隔一小段時間還要一次又一次的恫嚇自己的心血管系統。同樣的做法在一週間至少發生五次，你就要開始體會，虐待心臟和神經系統的後果會延續一輩子 如何改善睡眠品質？ 每天都在同樣的時間醒來，不管是週間或週末 補充知識： 為什麼冷色調的藍光會是調節褪黑激素釋放最有力的可見光？ 人類和目前所知的所有陸生生物一樣，是起源於海洋的。海洋的作用就像光的濾鏡，會濾掉大部分波長較長的黃光和紅光，留下來的是波長較短的藍光。這也是為什麼無論從海上或水面下看起來，大海都是藍色的 Ch 14 - 安眠藥真的能安眠嗎？ 反彈性失眠： 停止使用安眠藥後，常會發生睡得更差的狀況，有時甚至比決定開始吃安眠藥時的情況更糟 目前最有效的睡眠治療： 失眠認知行為治療 （CBT-I，cognitive behavioral therapy for insomnia） 容易理解的方法包含減少咖啡因和酒精的攝取、把電子螢幕移出臥室、讓臥室溫度較低。此外，病患必須 建立固定的上床和起床時間，即使週末也一樣 只有在要睡覺時才躺到床上，避免夜晚較早時在沙發上小憩 不要睡不著卻一直躺在床上，此時要離開床鋪，做一些較舒緩放鬆的活動，直到睡意恢復 如果晚上睡覺有困難，要避免白天的小睡 學習在睡前放慢腦袋的運轉速度，減少引起焦慮和煩惱的想法產生 不要在臥室裡視線所及的地方放置時鐘，避免半夜盯著時鐘看的焦慮 最好在夜晚熄燈前二到三小時就結束運動 身體活動過後一至二小時內，體溫依然偏高，如果運動時間太接近睡覺時間，會因為代謝率提高，讓核心體溫來不及下降、有效啟動睡眠 Ch 16 - 二十一世紀的睡眠新願景 避免上床的時候過飽或過餓，並且避免過度偏向高碳水化合物的飲食（超過總熱量攝取的70%），尤其要避免糖的攝取 光源調控系統可以在生物學上合理的範圍內，稍微改變一個人的睡眠節律（提前或延遲三十到四十分鐘以內），藉此逐漸把節律調得更早或更晚 e.g., 如果在星期三有場特別早的會議，從星期一開始逐漸調移近日節律，把上床和起床時間稍微提前。如此一來，星期三特別早起時就不會那麼痛苦，也不會對你的大腦和身體造成那麼多生物學上的折磨 把健康的新習慣轉變為長久的生活方式： 紀錄自己的健康數據","tags":"Book","url":"https://wei-lee.me/posts/book/2020/10/why-we-sleep","loc":"https://wei-lee.me/posts/book/2020/10/why-we-sleep"},{"title":"小林的程式會不會遇到 SQL Injection","text":"其實這篇文章應該一年前就該寫了... 今年為了在 PyCon TW 的 Lightning Talk 想個梗，就拿出來講 ( slide ) 沒想到被投影機擺了一道...... 前言雜談 去年看了京阿尼的作品 小林家的龍女僕 第一集就發現主角小林也是寫 Python 的工程師，就開心地分享了這個消息 沒想到馬上就有朋友問我這段程式碼會不會有 SQL injection 單看這一段程式碼其實很難直接下定論 畢竟 key 根本就不會被帶入 session_id=$key ，誰知道 db 怎麼實作的 當然，早就有人注意到這段程式碼了 它出自 webpy/web/session.py 如何评价京都动画2017年1月新作 小林家的龙女仆? 除了找到程式碼外，它還列出了劇情的其他 Python 程式碼，並討論了京都動畫使用這段程式碼會不會有法律問題 小林さんちのメイドラゴンで出てきたコード（小林さんを探せ！） 透過 git blame 來找出「到底誰是小林！」 Ponkatsu - Tag: sql injection 直接點出這段程式碼會遇到 SQL injection 但身為工程師還是要自己驗證一下到底會不會有 SQL injection 什麼是 SQL injection 根據 SQL注入 維基百科頁面的例子 假設有一段產生 SQL 字串的程式碼是這樣寫的 sql_str = \"SELECT * FROM users WHERE (name = '\" + username + \"') and (pw = '\" + password + \"');\" 只要攻擊者輸入了 username = \"1' OR '1'='1\" password = \"1' OR '1'='1\" 就會產生 SELECT * FROM users WHERE ( name = '1' OR '1' = '1' ) and ( pw = '1' OR '1' = '1' ); 因為 1 一定等於 1，這段 SQL 就會產生跟 SELECT * FROM user; 一樣的效果 也就是攻擊者在完全不知道帳號密碼的情況下，就可以取得所有 users 的帳號密碼 web.py 到底會不會有 SQL injection？ 因為小林家的龍女僕是在 2017 年的 1 月到 4 月播出 根據 web.py 的 tags 頁面，在那之後的第一個發佈是 webpy-0.39 可以推測，這最有可能是第一個包含小林撰寫程式碼的發佈 我們先從安裝 web.py==0.39 到虛擬環境中開始 （p.s. web 跟 py 中間的 . 是必要的，因為真的有個套件叫 webpy） poetry add web.py == 0 .39 很不幸，如果使用的是 Python 3，會遇到以下的錯誤訊息 Creating virtualenv kobayashi-pwI4Cysh-py3.8 in /Users/weilee/Library/Caches/pypoetry/virtualenvs Updating dependencies Resolving dependencies... (0.1s) Writing lock file Package operations: 1 install, 0 updates, 0 removals - Installing web.py (0.39) [EnvCommandError] Command ['/Users/weilee/Library/Caches/pypoetry/virtualenvs/kobayashi-pwI4Cysh-py3.8/bin/pip', 'install', '--no-deps', 'web.py==0.39'] errored with the following return code 1, and output: Collecting web.py==0.39 Using cached web.py-0.39.tar.gz (93 kB) ERROR: Command errored out with exit status 1: command: /Users/weilee/Library/Caches/pypoetry/virtualenvs/kobayashi-pwI4Cysh-py3.8/bin/python -c 'import sys, setuptools, tokenize; sys.argv[0] = '\"'\"'/.../web.py/setup.py'\"'\"'; __file__='\"'\"'/.../web.py/setup.py'\"'\"';f=getattr(tokenize, '\"'\"'open'\"'\"', open)(__file__);code=f.read().replace('\"'\"'\\r\\n'\"'\"', '\"'\"'\\n'\"'\"');f.close();exec(compile(code, __file__, '\"'\"'exec'\"'\"'))' egg_info --egg-base /... cwd: /.../web.py/ Complete output (7 lines): Traceback (most recent call last): File \"<string>\", line 1, in <module> File \"/.../web.py/setup.py\", line 6, in <module> from web import __version__ File \"/.../web.py/web/__init__.py\", line 14, in <module> import utils, db, net, wsgi, http, webapi, httpserver, debugerror ModuleNotFoundError: No module named 'utils' ---------------------------------------- ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. WARNING: You are using pip version 20.1.1; however, version 20.2.3 is available. You should consider upgrading via the '/Users/weilee/Library/Caches/pypoetry/virtualenvs/kobayashi-pwI4Cysh-py3.8/bin/python -m pip install --upgrade pip' command. web.py 要到 0.40 才支援 Python 3 (Ref: python3 ImportError: No module named utils #180 ) 因為我不太想測試 Python 2，就假設小林的程式碼到 0.40 都沒什麼被改動到好了 😆 初始化資料庫 要實驗到底有沒有辦法取得資料庫的資料，總是要先有一個資料庫 這裡做了三件事 用 sqlite3 跟 \"kobayashi.db\" 建立連線 建立 USER 資料表 將 \"kobayashi\", \"tohru\", \"kanna\", \"elma\" 新增到 USER 資料表中 import sqlite3 def init_db (): # connect and create \"kobayashi.db\" conn = sqlite3 . connect ( \"kobayashi.db\" ) # create USER table create_table_sql = \"\"\" CREATE TABLE `USER` ( `account` TEXT NOT NULL UNIQUE, `password` TEXT NOT NULL, PRIMARY KEY(`account`) ); \"\"\" # insert users into USER table insert_user_sql = \"\"\" INSERT INTO USER (account, password) VALUES ('kobayashi', '1'), ('tohru', '2'), ('kanna', '3'), ('elma', '3'); \"\"\" conn . execute ( create_table_sql ) conn . execute ( insert_user_sql ) conn . commit () conn . close () if __name__ == \"__main__\" : init_db () 實作登入功能 login 會把使用者輸入的 account 跟 password 帶入 where 如果在資料庫找到正確的匹配，就會回傳找到的第一筆 user 如果找不到就回傳 None from typing import Optional , Tuple import web def login ( account : str , password : str ) -> Optional [ web . utils . Storage ]: result_set = db . select ( \"USER\" , where = f \"account =' { account } ' AND password=' { password } '\" ) user = result_set . first () if user : print ( \"login succeeded\" ) return user else : print ( \"wrong username or password\" ) return None 這裡用三個案例來測試 錯誤的帳號密碼 → 不應該取得 user 正確的帳號密碼 → 應該取得 user SQL injection → 理想上，也不該取得 user if __name__ == \"__main__\" : db = web . database ( dbn = \"sqlite\" , db = \"kobayashi.db\" ) print ( login ( \"kobayashi\" , \"\" )) print ( login ( \"kobayashi\" , \"1\" )) print ( login ( \"1' OR '1'='1\" , \"1' OR '1'='1\" )) 但這個世界始終不理想，包含了 SQL injection 的程式成功取得 user 之所以只取到一筆 user，是因為 login 只會回傳第一個物件，但這段 SQL 是能取到整個資料庫的 user 的 0.0 (1): SELECT * FROM USER WHERE account ='kobayashi' AND password='' wrong username or password None 0.0 (2): SELECT * FROM USER WHERE account ='kobayashi' AND password='1' login succeeded <Storage {'account': 'kobayashi', 'password': '1'}> 0.0 (3): SELECT * FROM USER WHERE account ='1' OR '1'='1' AND password='1' OR '1'='1' login succeeded <Storage {'account': 'kobayashi', 'password': '1'}> 該如何修正？ 修正的方式很簡單，只要在呼叫 select 的時候用 vars 將參數帶進 where 即可 其實 web.py 的文件就有寫了 (Ref: db.query ) def login ( account : str , password : str ) -> Optional [ web . utils . Storage ]: result_set = db . select ( \"USER\" , where = f \"account=$account AND password=$password\" , vars = { \"account\" : account , \"password\" : password }, ) user = result_set . first () if user : print ( \"login succeeded\" ) return user else : print ( \"wrong username or password\" ) return None 這次就算用原本 SQL injetion 的作法，也取不到任何的資料 因為沒有 account 是 \"1' OR '1'='1\" 0.0 (3): SELECT * FROM USER WHERE account =\"1' OR '1'='1\" AND password=\"1' OR '1'='1\" wrong username or password None 知其然還要知其所以然啊！ 除了知道怎麼修正外，我還想知道 web.py 做了什麼 下面冗長的紀錄我追 web.py 原始碼的過程 pdbpp 寫這篇文章最大的收穫，大概就是大幅的提升了我對 pdb 的熟悉度 剛好聽到廣播 Python Bytes 推薦的 pdbpp 就順手玩了一下 pdbpp 在安裝後會取代原生的 pdb 主要有這兩個功能比 pdb 好用 syntax highlight 不過需要注意的是，如果要能客製化 highlight 風格，需要直接從 master branch 安裝的版本，目前還沒把這個修正釋出到 PyPI 上 sticky mode（在除錯器的上方一直顯示目前追到的程式碼） 順便記錄一下常用到的 pdbpp 指令 n : 下一行 s : 進到函式 p [var] (e.g., p locals() ): 印出變數 var args : 印出參數 ll : 顯示現在在原始碼的哪裡（原本 pdb 的 longlist） 追 web.py 原始碼 這部分的紀錄方式會是每進到一次函式 (在 pdb 裡面使用 s ) 就會加一個四級標題 回到原本的函式，則會在標題後面加一個 back 首先當然是從 login 呼叫到 db.select 函式開始追回去 web/db.py::DB::select 位置: web/db.py#L845 跑完 874 行的 list comprehension 後， clauses 會包含以下四個部分 (Pdb++) p clauses [<sql: 'SELECT *'>, <sql: 'FROM USER'>, <sql: 'WHERE account =\"1\\' OR \\'1\\'=\\'1\" AND password=\"1\\' OR \\'1\\'=\\'1\"'>] 看起來已經成功將特殊字元跳脫，解決 SQL injection 所以接下來要去追產生 clause 的 gen_clause web/db.py::DB::gen_clause 位置: web/db.py#L934 gen_clause 會被呼叫三次，當輸入的參數 sql 是 WHERE 時，會執行到 948 行的 nout = reparam(val, vars) 此時輸入的各個參數如下 ( Pdb ++ ) p sql 'WHERE' ( Pdb ++ ) p val 'account =$account AND password=$password' ( Pdb ++ ) p vars { 'account' : \"1' OR '1'='1\" , 'password' : \"1' OR '1'='1\" } web/db.py::reparam 位置: web/db.py#L344 參數: val = 'account =$account AND password=$password' vars = {'account': \"1' OR '1'='1\", 'password': \"1' OR '1'='1\"} 一進到 reparm ，這些值就會繼續被傳到 safteval web/db.py::SafeEval::safeeval 位置: web/db.py#L1699 帶入參數 text = 'account =$account AND password=$password' mapping = {'account': \"1' OR '1'='1\", 'password': \"1' OR '1'='1\"} 1700 行的 Parser 會將 text 分解成四個 SQL 的部分，並且將 nodes 連同 mapping 一個一個帶入 eval_node (Pdb++) p list(nodes) [Node('text', 'account =', None), Node('param', 'account', None), Node('text', ' AND password=', None), Node('param', 'password', None)] web/db.py::SafeEval::eval_node 位置: web/db.py#L1703 self.eval_expr 的功用是在讓 node[1] 能抓到 \"1' OR '1'='1\" 抓到了字串 \"1' OR '1'='1\" 後會丟到 sqlquote web/db.py::sqlquote 位置: 463行 參數: a = \"1' OR '1'='1\" a 會在 475 行被初始化成 SQLParam 物件 ，然後再產生 SQLQuery 物件 web/db.py::SafeEval::eval_node (back) 位置: web/db.py#L1703 回到 eval_node ，就會把剛剛的結果 <sql: '\"1\\' OR \\'1\\'=\\'1\"'> ( SQLQuery 物件印出的形式) 回傳 web/db.py::SafeEval::safeeval (back) 位置: web/db.py#L1699 1701 行的 [self.eval_node(node, mapping) for node in nodes] 會產生 [ 'account =' , < sql : '\"1 \\' OR \\' 1 \\' = \\' 1\"' > , ' AND password=' , < sql : '\"1 \\' OR \\' 1 \\' = \\' 1\"' > ] 這個 list 會接著被帶入 SQLQuery.join 整合成一整個 SQL 的片段 web/db.py::SQLQuery::join 位置: web/db.py#L254 277 ~ 285 行的 for loop 執行完會產生一個新的 target ( SQLQuery 物件) (Pdb++) p target <sql: 'account =\"1\\' OR \\'1\\'=\\'1\" AND password=\"1\\' OR \\'1\\'=\\'1\"'> (Pdb++) p target.items ['account =', <param: \"1' OR '1'='1\">, ' AND password=', <param: \"1' OR '1'='1\">] (Pdb++) p target.values() [\"1' OR '1'='1\", \"1' OR '1'='1\"] (Pdb++) p target.query() 'account =%s AND password=%s' 可以發現這時候要回傳的 SQLQuery 物件已經把查詢時跟要帶入的值分開儲存 web/db.py::reparam（back） 位置: web/db.py#L344 web/db.py::DB::gen_clause (back) 位置: web/db.py#L948 在 956 行，剛剛回傳的 nout 會透過 xjoin 跟字串 WHERE 整合成一個新的 SQLQuery 物件 字串跟 SQLQuery 相加的行為被定義在 196 行 的 __radd__ 但因為沒有什麼太意料之外的行為，這裡就不繼續追下去了 web/db.py::DB::select (back) 位置: web/db.py#L874 取得了回傳的 clauses 後，它會在 879 行的 SQLQuery.join 整合成一個 SQLQuery 物件 產生 qout (Pdb++) p qout <sql: 'SELECT * FROM USER WHERE account =\"1\\' OR \\'1\\'=\\'1\" AND password=\"1\\' OR \\'1\\'=\\'1\"'> 最後就要看 884 行的 self.query(qout, processed=True) 是不是真的會以參數化的方式執行這段 SQL web/db.py::DB::query 位置: web/db.py#L807 執行到 831 行 self._db_execute(db_cursor, sql_query) 才會用到傳進來的 sql_query web/db.py::DB::_db_execute 位置: web/db.py#L750 在 756 行的 _process_query 產生要執行的 SQL query 跟它的參數，回傳的結果分別是 query = 'SELECT * FROM USER WHERE account =? AND password=?' params = [\"1' OR '1'='1\", \"1' OR '1'='1\"]) 再帶到 757 行的 out = cur.execute(query, params) 直接對資料庫作查詢，所以就不會遇到 SQL injection 了 原本好像是要追 delete 才對 顧著重現維基百科的例子，竟然忘記了原本要追的其實是另一段程式碼 不過我想本質應該還是相同的 有興趣的話，可以拿以下這段 SQL 來測測看 delete 的 SQL injection 是不是真的能清空整個資料表 disclaimer: 請不要拿它用在會影響到其他人的程式上 (e.g., production 環境) DELETE FROM USER WHERE account = '' OR '' = '' 你是不是真的把你的兒子取名為 Rober'); DROP TABLE Students; 結語 結論是「雖然小林的程式碼可能遇到 SQL injection，但也存在著很簡單的解決方案，只要使用者有讀文件，應該就不會遇到」 我完全不是資訊安全的專家，只是抱持著對京都動畫和 Python 的愛來追這段程式碼 如果有說錯或可以補充的部分，再麻煩留言讓我知道 🙏 其實小林家的龍女僕，還有其他場景也有出現 Python 像是這裡說了小林自從開始寫 Python 後變得開朗了許多呢（誤 我也是自從寫了 Python 後，每次考試都考 100 分呢（並沒有） 所以大家一起來寫 Python 吧 🐍 那寫 Python 的人最好的交流平台是什麼呢 🤔 當然是 PyCon TW 啊 🤩 來當 PyCon TW 志工，跟大家交流 Python，變成一個開朗的人吧 💪 One more thing 去年七月一場不幸的縱火案，大大的重創了京都動畫 PyCon JP 2019 時，我也去了鷲宮神社留下我的祝福 不會日文的我，就只簡單的寫了 Pray for Kyoani 即便如此，京阿尼還是很快就站起來 一年過後的現在宣布「小林家的龍女僕將於 2021 年開播 」🎉 TVアニメ第2期「小林さんちのメイドラゴンS」2021年放送決定！SuperでSupremeなSecond lifeがStartします！ そして、メイドラゴンS(読み:エス)ティザービジュアル公開！ティザーサイトもぜひチェックお願いします！ https://t.co/pKOgbEe3sL #meidragon pic.twitter.com/XoyiBPbnvt — TVアニメ「小林さんちのメイドラゴンS」公式 (@maidragon_anime) August 10, 2020","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/09/will-kobayashi-s-code-encounter-sql-injection","loc":"https://wei-lee.me/posts/tech/2020/09/will-kobayashi-s-code-encounter-sql-injection"},{"title":"[Book] 學徒模式","text":"學徒模式是由數十個在不同情境下可以用的模式所組成 每個模式都會分為 情境、問題、解決方案、行動 四個部分 模式之間彼此可能有一些關聯，但並非順序性的 所以這本書並沒有必要照著順序閱讀 讀起來的感覺跟 The Clean Coder 有點像 在職涯的不同階段閱讀都可能有很不同的感受 前言 有些讀者發現需要讀本書兩次 第一次快速瀏覽，在腦中建構所有內容的印象 第二次建立各模式間的互相連結 我覺得我自己就是幾乎什麼書都得讀兩次的人 XD Ch2 - 倒空杯子 你的第一個語言 選一個語言， 精通 它 和專家一起工作 參加該語言愛好者舉辦的本地聚會（或網路論壇），評估自己是不是願意屬於這個社群 盡快閱讀如 Effective Perl Programming, Effective Java 這類書籍，加速學習並減少犯下常見錯誤的機會 但不應該與任何特定的技術白頭到老，應該尋求廣泛而足夠的基礎知識與經驗，才能針對任何特殊的狀況挑選合適的方案 具體技能 「如果我今天雇用你，下星期一你能對團隊帶來什麼好處？」 對第一個語言的深入了解能幫你建立可靠度，證明對團隊的幫助 變成工匠後，聲望、過去的工作經驗，以及對團隊帶來更深層的影響將更為重要 到這個時間點之前，你必須盡可能地擁有更多技能 收集你嚮往的人的履歷資料，從每份履歷中挑出五個不同的技能，評估是是否夠用在你想加入的團隊中，利用挑選出來的技能建立一個能夠展現你擁有這些技能的小專案 養成定期維護個人履歷的習慣，將具體技能獨立為個別的清單 Ch3 - 走在漫漫長路 量身繪製地圖 列出三個目前工作之後可以做的工作，之後再為每個工作列出三個後續的工作 思考這些是否包含接下來幾年你生命中期望的職務 Ch4 - 正確的自我認知 成為菜鳥 問題： 學習的機會慢慢減少 解決方案： 讓自己被比自己優秀的開發人員圍繞 行動 列出所有你知道的團隊（e.g., 開放原始碼專案、其他部分、以及其他公司） 將這些團隊一技術能力好壞排列，然後找出其中正在找尋新成員加入的團隊 可能得加入好幾個 mailing list ，向許多人詢問才能弄清楚這些團隊彼此的技術能力 打掃地面 問題： 不確定自己在團隊中的位置，團隊對你的認識也不多，你希望找到為團隊貢獻的方式，獲得團隊的信任，並成長成工匠 解決方案 自願去做簡單、枯燥、又非做不可的工作 初期為團隊的成功做出貢獻，展現出即使在小事上也能維持高品質的成果 Ch5 - 終身學習 拓展你的頻寬 在 Twitter 上追蹤一些傑出軟體人員，持續關注他們在進行的工作 訂閱高流量的 mailing list ，重新產生他人詢問的問題，並試著回答他們 加入新成立、以最新科技為主題的本地使用者群組，向負責人自我介紹，並提供需要的幫助 每讀完一本書，寄信給作者表達謝意與提問 作者、講者與傑出人員也許看起來很嚇人或忙碌，但他們通常很樂意與讀者互動 邊工作邊反省 情境 有足夠能力的人，都會在幾年後爬上升職的階梯。如果你不為那個晉升準備，你會發現自己成為「彼得原理」的受害者，被晉升到不能勝任的位置 解決方案 經常反省自己的工作方式 建立 Personal Practices Map (Ref: My Personal Practices Map ) 分享個人所學 這對初學者可能是不容易跨過的心理障礙， 但正因為知道的不多，你的解釋會最簡單、直接，而不需要其他知識，這會讓他們成為更好的解釋 行動： 回想你上次學到重要知識的過程，寫一篇相關的文章，提供你當初希望已經存在的訊息 建立回饋迴路 情境： 你無法知道自己是否限於 unconscious incompetence 解決方案 定期取得關於自身表現的外部客觀資料 學徒也許不該太早致力於減少錯誤，而是致力於如何辨認自己犯的錯 Ch6 - 安排自我課程 閱讀清單 問題： 你需要閱讀的書籍大量增加，遠遠超過你的閱讀速度 解決方案 維護閱讀清單，紀錄你計畫要讀跟已經讀完的書 考慮將閱讀清單公開出來，這能讓其他人也從你的學習受益 (Ref: BookShelved ) 反省過去的學習習慣 你可能會發現有些書持續出現在參考書目中，應該將這些書移到前方 閱讀清單應該要是一個 priority queue","tags":"Book","url":"https://wei-lee.me/posts/book/2020/09/apprenticeship-patterns","loc":"https://wei-lee.me/posts/book/2020/09/apprenticeship-patterns"},{"title":"[Book] 葛洛夫給經理人的第一課：從煮蛋、賣咖啡的早餐店談高效能管理之道","text":"放在那個位置上，做久了覺得自己做得來，就會接受這個位置 不過這樣的事情並沒有自然而然的發生 一年的 PyCon TW 2020 議程組長當下來，跟團隊的協調上還是會遇到不少難題 才覺得自己好像該多讀點書了 這本書在很多面向給我解決問題的方向，也包含了不少我踩了雷才形成的作法 有種相見恨晚的感覺（笑 做久了，就會想辦法讓自己有能力勝任這個位置 改成這樣好像比較符合我今年下來的感受 前言 產出導向管理 團隊意識： 經理人的產出 = 他所管理或影響所及的部屬工作成效總和 管理槓桿率： 高槓桿率的管理活動 → 高產能 第1章：「生產」包含了些什麼？ 及早發現、及早治療 原物料在流程中「愈變愈有價值」 → 在「價值最低」的階段就修正問題 e.g., 校園徵才時便決定篩掉哪些人，便可以省下後來面試所花的時間和金錢 第2章：從早餐店的庫存談起 踏進辦公室，經理人得馬上知道的資訊 當日銷售預測 原料存貨 設備狀況 人力資源 人力資源品質指標 任何管理都需要評估 → 評估產出 ，而不是產出前的生產活動 好的指標 → 衡量具體且可計算的事情 領先指標 (leading indicator) 了解未來的概況來引導你注意黑箱中該注意的事情 e.g., 機器故障紀錄、客戶滿意程度 線性指標 (linearity indicator) e.g., 除了產出外，也衡量每一天的進度，再 將其與理想的線性進度相比 有可能出貨都擠在當月最後，一旦月底機器故障，進度會大大落後 趨勢指標 (trend indicator) 以時間(這個月業績和過去數月相比)或其他設定的標準為基礎，衡量產出 e.g., 早餐做幾份或是傳單做了幾張 重覆印證表 (stagger chart) 預測未來幾個月的產出 每個月都更新資料並重新預測 以實際銷售業績和上個月的預測，甚至前幾個月對本月的預測相比 出貨品質檢驗 海關與監視器 海關： 產品沒通過測試，便會被打回前一關或廢棄 監視器： 如果取樣到瑕疵品，就標上記號，並計算瑕疵率。如果瑕疵率，就該停止這條生產線 除非放過一個瑕疵品的損失過大，不然建議採用監視器的方式 隨機檢驗 應用在管理上: 經理人對一個特定事件多花點精神 應用在管理上的好處 增加員工的責任感 節省時間 對部屬事必躬親的壞處 過度干預 浪費時間監督不會出錯的部屬 養成部署依賴性 反正什麼事到最後老闆都會檢查 最近跟 KK 聊到「如果管理者必須事必躬親，代表的是管理者自己風險控管能力不足」 我也認同如果每件事都事必躬親，那就是我對自己的管理能力，投下了不信任票 更糟的是，這麼做還會讓自己的管理能力停滯不前 但有時候就是會忍不住啊（苦笑 槓桿率 較高的槓桿率 → 同樣的投入下，這項活動會較槓桿率低者有較高的產出 增加槓桿率的方式 自動化 工作簡單化 步驟 建立生產流程表（這個表必須詳盡） 計算步驟 → 接下來才找得出比較的依據 設定刪減的目標 先質疑每一個步驟存在的理由 很多步驟可能只是因為傳統或為了讓工作顯得正式，對實際的生產沒有幫助 第3章：管理槓桿率 經理人的產出 ＝ 直接管轄的部門產出 ＋ 間接影響所及的部門產出 經理人永遠有忙不完的事，永遠有更多的事要做、應該做，也永遠超過你所能負荷 😢 資訊收集 最重要的資訊來源往往來自於簡短而且非正式的談話中 有效的方式： 實際在公司走動 資訊傳遞 發出警訊 e.g., 打個電話建議你的同事該怎麼做, 在口頭報告中提出你的意見 除了傳遞資訊，同時將事情或人引導到你覺得對的方向上 決策 未雨綢繆型 亡羊補牢型 當部屬表率 價值觀和行事規範很難只用講的或是寫在紙上，最好的方法就「做」，還 得做得「讓人看得到」！ 「在資訊收集、資訊傳遞、決策制定、發出警訊以及為人表率這幾項管理活動中，有哪一項我可以不靠開會達成？」 答案是「沒有」 會議本身並非「活動」，它只是個「媒介」 媒介可能是開會，可能是張小紙條，甚至可能是公司的擴音機 目標： 找到最具「槓桿率」的活動 經理人的產出 ＝ 組織產出的總和 組織產出的總和 ＝ 槓桿率A×管理活動A ＋ 槓桿率B×管理活動B…… 增進經理人的生產力 加速活動進行的速度 提高活動的槓桿率 調整管理活動的組合： 用高槓桿率的活動取代低槓桿率的活動 達成高槓桿率 當經理人可以同時影響很多人 （e.g., 對年度計劃先做仔細的考量） 當經理人簡單的動作或簡短的話，可以對別人產生長遠的影響 當經理人所提供的技術、知識或資訊，會對一群人的工作造成影響 「負」槓桿率 舉棋不定: 經理人拖延決策，通常會影響到他人的工作 上級干涉 過度參與部屬工作 → 剝奪了部屬實際執行的機會 用太多技能性的指令（不管是不是真的懂） 如果發生得太頻繁，下屬會變得不再自己解決問題並轉而求助其上司 授權也是槓桿率 「授權人」和「被授權人」的關係間有一個必要條件： 有相同的資訊基礎，而且工作進行和解決問題上一套彼此認同的方法 經理人除了告訴部署既成的事實外，經理人還必須告訴部屬他的目標、優先順序以及做事的方式 沒有完備監督計畫的授權等於是瀆職 即使經理人已經授權，依然得付成敗責任 監督原則 在產品價值最低時便進行監督 e.g., 若交待部屬寫報告，你應該在他草稿打好之後便拿來看 採用不定期抽查 對不同的部屬進行不同的採樣方法 抽查的頻率以員工對授權案子的熟悉度而定 增進管理速度 增進速度的作法 找出限制步驟 (Bottleneck) 找出不做哪些事就會沒辦法繼續生產，再將其他活動繞著這些事來規劃 類似的工作集中做 管好行事曆 先排「一定要在某個時間」的事，再排「很重要但時間上較有彈性」的事 對於超過你工作量所能負荷的事，你必須說「不」！ 必須安排一些閒置時間 如果有不速之客或是非預期的電話，就不會讓一天的行程大亂 建立指標 存貨法 一個經理人必須要有一些「案子」的存貨 e.g., 不急著完成的案子，像是用來增進部門長期生產力的方案 標準化 生產流程一旦設定且經過試驗發現有效後，便不會任意改變 建立標準化流程的同時，應該繼續找更好的方法 應該有多少個部屬？ 根據經驗法則，如果「帶人」是經理人的主要任務，那麼他大約應有六到八個部屬，全職經理人大約在一星期內需要花半天的時間在一個部屬身上 干擾與突發狀況的解決良方 設法歸類出常見的問題，並備妥答案 → 更進一步授權給其他下屬來處理 不緊急的問題留至部門會議或是「一對一」會議一起處理 第4章：管理的必經之途：開會 你絕對無法避免開會，但你可以讓會議更有效率 過程導向會議 用「規律化」提升效率： 讓與會者都明白會議運作的方式、需要討論的議題、需要達成的目標 一對一會議 互通資訊有無以及彼此學習 上司將其技能以及經驗傳授給下屬，並建議切入問題的方式 下屬對工作的進度中碰到的問題做回報 一次「一對一」要開多久? 看部屬對現正進行任務的熟悉度 至少必須讓部屬覺得時間足夠到提出一些棘手的問題 提升效率 兩方都該握有會議綱要，並且都在會議中做筆記 在會議中能專心，並消化資訊 「寫下來」這個動作所象徵的意義 當部屬在經理人提出建議後動筆記下，這個動作表示的是一種承諾 建立存檔 將重要但不太緊急的事項列入，留待下次討論 上司應該鼓勵部屬在會議中講些「內心話」 會議後交換筆記 彼此了解對方立下的一些行動承諾 會議結束前，應該計畫下一次開會的時間 部門會議 與會者: 部門主管及其部屬 討論主題： 任何牽涉到兩個部屬以上的問題 進行方式 與會者應該事先知道要討論什麼，並在開會前做好準備 開始保留一段開放時間，讓大家能談工作上的枝微末節，甚至提出還未成型的提案 會議的議題應該讓部屬負責，而經理人的責任則是讓會議進行不要離題 營運檢討會議 讓一群不常合作的同事能有互動的機會 議程設計 讓與會者有機會向同事介紹工作內容，讓大家更了解公司 任務導向會議 目的： 用來應變，而且必須產生決策 召開會議前，先問「我有什麼任務要藉這場會議達成？是不是有必要？」 建議人數： 不超過 8 人 會議記錄 記錄事項 該做的事 誰負責做 什麼時候做 會議一結束就馬上發送會議記錄 「如果經理人花超過 25% 的時間在『應急的任務導向會議』上，這個組織一定有毛病。」 第5章：不揮舞權杖的決策 決策是由離問題最近，最了解問題的人來制定 「參與決策的制定過程」是經理人例行工作中非常重要的一環 理想的決策模式 自由討論 清楚的決策： 在討論階段有愈多不同的意見，愈有可能在此階段達成「清楚」的決策 全員支持： 決策是由離問題最近、而且最了解問題的人來制定 同儕團體症候群 「同儕團體再加一」（peer-plus-one） 當職位相當的人要開會時，需要有個職位較高的人與會，他不見得最能幹或最具有專業知識，但他能夠掌控會議的進行 制定決策前，經理人應有以下六項問題的答案 決策的內容 決策的時限 決策人 在制定決策前應先向誰請益 誰對此決策一言九鼎，或是能全盤否定 誰應該在決策制定後被告知 第6章：「規劃」是為了明天 有什麼事情我如果「今天」做了，可以讓「明天」更好，或者至少讓「明天」不會更糟 目標管理 我想要到哪裡？（目標） 我要如何知道正朝著目標邁進？（該驗收的戰果） 慎定目標： 目標協助你專注在需要注意的事項，因此目標數不能多 即使下屬沒能達成所設定的目標，他的績效仍可能被評為卓越 如果上司只用目標管理來決定下屬的升遷賞罰，以致下屬一心只放在訂好的目標上，錯失了其他可能，不免會見樹不見林 第10章：每個人都聽命的三個長官 工作上的行為，主要受這三項無形但極具效力的因素控制 自由市場考量 契約義務 文化價值觀 經理階層負責發展出組織內共享的價值觀、目標以及行事準則，以建立個體對組織的信賴 決定哪位長官該出場的兩項變數 個體關心的是團體或是自身利益？ 個體所處的工作環境本質 衡量一個工作環境: CUA指標 complexity 複雜性 uncertainty 不確定性 ambiguity 指令模糊程度 e.g., 某個剛進公司的新人身上 剛開始較關心自身的利益 → 給明確的工作架構，降低複雜性及不確定性 過了一陣子表現不錯，較有歸屬感 → 晉升到複雜性及不確定性都變高的職位 因此企業文化較強的公司較傾向於內部擢升 第11章：激勵部屬參加比賽 先確定部屬仍有需求尚未得到滿足 基本生理需求、安全感與歸屬感、認同感 → 上班在公司裡露臉 地位與尊重、自我實現 → 工作上追求更卓越 目標應該制定在高於一般人的能力，即使非常賣力，可能只有一半的成功機會 雖然個體可能失敗，但「靶定得遠，箭也射得遠」，實驗證明這種情況的產出大於「一蹴可幾」的目標 簡單測試一個人屬於哪個需求層級 在乎的是薪水調升的絕對值 → 基本需求、安全感 「相對於別人」調薪幅度是大是小 → 尊重、認同、自我實現 第12章：工作相關成熟度 部署工作成熟度 有效地領到風格 高 干涉降至最低，彼此建立工作目標和監督系統 中 注重在個體本身，強調雙向溝通，給予情緒上的支援以及鼓勵 低 提供明確且詳細的指示（做什麼事、何時完成、如何著手） 不管工作成熟度在哪個階段，經理人都應當隨時且適度地監視部屬的工作，以避免任何突發狀況 如果希望管理風格能夠由組織化進展到旁觀監督，必須先建立起共同的行事準則及決定優先順序 第13章：再難也得做：績效評估 績效評估 檢視技能水準： 決定部屬缺少了哪些技能並且設法補足 加強激勵來源： 讓具備適當技能的人創造出更高的績效 決定部屬的績效 主管得事先搞清楚對部屬的期望 ，再依此判斷部屬績效是否合乎期望 評估最大的問題大多是經理人並沒有列明對部屬的期望 產出評估與流程評估 產出評估: 黑盒子的產出 流程評估: 包括黑盒子中所有的活動 有些活動產出可能在年度內，有些則可能是為未來鋪路 避免達成目前的生產目標，而對未來造成傷害 遠程及近程績效 這件遠程活動最後能幫我們賺進多少錢？然後將此換算成現值 產出與時間的因素 個人、部門兩者兼顧 避免落入潛力陷阱 評估績效而非部屬的潛力（這裡的「潛力」指只有形式而沒有實質的事） 告知績效 三L原則 坦誠 (level) 傾聽 (listen) 動用所有的感官確保部屬真正了解你的意思 沒做到這點，所有的績效評估就都是浪費時間 每個好老師都個共通點： 他們知道學生到底懂不懂他在講什麼 如果學生不懂，他會再逐步解釋，或者換個角度舉個例子 我們都曾經碰過只對著黑板自言自語的教授，而且他們常能很有技巧地躲避學生的眼光 忘了你自己 (leave yourself out) 擺開你的不安全感、焦慮以及罪惡感 你要處理的是部屬的問題而不是你自己，這是部屬「上法庭」的時候呢 正反兩面俱陳 「多」並不就代表「好」 整理資訊 資訊來源 進度達成率 每季目標達成率 一對一會議的筆記 找出資料之間的的關係 也許有些項目是「同一個問題以不同面貌呈現」 也許能歸納出部屬弱點或是長處的指標 衝突性評估 解決問題的不同階段 從怪罪別人到擔負責任 →「心理上的障礙」 由擔負責任到尋找解決方案 → 「能力智識能解決」（較容易解決） 只要部屬願意採取行動改進就「可以接受」，人在複雜的事情上很難有相同的意見 為了完成任務，你最需要的是部屬願意採行你決定的行動方案，至於他同不同意與你抱持同樣的想法則是其次 評估明日巨星 常會發生的狀況 努力找明日之星做得好的證據，而不是如何增進績效；對表現不佳的部屬，則能寫出很多改進方案 我們是把優先順序完全弄反了！ 在明日巨星身上多花點心力才會得到較高的管理槓桿率 第14章：找人與留人 找人 提出問題以收集資訊 職能智識 描述曾經負責而上司很滿意的案子，特別是直屬主管的上司也滿意的 弱點或短處為何？如何改進？ 運用職能的能力 過往有那些成就？ 遭受過什麼失敗或挫折？ 知與用之間的差異 從以前的失敗中學過什麼教訓？ 目前職務上碰到哪些問題？ 工作價值觀 為什麼覺得能勝任工作？ 為什麼應該錄用你？ 為什麼應該用有工程背景的人擔任行銷職務？(隨招募內容改變問題) 大學時修過最重要的課與專案計畫 降低徵才的風險 假設性問題 讓應徵者發問 詢問關係人 無論你再如何小心謹慎，面試也無法保證些什麼，它唯一能做的只是增加你的運氣 留才大作戰 馬上放下手上的事情，請他到辦公室坐下來談，問他為什麼要辭職，讓他暢所欲言，千萬不要起任何爭辯 爭取時間，而不是想馬上變對方的想法 在他吐完了苦水後，問他能否給你一些時間想想 利用這些時間，你必須準備下一回合，並且做到在第一回合時承諾的事項 第15章：報酬的誘惑 回饋的多種考量 發放績效獎金必須在時間上 盡量接近工作完成 之時 → 記得為何受到獎勵 關於升遷 彼得原理 (Peter's Principle): 當一個人做好工作，他受到上司提拔，一直往上爬直到無法勝任，他便停在那個位置上 別怕再回收 「再回收」： 放回之前他表現優異的工作上 一個人可能被晉升到超出他能力太多的職位，因此有很長的時間他都達不到及格邊緣 第16章：別等火燒眉毛才訓練 經理人應該扛起訓練員工的責任 → 部門產出即經理人產出 增進工作的動力，使他們盡力把工作做好 增進部屬的工作能力","tags":"Book","url":"https://wei-lee.me/posts/book/2020/09/high-output-management","loc":"https://wei-lee.me/posts/book/2020/09/high-output-management"},{"title":"COSCUP 2020 / SITCON 2020","text":"因為這次 COSCUP 跟 SITCON 只隔了一週，就順手寫在一起了 COSCUP 2020 看了今年的議程表才發現很多 Python 的議程，而且還跟 PyCon TW 稿件的重複性很高（笑 早知道今年就該來投一下 COSCUP 不得不說，在全世界都受疫情所苦，實體研討會紛紛取消 能舉辦一場累計 2800 人次的會議，真的是很厲害 😲😲😲 前夜派對 去年收到前夜派對的訊息時，票早就已經賣光了 😢 今年除了把大會的售票亭拆掉，前夜派對的也一起拆了 憑著健康申明書就能入場 再來之前，好像跟誰聊到天，就會問要不要來喝酒 不小心就揪了不少人來 主要的時間都在跟老朋友聚，沒認識到太多的新朋友 但也還是玩的蠻開心的 演講 今年就真的是佛係聽講 因為也沒特別提早去搶位置，大家都搶著去的演講 我都是走到門口才看到排不進去了 XDD COSCUP 的主題相對算是廣泛 大概有一半都是跟我不太有關，我可能也不感興趣的 技術深度太深的，可能是我連基礎都沒碰過的東西，去聽也聽不懂 較為基礎的技術，也會讓我覺得好像回去看個文件就夠了 所以我比較傾向去聽軟性議題（e.g., 溝通的藝術，專案經理與工程師的二三事 ) 或是技術如何被應用到不那麼常見的領域（聽不懂細節沒關係，只是想知道講者者思考的方式） 倒是 COSCUP 幾乎每場演講都「像極了愛情」... BoF 想說都要來 COSCUP ，就接受推坑來主持一個 BoF 反正大概跟 Open Space 一樣...吧？ 來的人數還算是不少（2/3 是 PyCon TW 老朋友， 1/3 的新朋友） 原本想說既然 PyCon TW 2020 辦在台南，我們就來聊聊要去台南吃什麼美食吧（？ 但沒有好好規劃的結果，就是一陣尷尬 XDDD 如果以「討論要吃什麼台南美食」作為成功與否的指標的話，應該是蠻失敗的 XD 但以「連結對 Python 有興趣的人」為指標的話，倒是蠻成功的 連結到一些 PyCon TW 老朋友，也招募到幾位有淺力，合作愉快的夥伴 🤩 閃電秀（Lightning Talk） 最近參加的會議，我都會順手投個閃電秀推廣一下 commitizen-tools 但到了第二天被通知有抽到的時候，我才想起來前一天有投... 所以我轉接頭沒帶，投影片也還沒做（雖然閃電秀半小時前做應該也還好） 還好不是現場抽上台的那種，不然就太刺激了 XD 比起之前在 EuroPython 2020 即興的閃電秀，果然用自己的母語還是有差 大致上，我的閃電秀得到的回饋還算熱烈（？） 像是 真的沒在寫 js， Java Script... COSCUP 全大寫啊啊 中文的 git 好不習慣XD 根提交... 啊 打錯了 哎呀 怎麼會沒有時間了呢 「先要買，再考慮好..」 - Pycon 2017 其實我也很不習慣中文的 git ，但要改他實在有點麻煩 XD 啊，然後附上我的 閃電秀投影片 SITCON 2020 當初會想來 SITCON 就只是想支持 Pochun / Rain Wu 的演講 雖然 Pochun 跟去年的我都是在講 X-Village 相關的東西 他講的就是比我精彩很多，座無虛席啊 明顯看得出準備的用心程度就是不同 XD 除此之外，還想聽聽「臉書資料探勘－鯉魚教の教主崇拜分析」 但不小心在攤位聊得太開心，只趕上感謝教主 最不友善贊助商 今年其實我是以贊助商（社群？）的身份來的 除了回饋學生社群外，還有一個很大的目的是招募對 PyCon TW 有興趣的夥伴 但今年因為疫情從三月延期到八月 對離大會只剩一個月的我們來說，其實是有點晚了 所以我們就修改了這次的攤位方針 只針對主動對 Python / PyCon TW 有興趣的人講解，沒有的話就直接掃 QR Code 雙方都不浪費彼此的時間，仔細想想其實真的蠻不錯的 😆 道歉大會 閃電秀（Lightning Talks） 如同前面所提到的， COSCUP 的閃電秀中，我犯了很多的錯誤 身為一個負責任的人，必須要為自己錯誤的行為道歉 所以只好在 SITCON 公開道歉了（？？？） 影片很快就出來了，所以想看我道歉的可以直接看 道歉大會影片 （到底是誰會想看這種東西？？？） 順便附上 投影片 倒是會後有聽到也在 SITCON 幫忙的夥伴說，在閃電秀中，大家對我的最有印象... 這兩場閃電秀，我大致上的分配是 讓人覺得有趣的點 → 像極了愛情（並沒有）、道歉大會 想要傳達的知識 → commitizen-tools 很好用 想要業配的訊息 → PyCon TW 售票 在我撰寫這段文字的時候 commitizen-tools ，比起 COSCUP 前已經增加了 42 個 star 看來這個行銷策略很成功呢（？ 哦對了，如果看到這邊的你還沒買 PyCon TW 2020 的票 就快點買票吧 👉 PyCon Taiwan 2020 Registration","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/08/coscup-2020-sitcon-2020","loc":"https://wei-lee.me/posts/tech/2020/08/coscup-2020-sitcon-2020"},{"title":"EuroPython 2020","text":"好不容易投稿上了 EuroPython 原本打算順便去愛爾蘭的 Skellig Michael 疫情一來就全都去不成了 😭 前言雜談 EuroPython 2020 在 3 月底的時候公佈轉成線上會議 比起 PyCon US，場地跟其他費用都還沒有支出，算是蠻幸運的 倒是今年線上會議要收票的問題，聽說在 Telegram 群組有一番爭論 一張一般票 EUR 95.00 的確不算很便宜 不過講者票今年不用錢就是了 XD 今年有來自 69 個國家的會眾參與，比起 2019 多了 40 個國家 雖然大家抱怨歸抱怨，最後好像還是有 1000 人以上買票啊 XDDDD 線上會議跟真人會議的體驗上會有差是無法避免 但我覺得已經算是盡可能把實體會議的一切搬到線上了 能在這麼短的時間內，完成那麼多規劃真的蠻厲害的 最棒的一點是，留了很多文件給大家參考 🤩 EuroPython 2020 Online Conference Tools EuroPython 2020 Speaker Guide 以往 EuroPython 的演講影片都會公開，並放到 PyVideo 上 我原本蠻好奇今年打算怎麼在收費和不收費的會眾做出區別 畢竟以往購票參與會議一個很大的價值是跟其他的與會者互動 今年的互動雖然用 Discord 來彌補，但還是會打一些折扣 最後的作法是會先還沒剪的影片傳到私有的 Youtube 頻道供購票會眾觀看，但兩週後就會公開 幾週後弄完就把修剪版放上去 整體參加下來我覺得是很成功的線上會議，我也很享受跟會眾的線上互動 雖然少了實體的互動是可惜了點，但降低參與成本讓更多還自不同地區的人能一起來共襄盛舉 現在也還說不準預期疫情到底什麼時候會結束，不知道線上會議會不會是一個新的標準 又或者之後可以嘗試一下實體/虛擬混合的會議？ Discord 互動設計 EuroPython 設計了很完整的架構，讓會眾可以更快速的找到各個資訊在 Discord 的哪裡 Lobby Lobby 的 Channel Category 主要是註冊用跟大會公告 進到 info-desk 輸入自己的票務資訊後，就會有機器人自動設定正確的權限 而且這個機器人也有開源 👉 ep-regbot hallway 可以想像成大會的走廊，就是讓會眾隨意聊天的地方 好像有人問有沒有人要在 after party 的時段直播表演樂器 有點像是 PyCon TW 的 PyNight 但 after party 的時間，在台灣的凌晨，我就沒有參加到了 Conference Tracks 註冊後最重要的是 Conference Tracks 這個 Channel Category microsoft / brain/ ni /parrot 可以看成 PyCon TW 的 r0 / r1 /r2，總之就是不同的 track 除了 track 都有自己的討論頻道外，每個 track 還會有一個 .*-peek 的頻道 機器人會截圖 track 中現在 Zoom 的畫面 供會眾參考要不要連進去現在的 Zoom 或是看 Youtube 我覺得這個功能真的超酷 XDD 另外，每個 Track 都會有自己的 Channel Category 裡面會有每一個講者的頻道 身為講者，我覺得有一個自己的頻道可以繼續跟會眾互動真的蠻棒的 💯 還有兩個頻道是給 Open Space 用的，這次好像不算特別熱絡 一天大概只有兩、三場 Sponsor Exhibit 贊助商也會有各自的頻道 也會有各自的 Zoom ，可以跟跟會眾互動 我有稍微路過一下，但沒參與太多就跑去參加下一個演講了 另外，在每一場演講的間隔，會播放贊助商的廣告影片 我覺得效果蠻不錯的 畢竟就是在等下一場演講，好像就還是得看完 XD Attendee Rooms 會眾有一整個 Channel Category 好像可以自己創主題式的討論 但這部分我就真的沒什麼參與到了 Backstage 講者後台的設計就真的有點複雜 在線上會議會遇到的一個問題是「怎麼提醒講者時間快到了」，直接在演講中打斷講者好像不太適合 他們的作法是講者會在演講開始前 15 分鐘加入 .*-greenroom ，讓 session manager 確定講者已經抵達 接著， session manager 會讓講者加入 Zoom 跟 .*-talkback 用 Zoom 讓講者做演講並跟主持人做互動 session manager 則是透過 .*-talkback 跟講者說剩下的時間 在線上會議也有講者準備/休息室（greenroom）的概念真的蠻有趣的 XD 會期 Day 1 第一天開始時因為技術問題卡了十幾分鐘 倒是有會眾開始詢問，有沒有人有 vga-to-hdmi 轉接線 It's just like being there in person - \"does someone have the correct vga-to-hdmi adaptor?\" 🙂 EuroPython 就連實體會議找不到轉接線都模擬了（誤 大家都在等有沒有會眾剛好有帶 HDMI 線現場救援（？？？ 有跟上這段討論真的超有趣 😆 開場結束後，馬上又遇到下一個問題 連接線找到了，但找不到講者 😱 第一場 Keynote Speaker 就直接 no show 了，真的有點尷尬 @@ 因為時差的關係，大概會有三分之一的演講完全沒機會聽到 晚上我又另外有事，第一天沒聽到什麼演講 這兩場是我還有時間做筆記覺得也蠻不錯的演講 Clean Architectures in Python Practical Optimisations for Pandas 我超佩服 @ongchinhwee 她每個研討會都能在 twitter 上做超多超快的筆記 今年她在 PyCon Taiwan 演講完，要好好跟她請教怎麼辦到的 XD Day 2 Community-oriented conference status during COVID-19 Noah 分享了亞太地區 PyCon 的近況 台灣是亞太地區唯一能辦實體 PyCon 搞不好有機會是 2020 疫情開始後，唯一一場能辦實體的 PyCon How to Avoid Becoming a 10x Engineer 這場演講頻道的討論超熱鬧 看來大家應該都遇過了 10x Engineer 寫 code 是一般人的時倍快，製造的 bug 是十倍快 Live-coding a music synthesizer 原本應該要去聽 Advanced Infrastructure Management in Kubernetes using Python 但這場從 ni-peek 看到的截圖實在太有趣了，就來看 Ram Rachum 如何現場完成合音器 Python Table Manners: Cut the Cookie Gracefully 這場是我自己的演講 XD 雖然講過幾次了，而且又是線上的 但老實說還是稍微會有點緊張 不過在我的頻道中，討論算是還蠻熱烈的 也被問了蠻多問題的 其中一個問題是「為什麼要使用 invoke ，而不用可以跟 poetry 整合的 taskipy 」 恩... 就只是單純因為我不知道有這個東西 XD 就會眾的反應來看，大致上這場演講是成功的 一開始構思這場演講的時候，也會擔心內容會不會不夠深入 但介紹了這麼多工具，總會有一兩個是會眾不知道吧！ 不然帶走我的 cookiecutter template 還是能省下一些重造輪子的時間 Running EuroPython 2020 as an online conference 這場演講外，大會主席還給了 EuroPython 2021: Help us build the next edition! 的演講 除了講今年線上會議遇到的困難，還招募了明年有意願來籌備會議的會眾 slide 其中有提到為什麼 2020 還是要收錢 因為如果今年不收錢了，以後如果突然要收錢就會變得很困難 大概就跟調降健保費就漲不回去的概念是一樣的 對於一個組織跟研討會的存續其實是不好的 If you can handle free, that's fine, I still believe that the free for all is going in the wrong direction. It's likely that we will stay in this situation for a longer while and unless you plan for it longer term, running free events is going to create too much loss for the orgs behind the conference to stay alive. 另外，還有一個問題很有趣 如果開啟 Zoom 會議的主持人電腦當機怎麼辦？ 這時候會不會講者的演講就突然中斷了 這還真的是我完全沒想過的問題 他們的解法是直接用雲端服務開 VM 來開 Zoom 的會議避免掉這樣的問題 Making Pandas Fly 講者 Ian Ozsvald 同時也是 High Performance Python 的作者 這場主要談如何讓 Pandas 更有效率，大多都是蠻泛用的技巧，算是蠻有收穫的 筆記我放在 Making Pandas Fly 如果覺得這場演講對你有幫助，可以寄明信片給 Ian Ian 很喜歡收明信片 XD Lightning Talk 除了演講外，我也報名了 Lightning Talk 在一天開始的某一個時段，開放一個 Google Sheet 讓大家填，先搶先贏 我的內容當然是繼續宣傳 commitizen-tools XD 不過用英文演講又要 Live Demo 果然還是需要準備一下 即興上場還是會有點卡 Guido van Rossum Q&A Guido 的訪談算是第二天的重頭戲，稍微紀錄一下我比較有印象的內容 Python will always be dynamic language. Type needs to be optional. 對於新進的軟體工程師，推薦可以看 King's Day Speech Q: 你能想到你最不喜歡 Python 哪嗎? A: 目前沒想法，抱歉 Developments Sprint 報名的方式很容易，只要到 EuroPython 2020 Sprints 上面自己改文件就好 順帶一提，今年 PyCon TW 的 Sprint 也是採用相似的形式 👉 PyCon TW 2020 衝刺開發 Development Sprints 第一天的開始會請各個專案的主辦人介紹自己的專案是什麼 除了專案以外，還有人帶初學者 session ，讓第一次參加的人可以更容易進入狀況 算是蠻好的設計，也許我們可以來學一下 🤔 今年線上的 Sprint 好像沒有很多人參與 也可能是 commitizen 的 Sprint 真的太邊緣了..... 從頭到尾就只有我跟作者 Santi 兩個人在寫 中間會有人突然跳進來，但他們都一語不發就又跳出去了 0.0 雖然我們邊緣，我們還是解決了超多 issue！ 這兩天把 commitizen 1/3 的 open issue 解掉 而且釋出 2.0 邊緣歸邊緣，我們還是很有產出的！ Sprint 的中間還有個有趣的小插曲 因為大家很好奇怎麼做 mate 第二天的晚上，就突然開了一個做瑪黛茶的 Open Space XD","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/08/europython-2020","loc":"https://wei-lee.me/posts/tech/2020/08/europython-2020"},{"title":"[Book] 一週工作四小時","text":"隔了半年終於又看完一本新書... 看書速度實在有點慢 這本書很重要的一個思想是「你如何衡量你的人生」 高工時高薪資和稍微低一點的薪資但自由，怎樣的人才是更加富有的？ 你如何把時間放在重要的事情上，放下低產出的事 雖然你的總產出看似降低了，但這個決策給了你更多的自由 它提到的部分嘗試都需要不少勇氣來能做到 但我覺得先看過，知道有人是這樣思考的，倒也沒什麼不好 我看完會馬上想來試試的是減少收電子郵件的頻率 XD 1. Definition 定義人生 每週工作八十小時、年薪五十萬美金的投資銀行家，相較於工時僅有銀行家四分之、年薪四萬美金的新富族員工，其實是更沒力量的，因為新富族能自由掌控何時、在哪、如何生活 本書的基本原則 退休是為防後患的保險 興趣與精力都是週期性的 穿插工作與休息是生存的必需條件 → 迷你退休 （e.g., 每工作兩個月後，就到海外換個環境待一個月） 做得少不代表偷懶 少做沒意義的工作，好專注在對你而言更重要的事情上 重新定義「懶惰」 → 忍受理想外的生活，讓外在環境或他人左右你的人生，或是累積大量財富，卻虛度人生 時間點總是不對 ← 「總有一天」不會到來 請求原諒，而非許可 如果這麼做不會讓周遭的人心碎，那就儘管嘗試，再說明你的理由 強調優點，而非改進缺點 物極必反 光是錢不能解決問題 「如果我有更多錢」是不斷延遲的自我醒獅、下定決心營造人生的藉口 → 就是現在，別再等了 相對收入比絕對收入更重要 當然相對收入必須達到能實現目標的最低水準 避免惡性壓力 (distress)，樂於承受良性壓力 (eustress) 如果你對採取行動猶豫不決，試著思考以下問題 做了這件事，會發生的最恐怖狀況 能採取什麼行動彌補，或讓事態暫時好轉 在比較有可能的局面下，會出現什麼暫時和長久的結果或好處 如果今年被開除，你會做什麼事，避免財務出狀況 你因為恐懼拖延了什麼 延後採取行動，對你造成什麼代價（e.g., 經濟、情緒、健康） 你在等待什麼 2. Elimination 忙碌表象： 一般人最常用忙碌當擋箭牌，避免去做幾樣很重要，卻會攘人不自在的行動 效率很重要，但如果沒用在正確的事上，等於徒勞無功 生產力法則 只做重要的事，縮短工作時間 （八十/二十法則） 縮短工作時間，只做重要的事 （帕金森定律） 「如果這是我今天唯一完成的事，我會對這天的表現感到滿意嗎」 低資訊飲食 in action [ ] 立即進食媒體大餐一週 禁止報紙、雜誌、有聲書或非音樂廣播 禁止新聞 禁止電視，除了晚上一小時 禁止讀書，除了晚上一小時的小說消遣 禁止辦公瀏覽網站，除非辦公必須 [ ] 「對我而言，這像資訊有立即、重要的用途嗎？」 [ ] 練習有始無終的藝術 打斷干擾與拒絕的藝術 每天檢查電子郵件兩次，一次在午餐前，另一次在下午四點 「小狗成交法」 如果有人很喜歡一隻小狗，但遲遲未下決定，寵物店會提議讓客人先帶小狗回家試養，如果改變主意，可以把小狗帶回來 讓他們「試試看」，給他們嘗試後反悔的機會，好讓你得寸進尺 3. Automation 自動入帳 4. Liberation 自由逍遙 爭取遠距工作 概念 顯示遠距工作對業績的注意 讓老闆覺得回絕遠距工作的請求，代價昂貴或不值得 實例 1 增加公司在自身的投資 證明辦公室外的生產力高 準備可量化呈現的績效 提出可終止的適用期 <- 「小狗成交法」 實例 2 (沙漏法) 使用預先計畫的緊急事件，任何需要你離開辦公室兩週處理的事 告訴上司希望期間能繼續工作，而非請假 提出遠距工作的方案，如果績效不加，可以斟酌扣薪資 與主管研擬在家工作的方案，好讓對方參與過程 讓兩週的「休假」成為最具生產力的兩週 回到辦公室後，展示量化的成果，證明在家工作的效率 提議每週在家工作兩到三天作為實驗 生產力要在遠距工作的日子爆增 提議每週只在辦公室一到兩天 讓進辦公室成為每週生產力最低的日子 提議全面性行動辦公 如同所有領先時代的創新者，你會有猶豫的時刻，常見的疑慮或自我鞭策（在認清這些想法的本質後，大多數都能推翻：這些都是「多比較好」與「錢多就是成功」的比較心態作祟） 這麼做真的是追求更多自由，過更好的生活，還是根本就瘋了？ 退出爭名逐利的生活，是因為這種生活不好，還是只是在逃避？ 這種生活真有這麼好嗎？或許我在當人下屬，忽視其他可能性時，還活得比較好，至少簡單多了。 我真的很成功嘛？還是只是在自欺欺人？ 我是否降低成功的標準？我的朋友現在賺的錢比三年前多兩倍，他們走的路是不是才是正途？ 為什麼我這麼不快樂？我可以做任何事，但我不快樂。我真的適合過這種生活嗎？ 新富族的十三大錯誤 失去夢想，墮入為工作而工作的陳規 事必躬親，時常檢查地電子郵件消磨時間 回覆可以用問與答或自動回覆回答的電子郵件 在你該過活、睡覺或放鬆時，卻還在工作 沒有每二到四週，對你的事業和個人生活，進行周詳的八十/二十法則分析 把不緊急的事看得十萬火急，合理化繼續工作的決定 忽略人生寶貴的友誼與親情 Last but not least 六個達成高產出及啲壓力的配方 為自己訂下規則，讓決策程序自動化 無法採取實際行動時，不要開始掛心問題 不要為了避免尷尬的對話，而遲遲不做決定 若非人命關天或無法轉圜的情困，學著盡快做決定 若非必要，不要追求變化，因而增加考慮各種選項的時間，習慣可以創造出最必要的創新 後悔是事後諸葛的決策模式，減少抱怨以降低後悔的次數 不辦清單 不要接聽陌生來電 不要一早或睡前收電子郵件 不要答應出席沒有具體的議程或結束時間的會議 不要持續檢查信件 - 「批次化」並在固定時間收信 不要加班處理堆積如山的工作，排定優先順序 不要無時無刻隨身攜帶手機或叫個不停的智慧型手機 書中建議的服務 Freedom 低價網域註冊: GoDaddy 相片庫: iStockphoto","tags":"Book","url":"https://wei-lee.me/posts/book/2020/07/escape-9-5-live-anywhere-and-join-the-new-rich","loc":"https://wei-lee.me/posts/book/2020/07/escape-9-5-live-anywhere-and-join-the-new-rich"},{"title":"Remote Python Pizza 🍕 2020","text":"上週六參加了第一場遠端的 Python 研討會 Remote Python Pizza 由於疫情的關係，國外的 PyCon 大多轉往線上或取消 雖然目前還不確定今年台灣的狀況會如何 但先觀摩一下其他社群怎麼做的，對我們也很有幫助 整體的體驗比我想像的好了不少，我還蠻享受 Remote Python Pizza 的 雖然只是透過螢幕跟文字，還是能感受到整個社群的交流 或許這在疫情趨緩後，也可以作為研討會的另一種標準 雖然少了實體的交流，但不用長途跋涉就可以集結全世界的大大們，其實也很方便 而針對時差這件事，他們也有在議程表上標上 UTC 跟使用者的當地時間，這在遠端研討會上就變得很必要 會眾交流主要是透過 Discord 不管是要回報 CoC 、對講者提問、工作人員休息室...等，都有專屬的頻道 盡可能將實體會議的元素都帶進來，其實還蠻有趣的 演講則是給主辦人先給講者跟主持人 Zoom 的連結 講者演講前的 30 分鐘，就先加入 Zoom 待命，接著把影片串到 Youtube 上讓會眾觀看 Remote Python Pizza 的時間非常緊湊 每一場演講只有十分鐘，演講之間的休息只有兩分鐘 因為也沒有實際換場的必要，所以這段就很考驗主持人的技術了 pyjokes 對於英語系的會議，應該會很有幫助 XD 因為時差的關係，開始的時候已經是下午四點 大概聽到八點就開始覺得有點累了 不過坐在客廳用電視投影演講是真的還蠻爽的 XD 為了響應 Remote Python Pizza ，我當天的晚餐也是吃 Pizza 而且 Discord 中就有一個 #cafeteria 頻道，讓大家曬自己的 Pizza 照 其實還蠻 High 的 XD 我覺得這是線上會議 鼓勵會眾互動非常棒的設計 第一場 Hynek 的 On the Meaning of Version Numbers 就先介紹了 SemVar 主要說大部分的專案都沒辦法用好 SemVar ，所以 SemVar 可能太難遵守，不見得是一個很好的作法 可以改成使用 CalVer 在一開始我會提到的 SemVar 就好好的被打臉了一波 XDDD 第二場講者沒來，所以就跳過直接換我，害我錯愕了一下 一場演講只要十分鐘，完全是個適合推廣 commitizen-tools 的好機會 就毅然決然的投稿了 XD 不過真的沒想到，官網會直接用我 Twitter 的大頭貼＠＠ 不過既然都被用了兵長的頭貼，我就順勢穿著調查兵團的披風來給演講了 XD 有點久沒講英文，還是覺得稍微有點卡 倒是我在演講中提到還是 beta 的自動產生變更日誌（changelog）功能 剛好在今天正式釋出了，快點來試試看吧 🤩 python -m pip install commitizen Disconnect3d 給的 sudo python is a trap, use isolate mode 是我印象最深刻的一場 現場 demo 如果你使用了 sudo python ，駭客多輕鬆就可以駭入你的電腦 所以不要使用 sudo python 啊！ 整體節奏太緊湊，實在沒什麼時間好好做筆記 之後再找個時間把比較有趣的內容補起來 每一場演講結束後 除了在 Zoom 中的主持人會拍手外，大家會在 #question-answer 頻道洗一波 👏 的 emoji 其實還蠻可愛 XD 大家也能在這個頻道直接堆剛講完的講者提問 另外也有 #slide 頻道，讓大家快速找到講者的投影片 講者也可以在結束後，創一個 #talk-*. (e.g., #talk-commitizen ) 的頻道討論演講相關的內容 以講者的角度來說，我覺得這裡的交流甚至有機會比實體會議更多，是個蠻好的作法 中間倒是有個小插曲，直播到一半就被 Youtube 封鎖了...... 最後發現原因是直播時不能開 Made for Kids ，很容易被封鎖 而且這還是預設值，要自己記得關掉＠＠ 這倒是可以作為一個警示，線上會議要多準備幾套備用的方案 大概就是這樣 因為時差的關係，我大概撐到 12 點就差不多了 畢竟整個會議有 50 場演講，延續了 12 個小時 要全部參加完實在太累了 之後再來補帶吧","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/05/remote-python-pizza-2020","loc":"https://wei-lee.me/posts/tech/2020/05/remote-python-pizza-2020"},{"title":"Python Table Manners - 文件","text":"Python 開源專案中， Sphinx 是很常見的文件產生工具 它能將 reStructuredText 寫成的文件轉成網頁 Read the Docs 也直接支援 Sphinx 產生的網頁 但我今天要介紹的工具是 mkdocs 最簡單的原因就是，我只會寫 Markdown 不會寫 reStructuredText XD Guido 也說簡單一點的文件可以使用 Markdown 而不需使用 Shpinx （我又要搬同一張截圖出來救援了 XD） 安裝 pipenv install mkdocs --dev 使用 這次依然是以將 mkdocs 運用到 pycontw-postevent-report-generator 為例子 在 commit 3fab5b 版之後產生將文件從 README.md 移動到 docs 並產生 GitHub Page 初始化 首先進到專案資料夾中，初始化 mkdocs 需要的檔案 pipenv run mkdir new . 執行後，資料夾會多出以下兩個檔案 mkdocs.yml : mkdocs 的設定檔 doc/index.md : 空白的範例文件 透過這個指令在本機將伺服器跑起來 pipenv run mkdocs serve 打開瀏覽器，進入 http://127.0.0.1:8000/ 就能看到最初始的頁面 修改網站名稱 初始的 mkdocs.yml 預設只會有這一行 site_name : My Docs 指的是文件的頁面名稱，先把它改成專案的名稱 site_name : PyCon TW post-event report generator (rg-cli) 增加頁面 因為 GitHub 也會讀 docs/READMD.md 作為進入專案時看到的文件 為了減少維護文件的時間，可以將 README.md 移動到 docs ，並取代掉 index.md 做為首頁 因為原先在 pycontw-postevent-report-generator 中的 README.md 有點長 我將 How to contribute 的內容拆出來放到 contributing.md 將檔案命名成 contributing.md 在 GitHub 開 issue 時自動出現這個頁面的連結（See more 👉 Setting guidelines for repository contributors ） 至於要怎麼寫好 contributing.md 則可以參考 Wrangling Web Contributions: How to Build a CONTRIBUTING.md ├── docs │ ├── README.md │ └── contributing.md 接著在 mkdocs.yml 加入 nav 參數，指定不同頁面對應的檔案 site_name : PyCon TW post-event report generator (rg-cli) nav : - Home : index.md - Contributing : contributing.md 位置是透過參數 docs_dir 來決定相對路徑 如果沒有設定，預設是相對於 docs 內部連結 撰寫文件時，為了讓使用者更容易找到其他頁面，會使用到內部連結 這時只要在文件中使用跟 mkdocs.yml 一樣的相對路徑即可 e.g., 在 README.md 連結到 contributing.md Please see the [ Contributing ]( contributing.md ) for further details. 更改主題 mkdocs 預設有 mkdocs , readthedocs 兩種主題 如果想嘗試其他主題則可以在 MkDocs Themes 找到 以主題 mkdocs-material 為例 首先先將主題安裝到開發環境內 pipenv install mkdocs-material --dev 在 mkdocs.yml 加上 theme 參數 需要注意的是這裡的 name 不需要加上前綴的 mkdocs- site_name : rg-cli nav : - Home : index.md - Contributing : contributing.md theme : name : 'material' 輸出靜態網頁 為了要能部署到其他服務 (e.g., GitHub Page）上，要先在本地將 Markdown 寫成的文件輸出成網頁 pipenv run mkdocs build 接著就可以在資料夾 site 找到輸出的網頁 因為 site 的內容都會跟著 docs 改變，專案中只需要留有原始的 Markdown 文件就好 可以在 .gitignore 加入 site/ echo \"site/\" >> .gitignore 下次輸出時，在指令後面加上 --clean 就可以清空上次的內容，重新輸出 pipenv run mkdocs build --clean 部署至 GitHub Page 在開源專案中，將文件部署到 GitHub Page 上是相當常見的 mkdocs 也為我們考慮到這點 只要在 mkdocs.yml 加入專案的 remote 相關設定 repo_url : https://github.com/pycontw/pycontw-postevent-report-generator remote_branch : gh-pages remote_name : origin 並執行 pipenv run mkdocs gh-deploy 就會自動將文件部署到 GitHub Page 上 如果想更近一步透過 GitHub Action 來達到 push 原始碼，就自動產生 GitHub Page 可以參考我之前寫的 透過 GitHub Action 自動發佈 Pelican 部落格文章 雖然裡面使用的例子是 Pelican ，但只要把建置頁面的指令換掉就可以了 其他 mkdocs.yml 常用設定 site_description, site_author, copyright google_analytics markdown_extensions mkdocs 解析 Markdown 文件時要使用 Python Markdown 的 extension 和其設定 plugins 預設會使用 search 套件，如果想使用其它套件可以在 MkDocs-Plugins 找到 Bonus: 徽章 在開源專案中，常常可以見到一些有趣的徽章 它們很可能就是用 shields.io 產生的 除了常見的徽章外，也可以透過修改 url 製作客製化的徽章 像是在 markdown 文件加入 ![ shields badge ]( https://img.shields.io/badge/<LABEL>-<MESSAGE>-<COLOR> ) 就會出現 自製測試覆蓋率徽章 最近發現另一個有趣的小工具 - coverage-badge 它可以不透過 codecov 直接去讀 pytest-cov 產生的 .coverage 產生測試覆蓋率徽章 pipenv install coverage-badge --dev pipenv run coverage-badge -o docs/coverage.svg Reference Publish a (Perfect) Python Package on PyPI MkDocs mkdocs-material shield.io","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/04/python-table-manners-documentation","loc":"https://wei-lee.me/posts/tech/2020/04/python-table-manners-documentation"},{"title":"Python Table Manners - 安全性檢查","text":"果然在沒有寫作松的督促下，馬上就拖稿了 XD 接下來要介紹在 Python 專案中做安全性檢查的工具 Safety - 檢查相依套件 不知道大家有沒有在 GitHub 上看過這樣的畫面 這個訊息告訴我們，專案的相依套件中可能有安全漏洞 透過 Safety 就能在本地做相依套件安全漏洞的檢查 它會到 safety-db 去查找已知的安全性漏洞 這個資料庫則是從 CVE (Common Vulnerabilities and Exposures) 整理出來的 如果是免費版，一個月會更新一次資料庫 付費版則可以達到即時更新 安裝 pipenv install safety --dev 執行 pipenv run safety check 在 pycontw-postevent-report-generator commit 128d ，透過 safety 不會找到任何安全漏洞 如果想要測試 Safety 的功能可以安裝套件 insecure-package ( 這個套件是真的存在的，而且是不安全的，僅作為測試用途 ) pipenv install insecure-package --dev 再試一次就能看到 Safety 將 insecure-package 列為不安全的套件 另外需要注意的是 safety check 是對當前環境做檢查 務必確定已經有進入專案的虛擬環境，不然 Safety 只會檢查到本機使用的套件有沒有漏洞 如果想要對 requriements.txt 做檢查，則可以加上參數 -r # 因為這個 case 不是針對 pipenv ，所以前面沒有加上 pipenv run safety check -r requirements.txt 雖然 Safety 並不支援對 Pipfile 進行檢查 (Ref: Add Pipfile support #47 )，但 pipenv 就內建有安全性檢查的指令 pipenv check bandit - 程式碼靜態分析 除了套件安全性的分析外，接著還能透過 bandit 來對自己的程式碼做靜態分析找出常見的漏洞 安裝 pipenv install bandit --dev 使用 pipenv run bandit -r <package> 執行後就會看到一個列表，整理出專案中可能有的安全性漏洞 每一個項目中會有以下五個欄位 Issue: 問題 Severity: 嚴重性 Confidence: 可信度 Location: 位置（在程式碼的哪一行） More Info: 詳細的原因和可能的解決方案 （也可以從 Complete Test Plugin Listing 找到全部的列表） 加上參數 -i (可信度) 和 -l （嚴重性），就可以讓 bandit 只回報特定程度的漏洞 越多的 i / l 代表程度越高 以下指令就是讓 bandit 只回報高嚴重性 ( -lll )、高可信度 ( -iii )的漏洞 pipenv run bandit -iii -lll -r <package> 局部跳過檢查 有時候 bandit 給的警告不會在所有狀況都適用 以 B101: assert_used 為例 警告不該使用 assert 在使用 python -o 指令產生優化過的 byte code 時，會跳過 assert 如果系統使用 assert 來進行登入的檢查，就會讓使用者在完全沒驗證的情況下成功登入 但大部分的時候，我們不太會這麼實作 而 assert 也是在測試中很常使用到的語法 這時候就可以在專案的最上層加入設定檔 .bandit 而它的格式會長這樣 [bandit] # 要執行 bandit 檢查的檔案或資料夾（逗號分隔） targets: # 跳過 bandit 檢查的檔案或資料夾（逗號分隔） exclude: # 要跳過的檢查種類 （逗號分隔） skips: # 要執行的檢查種類 （逗號分隔） tests: 執行 bandit 時要加上 --ini .bandit 讓 bandit 知道要找這份設定檔 bandit --ini .bandit 如果不是整個檔案或種類要跳過，則可以在程式碼後面加上 # nosec Reference Python Security Tool - PyCon US 2019 Watch out for Safety Bandits! - PyCon AU 2018 用 Bandit 靜態掃描工具，掃描 Python 專案中的安全性問題","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/03/python-table-manners-security","loc":"https://wei-lee.me/posts/tech/2020/03/python-table-manners-security"},{"title":"Python Table Manners - Commitizen: 規格化 commit message","text":"接續著前一篇的 pre-commit ，繼續談 git 相關的工具 這篇來聊聊如何透過 commitizen 規範 commit message 還有規範過的 commit message 能拿來做什麼 為什麼要好好寫 commit message 如果不好好寫有意義的 commit message，每次都只用 \"update\" 當訊息 當你下了 git log 指令，就會看到一堆 \"update\" 然後哪天系統出錯的時候，你也會不知道要回朔到哪一個版本 (from hackjutsu/bad-commit-example ) 撰寫好的 commit message，除了讓未來的自己知道自己在幹嘛 也能讓團隊之間的溝通更順利 送 Pull Request / Merge Request 時，審核者能更快速地知道增加了哪些功能 新進人員可以從過往的 commit message 找到整個專案發展的脈絡，更容易上手專案 Commitizen 除了提供的 commit message 撰寫建議和規範 （👉 Writing commits ） commitizen 更進一步提供互動式介面，讓使用者可以夠輕鬆地產生符合規範的 commit message 同時也整合了前一篇所提到的 pre-commit hook，避免使用者將不符合規範的 commit message 寫入 除了採用來自 Angular 社群的 Conventional Commits (約定式提交) 外， commitizen 提供了高度的客製化，讓每個團隊或專案都可以依照自己的需求，撰寫相對應的規範 規範了 commit message 後，除了增加可讀性增加外，也讓訊息有可以被解析做其他運用 e.g., 提升版本號, 產生更新日誌 安裝與設定 Commitizen 跟 invoke 一樣，我會把 commitizen 同時安裝在系統和虛擬環境 安裝在虛擬環境主要是為了能在 CI/CD 伺服器上自動升版 # 安裝 commitizen 到系統 pipx install commitizen # 安裝 commitizen 到虛擬環境中 pipenv install commitizen --dev 在專案中第一次使用 commitizen 可以使用初始化指令來完成基本的設定 cz init 一開始會先問想使用哪種設定檔 接著要選擇一套 commit 規範，預設有三種 如果有安裝其他的 commit 規範，它們也會出現在選項中（See more 👉 Third-Party Commitizen Templates ） 再來會問最新的 git tag 是否為最新的版本號 如果不是，就會列出 git tag 所有的結果 如果完全沒有用過 git tag，預設會是 0.0.1 之後會詢問版本的格式要是如何 常用的格式有 $version (e.g., 1.0.0 ) 或 v$version (e.g., v1.0.0 ) 最後會確認要不要將驗證 commit message 的 pre-commit hook 設定好 完成後就會看到以下畫面 相對應的設定也會加入到設定檔 pyproject.toml (或 .cz.toml ) [tool.commitizen] name = \"cz_conventional_commits\" version = \"1.0.2\" tag_format = \"$version\" 使用 Commitizen # 使用 commitizen 做 commit # (也可以用簡短版的 cz c) cz commit 以 cz_conventional_commits 這套規則為例 會先詢問這次的 commit 做了哪一種改動 接著會要求輸入這次改動各項細節 Scope： 改動範圍 Subject： 簡短敘述這次的改動 Body： 詳細敘述這次的改動 Is this a BREAKING CHANGE？： 這是否是一個重大改動 Footer： 其他參考資訊，通常可以將 Issue 的編號寫在這 回答完，就會產生 commit message feat(blog-post): update python table manners series 最下方則是 pre-commit hook 的 commit message 格式檢查通過 強制檢查 commit message 剛開始引入 commitizen 時，可能會常常忘記要使用它來做 commit 這時候就能使用到前一篇提到的 pre-commit 雖然在 2.0.0 後可以透過 cz init 初始設定好，但還是說明如果事後才想設定要怎麼做 我在 commitizen 中有加入 .pre-commit-hooks.yaml 因此只要在專案的 .pre-commit-config.yaml 加入以下這段 - repos - repo : https://github.com/commitizen-tools/commitizen rev : v1.23.1 hooks : - id : commitizen stages : [ commit-msg ] 並透過 pre-commit 設定 commit-msg 階段的 git hook pipenv run pre-commit install -t commit-msg 在 commit 執行完，要進訊息寫入前 git 會執行 cz check 來確認輸入的訊息是否符合規範 如果不符合規範就會拒絕這次的 commit 需要注意的是檢查會在產生 commit message 後才能執行 因此要設定 commit-msg 階段的 git hook （i.e., .git/hooks/commit-msg ） 如果只下 pipenv run pre-commit install 是不會成功的 接著可以開始聊勞，這些 commit message 能做什麼應用了 自動提升版本號 與 commit message 規範可以做客製化不同 commitizen 目前並沒有提供不同版本表示方式的客製化 一律都會遵守 Semantic Version （語意化版本） 這種版本號採用 MAJOR.MINOR.PATCH (e.g., 1.10.20 ) 的格式 MAJOR ： 重大改動，不向後相容 MINOR ： 新增功能，必須向後相容 PATCH ： 修正功能，必須向後相容 以 commitizen 預設使用的 cz_conventional_commits 來說，相對應的 commit 種類和應該提升的版本號如下 MAJOR : BREAKING CHANGE (每次 commit 都會問的，這次是否為重大改動) MINOR : feat PATCH : fix, refactor, perf p.s. conventional commit 可以有很多種延伸，這裡指的只是 commitizen 採用的版本 每次提升版本號只會提升 1 ，而且以最前面的為主 e.g., 要 merge 回 master 的改動中出現 BREAKING CHANGE，不管其他有多少 feat 或 fix ，都只會讓 MAJOR 提升 1 目前只有 cz_conventional_commits 有預設的版本對應 如果為 cz_jira , cz_customize 或自己客製化規則加上提升版本的功能，可以參考commitizen 文件中 customization ，並加上 bump_pattern （比對 commit 是哪個種類） 和 bump_map （哪個種類的 commit 要提升哪個版本號） 稍微解釋了一下提升版本的規則，接下來要來講該如何使用了 cz bump 第一次提升版本的時候，會先確認目前在設定檔 (e.g., pyproject.toml ）中的版本是否已經有相對應的 git tag 如果沒有則會確認這是否是第一次為這個專案加上 git tag Tag v0.0.1 could not be found. Possible causes: - version in configuration is not the current version - tag_format is missing, check them using 'git tag --list' ? Is this the first tag created? (Y/n) 如果想跳過這個確認可以在後面加上參數 --yes cz bump --yes 接著 commitizen 就會新增一個相對應的 git tag 和更新設定檔中的版本號 因為要將設定檔中的改動儲存， commitizen 這時會再新增一個 commit (e.g., bump: version 0.0.1 → 0.0.2 ) 除了設定檔中的版本號外，有時候專案本身也有其他地方會使用到版本號 如果每次透過 commitizen 提升版本號後，還要手動更新其他部分，就失去了自動的好處了 所以 commitizen 另外提供了 version_files 這個設定，將需要改動的檔案也寫進來 commitizen 提升版本號時，就會一併更新檔案的內容 （Read More 👉 bump ） 透過 cz bump 指令雖然可以省下很多步驟 但更好的做法是將自動升版加入到加入到持續整合（Continuous Integration） 在 git repo 上將分支 merge 到 master 時，自動提升版本號 因為會牽涉到各個不同平台的做法，不會敘述太多 這裡附上 commitizen 文件中 Github Actions , Gitlab CI 還有 Jenkins Pipeline 的做法 客製化 commit 規範 目前 commitizen 提供兩種方式 直接在設定檔設定 → 適合只需要改動問題，不需要使用到複雜的功能 將 commit 規範寫成 Python 套件發佈 → 適合需要加入複雜的驗證 直接在設定檔設定 首先必須先將 name 指定到 cz_customize 這套 commit 規範 [tool.commitizen] name = \"cz_customize\" 再來要設定下面的欄位 其中最重要的是 message_template （支援 Jinja ） 以 \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\" 這個例子來說 需要 change_type , show_message , message 三個變數來產生 commit message （p.s. 如果想要使用驗證 commit message 的功能，則要更新 schema_pattern ） [tool.commitizen.customize] message_template = \"{{change_type}}:{% if show_message %} {{message}}{% endif %}\" example = \"feature: this feature enable customize through config file\" schema = \"<type>: <body>\" schema_pattern = \"(feature|bug fix):(\\\\s.*)\" bump_pattern = \"&#94;(break|new|fix|hotfix)\" bump_map = { \"break\" = \"MAJOR\" , \"new\" = \"MINOR\" , \"fix\" = \"PATCH\" , \"hotfix\" = \"PATCH\" } info_path = \"cz_customize_info.txt\" info = \"\"\" This is customized info \"\"\" 變數要在 [[tool.commitizen.customize.questions]] 的區段作定義 背後所使用的套件是 questionary name ： 必須跟前面 message_template 定義的一模一樣，而且裡面用到的變數都要有對應的問題能取得值 message ： 顯示給使用者的問題 type ： questionary 中的問題型態 其他欄位 (e.g., choice ) 則是靠 type 來決定是否需要 [[tool.commitizen.customize.questions]] type = \"list\" name = \"change_type\" choices = [ \"feature\" , \"bug fix\" ] message = \"Select the type of change you are committing\" [[tool.commitizen.customize.questions]] type = \"input\" name = \"message\" message = \"Body.\" [[tool.commitizen.customize.questions]] type = \"confirm\" name = \"show_message\" message = \"Do you want to add body message in commit?\" 設定完之後，再使用 cz commit 就可以看到客製化過後的問題了 將客製化的 commit 規範寫成 Python 套件發佈 這個做法比較複雜，也比較不常會用到，所以我只會概略地講 （Read More 👉 Customization ） 我已經先將套件的架構驟寫成一個 cookiecutter 範本 透過以下指令，可以進入 cookiecutter 的互動式介面，並初始化專案 cookiecutter gh:Lee-W/commitizen_cz_template 最主要需要實作的函式有 questions , message 實作完成後，必須在要使用這個 commit 規範的環境安裝這個套件 安裝之後會在 cz ls 看到這個新的 commit 規範 在設定檔中設定 name 或在指令列加上參數 -n name (e.g., cz -n cz_test commit ) 就可以開始使用 自動產生更新日誌（Changelog） commitizen 可以透過過往的 commit message 產生 keep a changelog 格式的更新日誌 透過以下指令，就能從最舊到最新的 commit message 產生更新日誌（預設是 CHANGELOG.md ） cz changelog 如果已經有現成的 CHANGELOG.md ， 則可以使用 cz changelog --incremental 指令 commitizen 會試著找出文件中最新釋出版本 (e.g., 1.0.5 ) 的位置，將最新釋出版本以後的 commit 加入到更新日誌的最頂端 例如目前有一個專案，最新的版本是 1.0.5，之後有 2 個 commit feat: cool new features ci: update jenkins file 原本的更新日誌 ## 1.0.5 ### Feat - old features 則 commitizen 在釋出 1.1.0 時，就會產生如下的更新日誌 ## 1.1.0 (2020-07-19) ### Feat - new cool new features ## 1.0.5 ### Feat - some old features 因為產生更新日誌，通常適合在升版後執行 在 cz bump 加上 --changelog 參數就可以提升版本的同時，產生更新日誌 其他 commitizen 指令和常用參數 cz bump ： 提升版本號 --dry-run ： 將提升版本號的訊息輸出到終端機，不會實際產生 tag 和改變檔案 --increment {MAJOR,MINOR,PATCH} ： 提升特定版本號 cz changelog : 產生更新日誌 --dry-run : 將產生的更新日誌書處到終端機，不產生或更新 CHANGELOG.md cz -n NAME [command] ： 使用不同的 commit 規則 （e.g., cz -n cz_jira commit ） cz version ： 顯示版本 -p （ --project ）： 顯示專案版本 -c （ --commitizen ）： 顯示 commitizen 版本（預設） 關於 commitizen 的雜談 我在 Taipei.py 第一次試講 Python Table Manners 時 有一頁就提到了，雖然 Python 也有 commitizen 這個工具，但還不太成熟 沒想到在 PyCon CA 的前一個禮拜我認真測試時 才發現其實 commitizen 已經很夠用了，該有的功能都有 只是我剛好都用一些奇怪的測試方式，測到一些 edge case 這時就覺得信奉 Python （？？？）的我，好像應該好好的介紹 Python 的工具 而不是 JavaScript 的 commitizen 於是我就在 PyCon CA 前一個禮拜，開始貢獻起 commitizen 把我遇到的 issues 都修了，就順便把投影片中相關的內容一起翻新了 貢獻的過程中也發現了很多還能再增加的新功能，於是就在 PyCon CA 2019 帶了這個專案去 Develop Sprint 第一次當 Sprint Leader 還蠻好玩的，也蠻有成就感的 （Read More 👉 PyCon CA 2019 ） 為什麼不用 Java Script 的 commitizen 就好了 因為我是 Python 的開發者啊！！！ 起初我也是從 JavaScript 的版本開始使用 （畢竟兩個專案 star 的數量差了一百倍） 原本我就有寫好 commit message 的習慣 能有工具幫助我把這件事做得更好，當然就再好不過了 用了一段時間後，我開始覺得我明明都已經認真寫好 commit message 了 為什麼每次 Pull Request / Merge Request 還是花那麼多時間寫 是不是有什麼工具可以自動透過寫好的 commit 產生一些訊息？ 再來就找到了 cz-conventional-changelog 但 cz-conventional-changelog 不能跟 cz-customizable 同時使用 （Read More 👉 Possible to use multiple adapters? #434 ） 而且這些擴充常常要用到 package.json 來做設定 可是我就不是 Java Script 的專案，就不想加入這個檔案來設定啊 🤷‍♂️ 所以才開始來找是不是有 Python 版本的替代方案 （Python 的 commitizen 支援的 toml （ .cz.toml ）是通用的格式，裡面 Python 相關的內容，適用於各語言） 持續貢獻 整體來說， commitizen 是一個讓我貢獻得很有成就感的專案 最主要的原因之一就是這是我想用的工具 貢獻的過程，也會很快就收到作者 Woile 的回饋 它也會用很友善的文字，讓我覺得貢獻 commitizen 所花的時間，是有受到重視的 除此之外， commitizen 測試覆蓋率很高，比較不需要怕改錯了會不會弄壞舊有的功能 程式碼風格上，透過 black 跟 flake8 來規範，讓程式碼閱讀起來輕鬆很多 在貢獻的過程中，也學到了不少很實用的工具（e.g., pre-commit, cookiecutter） 所以 一起來貢獻 commitizen 吧 💪 Reference how to create a good commit message How to Write Good Commit Messages: A Practical Git Guide Conventional Commit Semantic Version","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/03/python-table-manners-commitizen","loc":"https://wei-lee.me/posts/tech/2020/03/python-table-manners-commitizen"},{"title":"Python Table Manners - pre-commit: git commit 前做完檢查","text":"前一篇提到了透過 invoke 簡化繁瑣的指令 但人類除了是懶惰的，還是健忘的 即使已經更簡便了，沒被督促常常還是會忘了執行 就像這次的系列文，如果沒被寫作松督促，不知道什麼時候才會出現（笑 這篇來聊聊如何透過 pre-commit 強制做檢查 pre-commit pre-commit 讓我們能方便的加入 Git Hook ，並在各種 git 的相關操作前進行檢查 正如它的命名，它可以在進行 git commit 前執行一些操作 不過並不僅限於 commit 前，也可以在其它 git 的階段進行 之所以要這麼做就是為了讓不符合要求的程式碼，從最一開始就不會進入到版本庫 （pre commit）或 git 伺服器 （pre push） 使用 pre-commit 進行檢查 # 安裝 pre-commit pipenv install pre-commit --dev 設定 pre-commit hook 先透過設定檔 .pre-commit-config.yaml ，告訴 pre-commit 要做哪些檢查 需要注意的是，專案必須要是一個 git 專案 這些 git hook 都會被寫入 .git/hooks/ e.g., repos : - repo : https://github.com/pre-commit/pre-commit-hooks rev : v3.2.0 hooks : - id : end-of-file-fixer - id : trailing-whitespace args : [ --markdown-linebreak-ext=md ] 以上面的例子來說 repos 告訴 pre-commit 要去哪邊找到這些 hook repo : 去找專案 pre-commit-hooks rev : 在專案 pre-commit-hooks 找到 rev v2.3.0 hooks : 在 pre-commit-hooks rev v2.3.0 的 .pre-commit-hooks.yaml 中尋找指定的 hook id : hook id args : 執行這個 hook 的額外參數 pre-commit 整理了較為通用的 hook 在 pre-commit-hooks 除此之外，如 black 和 flake8 等工具也都有提供 pre-commit hook 另外， 建議 rev 不要使用 master，而應該使用版本號等明確的 rev 原因是預設 pre-commit 會在執行時將 hook 專案 clone 下來 如果沒有特別設定， pre-commit 不會把最新版 pull 下來 指到的 master 就會是第一次 pre-commit 抓到時的 master，不是最新版的 master 寫完設定檔後，接著就是把 pre-commit hook 安裝到 git 專案中 安裝 pre-commit 到專案中 # 將 pre-commit hook 安裝到 git 專案 pipenv run pre-commit install 需要注意的是每次重新 clone 之後，都必須要執行一次 雖然可以將 .pre-commit-config.yaml 加入版本控制 但 .git/hook/ 是不能被加入版本控制的 執行完會出現以下訊息 pre-commit installed at .git/hooks/pre-commit 第一次進行 git commit 時，會將 pre-commit-hooks clone 到 pre-commit 統一管理的地方 之後就會進行 Fix End of Files 跟 Trim Trailing Whitespace 的檢查 [ INFO ] Initializing environment for https://github.com/pre-commit/pre-commit-hooks. [ INFO ] Installing environment for https://github.com/pre-commit/pre-commit-hooks. [ INFO ] Once installed this environment will be reused. [ INFO ] This may take a few minutes... Fix End of Files.........................................................Passed Trim Trailing Whitespace.................................................Passed 如果沒有通過， git 會阻止你進行 commit pre-commit 每次都只會針對要 commit 的檔案做檢查 所以建議第一次將 pre-commit 引入專案時，可以先檢查所有的檔案 pipenv run pre-commit run --all-files 使用自定義的 pre-commit hook 下面的例子是在 commit 前，要進行 pytest 的檢查 repos : - repo : local hooks : - id : pytest name : pytest stages : [ commit ] language : system entry : pipenv run pytest pass_filenames : false types : [ python ] repo: local : 直接在本地資料夾執行 hooks : 有哪些 hook 要執行 id , name : hook 的 id / name 是 pytest stages : 在 commit 前執行 language : 直接使用系統執行 entry 內的指令 entry : 這個 hook 要執行的指令是 pipenv run pytest types : 只有在 python 這種檔案類型才進行檢查 pass_filenames : 是否要將 commit 的檔案名稱作為 entry 中指令的參數 其中 stages 總共有六種 commit merge-commit push prepare-commit-msg commit-msg manual 需要注意的是當執行 pipenv run pre-commit commit 時 預設只會寫入 .git/hooks/pre-commit 如果要加入其他階段，則必須要在後面加入參數 -t [hook-type] e.g., pipenv run pre-commit install -t pre-push 支援 6 種 hook-type pre-commit pre-merge-commit pre-push prepare-commit-msg commit-msg 像是 pytest 這種需要執行比較久的任務 我就不見得會在 commit 這個 stage 做檢查 而是會把 stages 改成 push 並安裝 pre-push 的 hook (i.e., pipenv run pre-commit install -t pre-push ) 如果不想要每個 hook 都各自做設定，可以在 .pre-commit-config.yaml 加上 default_stages default_stages : [ push ] 表示如果沒有特定指定 stages 的 hook 都只在 push 的階段做檢查 為自己的工具加上 pre-commit hook 為你寫的工具加上 pre-commit hook 可以讓人更方便使用你的工具 在工具專案中加入 .pre-commit-hooks.yaml 讓 pre-commit 知道其他人引入你的工具時要做什麼處理 撰寫的方式跟 local 的 repo 的寫法相似 repos : - repo : local hooks : - id : ... name : ... description : ... entry : ... Bouns: 可以只跳警告不擋下 commit 嗎？ 根據 Can I show warning message without blocking the commit? #923 提到的， pre-commit 認為這不是好的作法 但仍然可以透過對 entry 內指令的操作達到類似的效果 Reference 提升程式碼品質：使用 Pre-Commit (Git Hooks)","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-pre-commit","loc":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-pre-commit"},{"title":"Python Table Manners - 管理繁瑣任務","text":"前面幾篇從套件管理、虛擬環境、測試、風格檢查到自動排版，提到了很多的工具 每一個工具又有各自的參數和設定 這麼多指令怎麼可能記得起來 😱 所以在這篇要介紹如何用 invoke 管理這些指令 invoke 是什麼 invoke 是一套任務執行工具 (task execution tool)，主要用來是統一管理各種指令 有點像是 Python 的 Makefile 安裝 invoke 不同於 pytest, flake8 等套件，我會同時將 invoke 安裝在系統和虛擬環境中 # 安裝 invoke 到系統 pipx install invoke # 安裝 invoke 到虛擬環境中 pipenv install invoke --dev 裝在系統的原因是想把它當成類似 make 的指令來使用 在虛擬環境還需要裝的原因是，部署時系統通常不會預裝 invoke 如果想在部署時也能使用 invoke 的功能，最方便的方法透過 pipenv 安裝 如何使用 invoke 再回到 pycontw-postevent-report-generator 的例子 checkout 到 commit 83e4 ，回到使用 invoke 管理指令前 從當時的文件可以看到，還需要使用相對冗長的指令 到了 commit 72ad (實作已經在 commit bc98 完成，只是在 commit 72ad 才更新文件)，已經可以使用較短且較為統一的指令 (以 inv 作為開頭) 除此之外，引入 invoke 後，也不用每次都去翻文件 invoke --list 可以列出所有可用的指令 # 列出可用的 invoke 指令 # p.s. invoke 指令可以縮寫為 inv $ inv --list Available tasks: clean Remove all the tmp files in .gitignore develop Install script in pipenv environment in development mode init-dev Install development dependencies install Install script in pipenv environment test Run testcase 執行的方式則是在 invoke 後面直接加上任務名稱 e.g., inv clean 實作 invoke 任務 我們先試著將前面的 python setup.py develop 改成 invoke 的任務 預設 invoke 會去找目錄下的 tasks.py 所以第一步要先在專案最上層建立 tasks.py 接著撰寫一個函式叫 develop ，這就會是之後的任務名稱 (i.e., 透過 inv develop 執行) 在函式前加上裝飾器 (decorator) @task invoke 會傳入一個 context 做為第一個參數 (Read More 👉 what exactly is this ‘context' arg anyway? ) (p.s. 原本的程式碼中是使用 cmd ，那是錯誤的用法) 最後就可以用這個 context （參數 ctx ） 執行指令 from invoke import task @task def develop ( ctx ): ctx . run ( \"python setup.py develop\" ) 如同先前所提到的，操作都應該在虛擬環境內被完成 所以我將 pipenv run 的前綴提出來 這樣就能確保之後的操作一定都會在虛擬環境內執行 如果之後更換了管理虛擬環境的工具（e.g. poetry run ），也可以更輕易的改動 tasks.py from invoke import task PIPENV_PREFIX = \"pipenv run\" @task def develop ( ctx ): ctx . run ( f \" { PIPENV_PREFIX } python setup.py develop\" ) 任務相依 如果任務之間有相依性，可以在 @task 後加入 pre 或 post 表示任務執行前或後還要執行其他任務 e.g., 在初始環境 ( init ) 前，常會先清除不必要的檔案 ( clean ) from invoke import task @task def clean (): print ( \"clean up\" ) @task ( pre = [ clean ]) def init (): print ( \"initial\" ) 任務模組化 當任務便多時，為了方便維護，就會傾向將相似的任務模組化 這時候就可以使用到 namespace 的概念 (Read More 👉 Constructing namespaces ) 不過我不會在這篇文章深入探討要怎麼說 一般來說，除非任務真的非常多，這是不太必要的 如果有興趣看我怎麼把 pycontw-postevent-report-generator 的任務模組化 可以參考 commit f105 最後修改後 tasks 套件中有這些模組 ├── tasks │ ├── __init__.py │ ├── build.py │ ├── common.py │ ├── env.py │ ├── style.py │ └── test.py 和各個模組下的指令 $ inv --list Available tasks: secure Check package security build.clean Remove all the tmp files in .gitignore build.develop Install script in pipenv environment in development mode build.install Install script in pipenv environment build.test-cli Test whether the cli is runnable env.clean Remove virtual environment env.init Install production dependencies env.init-dev Install development dependencies style.flake8 Check style through flake8 style.mypy Check style through mypy style.pylint Check style through pylint style.reformat Reformat python files through black style.run ( style ) Check style through linter ( Note that pylint is not included ) test.cov Run test coverage check test.run ( test ) Run test cases 自動補完 （Auto-completion） 工程師是很懶惰的 這種指令列工具沒有自動補完怎麼行 invoke 當然也想到了 透過參數 --print-completion-script=[shell] 就能取得 invoke 預先寫好的自動補完腳步 目前支援 bash, zsh, fish 三種 shell e.g., 將 invoke 產生的 zsh 自動補完腳本寫入 ~/.zsh inv --print-completion-script = zsh >> ~/.zshrc 為什麼不用 Makefile 就好？ 因為有些 shell script 並不見得那麼好寫 （也可能只是我不熟...） e.g., from invoke import task PIPENV_PREFIX = \"pipenv run\" @task def clean ( cmd ): \"\"\"Remove all the tmp files in .gitignore\"\"\" files_to_remove = [] with open ( '.gitignore' ) as input_file : for line in input_file . readlines (): if not line . startswith ( '#' ): files_to_remove . append ( line . strip ()) cmd . run ( f \"rm -rf { ' ' . join ( files_to_remove ) } \" ) （雖然後來發現上面的一串，可以用 git clean -Xdf 取代...） 除此之外，invoke 也可以讓 shell script 的結果，直接跟 Python 互動 更容易實作出想要的功能 另外，推薦閱讀 Building a CLI for Firmware Projects using Invoke 其他進階應用 如何在任務加上參數？ 任務的函式後面加上除了 context 意外的參數 👉 Task parameters 為什麼用 invoke 的結果跟指令列上的執行結果不完全相同？ 在 run 函式中加上 pty=True 參數通常能解決，但建議可以看看 invoke 為什麼不將這設定為預設行為 👉 Why is my command behaving differently under Invoke versus being run by hand? 如何在任務執行失敗時，只做警告，不要跳錯 在 run 函式加上 warn=True (預設是 False ) 👉 invoke.runners.Runner.run Reference Break the Cycle: Three excellent Python tools to automate repetitive tasks - PyCon US 2019","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-manage-trivial-tasks","loc":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-manage-trivial-tasks"},{"title":"Python Table Manners - 程式碼風格","text":"接下來要介紹的是 linters 它們是用來檢查程式是否符合特定程式碼風格的一類工具 以 Python 來說，則可能是判斷有沒有遵守 PEP 8 linter 除了能檢查是否不符風格，通常也能用來檢查語法錯誤 風格檢查 - flake8 flake8 是 Python 最常被使用的 linter 之一 幾乎是所有 Python 開源專案的標準配備 使用 以下面這段程式碼為例 # bad_code.py import os os = \"My Operating system\" 這段程式碼出現了兩個問題 把模組 os 指派成一個字串，會導致無法使用 os 模組內的函式（因為 os 已經變成一個字串） os 的 = 後面加上兩個空白是不必要的，不符合 PEP 8 的規範 # 安裝 flake8 pipenv install flake8 --dev # 執行 flake8 pipenv run flake8 flake8 預設對當前目錄下所有 Python 的檔案做檢查 執行後， flake8 會將這些錯誤找出來 ./bad_code.py:4:1: F811 redefinition of unused 'os' from line 1 ./bad_code.py:4:5: E222 multiple spaces after operator 透過錯誤碼（e.g., F811 ）可以在 flake8 rules 找到為什麼這是個錯誤和怎麼修正比較好 設定 某些狀況下，我們會不完全依照 flake8 的風格 例如 PEP 8 的每行只能有 79 個字元，已經越來越不被使用 除了可以直接在 flake8 指令後面加上參數 也可以直接寫入設定檔 setup.cfg (或 .flake8 , tox.ini ） 以下是我所使用的設定 [flake8] ignore = # F632: use ==/!= to compare str, bytes, and int literals F632, # W503: Line break occurred before a binary operator W503, # E501: Line too long E501, # E203: Whitespace before ':' (for black) E203 exclude = .git, __pycache__, build, dist max-line-length = 88 ignore : 指定要忽略的錯誤類型（可以從 flake8 rules 找到這些錯誤碼） exclude : 不用被檢查的檔案 max-line-length : 每行最長長度（這裡設定的 88，是後面會介紹到的 black 的預設值） Read More 👉 Configuring Flake8 局部跳過檢查 另一種狀況是，我們只想在讓一兩行程式碼跳過 flake8 的檢查 但這份檔案的其他地方還是希望能被檢查 這時候可以在那行程式碼加上 # noqa: [error] e.g., example = lambda : 'example' # noqa: E731 風格檢查 - pylint pylint 同樣是相當常見的 Python linter 一般來說，比 flake8 檢查的更加嚴格 使用 與 flake8 不同， pylint 指令需要指定模組或套件名稱才能進行檢查 # 安裝 pylint pipenv install pylint --dev # 執行 pylint pipenv run pylint <package> ...... 設定 原本我建議使用 pipenv run pylint --generate-rcfile >> .pylintrc 來產生設定檔 但現在我更傾向在 pyproject.toml 中只寫入想要客製化的設定 原先的做法會在設定檔 .pylintrc 中有著大量的預設值，不容易找到哪些是修改過的設定，造成維護上的困難 不過需要注意的是在某些版本的 pylint 這個設定方式會出錯，所以建議安裝版本 2.6.0 以上的 pylint [tool.pylint] [tool.pylint.messages_control] disable = [ \"bad-continuation\" , \"missing-function-docstring\" , \"missing-module-docstring\" , \"invalid-name\" ] [tool.pylint.format] max-line-length = 88 其中 disable 的錯誤可以在 pylint-messages 找到 局部跳過檢查 只要在要忽略的程式碼前面一行加上 # pylint: disable=[error] 但需要注意的是，這行以後全部的檢查都會被關閉 所以要記得在需要開啟檢查的地方再加上 # pylint: enable=[error] # pylint: disable=line-too-long print ( \"Imagine this is a really long line!\" ) # pylint: enable=line-too-long flake8 v.s. pylint 除了相關的檢查外， pylint 會比 flake8 做更嚴格的檢查 也可以做更多的設定，但在執行上也會比較慢 在 PyCon US 2018 的 Automating Code Quality ，Kyle Knapp 很詳細的比較了這兩個工具 我的使用上會把 flake8 作為強制檢查程式碼風格的一環 只要沒有通過 flake8 的檢查，就應該做修正 而 pylint 的警告則是只作為參考 flake8 在大多數狀況已經足夠 花時間去修改成符合某些 pylint 過於嚴格的檢查，或設定 .pylint ，對我來說並不值得 而且 Guido 也是這麼說的 XD 型別檢查 - mypy mypy 是 Python 做靜態型別檢查的工具 Python 是一個動態型別的語言，所以可以隨意地不同型別的值指派給同一個變數 e.g., str_var = \"This is a string\" str_var = 1 但這麼做有時候會造成邏輯上的錯誤 例如 import csv 時，如果使用了 csv 作為其他的變數名稱 就會將變數的值取代掉原本引入的模組 除此之外，型別標記的程式碼也會增加可讀性 因此近幾年越來越多人注意 Python 的型別標記 PyCon US 2017 中 Lisa Guo 和 Hui Ding 的 Keynote Session Python@Instagram 講了 Instagram 是為什麼要和如何將龐大的程式庫加上型別標示 Static Typing in Python 則是 PyCon US 2020 年 Dustin 對型別標示和檢查的詳細介紹 而 Vita Smid 在 EuroPython 2019 的 Static typing: beyond the basics of def foo(x: int) -str: 則講到了型別檢查更進階一點的應用 這幾場演講都非常推薦可以觀看！ 使用 以下列的程式碼為例 # wrong_type_hint.py from typing import List def func ( val : List [ str ]): print ( val ) func ([ 1 , 2 , 3 ]) func 的參數 val 標記為 List[str] 但在呼叫的時候卻傳入整數陣列 # 安裝 mypy pipenv install --dev # 執行 mypy pipenv run mypy [ files ] --ignore-missing-imports 執行 mypy 後，它就會告訴跳出型別錯誤的警告 wrong_type_hint.py:8: error: List item 0 has incompatible type \"int\" ; expected \"str\" wrong_type_hint.py:8: error: List item 1 has incompatible type \"int\" ; expected \"str\" wrong_type_hint.py:8: error: List item 2 has incompatible type \"int\" ; expected \"str\" mypy 預設會去找所有引入的函式庫是否也有做好型別標記 所以一般使用上都會加上參數 --ignore-missing-imports 只要確保我們撰寫的部分都是正確的 設定 以下是我用來設定 mypy 的 setup.cfg [mypy] files = [your files] ignore_missing_imports = true 自動排版 - black 比起 flake8, pylint 只做風格檢查 black 會更進一步的直接修正不符合風格的程式碼 原本我不太喜歡使用這種的工具 原因是每次執行的結果不一定相同，修正的結果不見得符合我的需求，這時就要再去做設定 black 某種程度上的解決了這些問題 black 每次執行的結果都會是相同的，而且大致上修正結果我還算滿意 它最特別的地方是，不太能做客製化設定，也不能只做局部程式碼修正 引述自 black 的文件 The Black code style Black reformats entire files in place. It is not configurable. It doesn't take previous formatting into account. It doesn't reformat blocks that start with # fmt: off and end with # fmt: on. # fmt: on/off have to be on the same level of indentation. It also recognizes YAPF's block comments to the same effect, as a courtesy for straddling code. 為什麼這可能是件好事？ 因為這能讓大家更專注於程式碼的功能本身 而不是這裡要不要加逗號？要不要斷行？如何去調教設定檔？ \"There should be one-- and preferably only one --obvious way to do it.\" –The Zen of Python, by Tim Peters 使用 因為 black 還是 beta 版 透過 pipenv 安裝時還要加上 --pre 參數 # 安裝 black pipenv install black --dev --pre # 執行 black 修正程式碼風格 pipenv run black <package> 因為 black 是直接重新排版程式碼 我節錄了部分我在 pycontw-postevent-report-generator commit e64a 修正風格的結果 上面紅色的部分是原本的程式碼，下面綠色是修正過的結果 (p.s. 當時設定的長度是 119) 如果只想要檢查程式碼是否符合 black 的風格 而不要直接做修正，可以在指令後面加入 --check 參數 pipenv run black <package> --check 設定 雖然說 black 不能對風格做太多的設定 我們還是能先指定哪些檔案是要修正，哪些是不用的 以下是我放在 pyproject.toml 的設定 （p.s. line-length = 88 是 black 的預設值） [tool.black] line-length = 88 include = '\\.pyi?$' exclude = ''' /( \\.eggs | \\.git | \\.hg | \\.mypy_cache | \\.tox | \\.venv | _build | buck-out | build | dist )/ ''' 排序函式庫 - isort isort 是自動排列函式庫引入順序的的工具 PEP 8 建議將引入的函式庫分為三類做排序 標準函式庫 第三方函式庫 本地的函式庫 並在每一個種類間空一行 e.g., import os import flask import models 使用 isort 的原因跟 black 差不多 就是讓程式來決定比較枝微末節的事，專注在開發本身上面 執行 # 安裝 isort pipenv install isort --dev # 執行 isort 修正函式庫排序 pipenv run isort --atomic . --atomic : 只有重新排序後的結果沒有語法錯誤，才會儲存 設定 自從 5.0.0 後， isort 直接把常見的設定寫成 profile 只要指定 profile 就能直接套用相容的設定 [tool.isort] profile = \"black\" 不過有一個相關的 bug 到 5.0.5 後才修正 (Ref: Black profile not compatible with Black (ensure_newline_before_comments not working) #1295 ) 所以還是建議安裝最新的版本 其他工具 check-manifest : 檢查有沒有少放入 MAINIFEST.in 的檔案 seed-isort-config Bouns: 設定檔的選用 從前面的測試篇到現在有提到很多設定檔的格式 通常每個工具都會有自己的設定檔 (e.g., .coveragerc , .flake8 ) 或者用 Python 比較通用的格式 (e.g., pyproject.toml , setup.cfg ) 其中 pyproject.toml 是在 PEP 518 提出的設定檔格式 不過還沒有被所有的工具支援 awesome-pyproject 整理了目前已經支援或討論是否要支援 proproject.toml 的工具 比起讓多個工具的設定散落在各個設定檔 我傾向統一管理在 pyproject.toml 或 setup.cfg pyproject.toml black isort pylint coverage pytest commitizen (之後才會介紹到) setup.cfg flake8 mypy Reference Automating Code Quality - PyCon US 2018 Life Is Better Painted Black, or: How to Stop Worrying and Embrace Auto-Formatting - PyCon US 2019 Beyond PEP 8 -- Best practices for beautiful intelligible code - PyCon 2015","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-coding-style","loc":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-coding-style"},{"title":"Python Table Manners - 測試 (二)","text":"接續前一篇提到的 pytest ，繼續看它的其他功能吧 fixture fixture 幾乎可以說是 pytest 最重要的功能 前一篇的例子中只有用到準備資源的部分 這裡再舉一些例子來說明它的其他應用 準備 / 清除資源 假設我們已經有了虛構的 db 函式庫，它可以處理各種資料庫相關的功能 現在寫一個測試案例來驗證 is_connected 函式是否能正確的判斷資料庫有連線 import pytest from db import DB @pytest . fixture ( scope = \"function\" ) def db (): # 初始化 DB 的 instance _db = DB () # 連接到資料庫 _db . connect () yield _db # 斷開資料庫連線 _db . close () def test_db_is_connected ( db ): assert db . is_connected () is True fixture db 中不使用 return 而是使用 yield 連線資料庫後，就先將 _db instance 回傳 在 test_db_is_connected 引入 fixture db 時，資料庫會處於連線的狀態 結束後，則會執行 _db.close() 斷開資料庫的連線 （什麼時候才算結束則是看 fixture 的參數 scope ，這會在後面說明） 接下來我還想要說明兩個概念 fixture 中使用 fixture 用 fixture 準備跟清除資源，但不直接呼叫到資源 ( pytest.mark.usefixtures ) 現在假設已經實作了 model ，裡面有 User 的定義 我們想要驗證新增了一筆 admin 的使用者後，是否能成功查詢到這筆資料 import pytest from db import DB from model import User @pytest . fixture ( scope = \"function\" ) def db (): _db = DB () _db . connect () yield _db . close () ＠ pytest . fixtures ( scope = \"function\" ) def insert_admin_user ( db ): # 初始化 user user = User ( name = \"admin\" ) # 將 user 新增到資料庫 db . insert ( user ) yield # 將 user 從資料庫移除 db . delete ( user ) @pytest . mark . usefixtures ( \"insert_admin_user\" ) def test_admin_user_exists (): # 從資料庫中找出第一筆 name 是 admin 的 user admin_user = User . query . filter_by ( name = \"admin\" ) . first () assert admin_user is not None 新增資料前，必須先跟資料庫建立連線 因此準備資料的 fixture insert_admin_user 會使用到 db fixture 而測試函式 test_admin_user_exists ，需要已經有 admin 使用者的資料庫，來測試 User.query.filter(name=\"admin\").first() 是否能成功取得資料 但它不需要用到 insert_admin_user 這個變數，因此就能改成使用 pytest.mark.usefixtures 這樣就能在不引入參數的情況下，使用 fixture 設定好的環境 scope fixture 的 scope 共分為五種 （function, class, module, package, session） 表示 fixture 會在哪個階段前準備資源，並在哪個階段後清除 如果設定成 function，就會在每一個測試函式執行前和後做資源的處理 conftest.py conftest.py 是 pytest 中的一個特殊檔案 如果是整個套件（同一個資料夾）都會用到的 fixture 就能放在這， pytest 執行時會自動載入 以下面的結構為例， test_sponsor.py 就會自動載入上層的 conftest.py 中的 fixture └── tests ├── __init__.py ├── conftest.py ├── test_sponsor.py └── page ├── __init__.py ├── conftest.py └── test_title.py 常用的內建 fixture caplog : 抓 log 訊息 capsys : 抓 std out, std err tmpdir : 暫時資料夾，通常用來測檔案相關的測試 參數化 (parameterize) 在測試資料比較簡單的時候，可以使用 parameterize 來減少撰寫重複的程式碼 @pytest.mark.parametrize(args1, arg2) 第一個參數: 指定測試函式要使用的參數名稱 第二個參數: 測試資料的陣列 import pytest @pytest . mark . parametrize ( \"x, y, expected_sum\" , ( ( 1 , 1 , 2 ), ( 2 , 2 , 4 ), ( 3 , 3 , 6 ), ), ) def test_add ( x , y , expected_sum ): assert x + y == expected_sum marker 前面已經介紹過 parameterize 和 usefixtures 這裡會介紹 markers 還可以做什麼 內建 marker skip : 跳過這個測試案例 skipif : 如果符合某個條件，則跳過這個測試案例 xfail : 預期會失敗 （其實前一篇想跳過會失敗的案例應該要用 xfail ，而不是 skip ） 自定義 marker @pytest.mark.[any custom marker] 的用途是標記測試案例 像是如果有些測試會特別慢，就可以透過標記 @pytest.mark.slow from time import sleep @pytest . mark . slow def test_super_slow_test (): sleep ( 99999999999999 ) 執行時加上參數 -m 就能跳過（或只執行）這些案例 pipenv run pytest -m \"not slow\" 上面的做法，如果有測試案例不小心打成 @pytest.mark.slwo ，會不太容易被發現 但 pytest 還是會正常執行 這時候可以在專案加入設定檔 pyproject.toml (pytest 6.0.0 之後才支援這種設定檔格式) 定義 marker p.s. 不建議使用 setup.cfg 做為 pytest 的設定檔 (Read More 👉 deprecate setup.cfg support #3523 ) [tool.pytest.ini_options] minversion = \"6.0\" markers = [ \"slow\" ] 並在執行時加上 --strict-markers 參數 pipenv run pytest --strict-markers -m \"not slow\" pytest 就會告訴我們 slwo 並不是被定義過的 maker 更進一步可以把 --strict-markers 直接寫入 pyproject.toml [tool.pytest.ini_options] minversion = \"6.0\" addopts = \"--strict-markers\" markers = [ \"slow\" ] 測試例外事件 透過 pytest.raise 確認測試案例是否有符合預期的丟出例外事件 import pytest def test_index_error (): some_list = [] with pytest . raises ( IndexError ): print ( some_list [ 1 ]) pytest 常用命令列參數 -v ( -vv , -vvv ): 顯示更多資訊 （越多 v 就會顯示越多資訊） --durations=N : 只列出最慢的 N 個測試 -x ( --exitfirst ): 遇到第一個失敗就終止測試 --maxfail=num : 失敗次數達到 num 次，直接終止測試 --lf ( --last-failed ): 只測試上次失敗的案例 --ff ( --failed-first ): 從上次失敗的案例開始測試 --nf --new-first : 從新的案例開始測試 -k EXPRESSION : 只測試名稱符合 \"EXPRESSION\" 的案例 -m MARKEXPR : 只測試有 \"MARKEXPR\" maker 的案例 --fixtures : 列出所有 fixtures pytest-cov 測試覆蓋率 pytest-cov 可以用來產生測試覆蓋率的報告，讓我們知道程式碼還有哪些沒被測試到 # 安裝 pytest-cov pipenv install pytest-cov --dev e.g., # 計算 myproj 的覆蓋率 pipenv run pytest --cov = myproj tests/ 比較重要的參數有 --cov=[SOURCE] : 測試包含的程式碼範圍 --cov-report=TYPE : 測試覆蓋率報告的種類 (term, term-missing, annotate, html, xml) --cov-fail-under=MIN : 如果覆蓋率小於 MIN 則跳出 其中 --cov , --cov-report 都可以加入多個參數 回到 pycontw-postevent-report-generator 的例子 先 checkout 回 1.0.2 ，來測試 1.0.2 上的測試覆蓋率 pipenv run pytest --cov = report_generator --cov-report = term-missing test/ 從下面的結果可以看到哪些檔案的哪些部分沒有被測試到 如果想看精美的網頁版報告，可以試試看以下的指令 報告會產生在專案資料夾下的 htmlcov pipenv run pytest --cov = report_generator --cov-report = term-missing --cov-report = html 一些更進階的設定，可以寫入設定檔 pyproject.toml (或 .coveragerc ，但語法會不太一樣) 以下是我自己使用的 pyproject.toml [tool.coverage] [tool.coverage.report] show_missing = true exclude_lines = [ # Have to re-enable the standard pragma 'pragma: no cover' , # Don't complain about missing debug-only code: 'def __repr__' , 'if self\\.debug' , # Don't complain if tests don't hit defensive assertion code: 'raise AssertionError' , 'raise NotImplementedError' , # Don't complain if non-runnable code isn't run: 'if 0:' , 'if __name__ == .__main__.:' ] Read More 👉 Configuration reference 其他常用 plugins pytest-xdist 用平行化加速測試的執行 ( pipenv run pytest -n NUM ) pytest-mock 使用 mocking 的技巧將部分不好測試的物件替換成假的物件 推薦參考 Demystifying the Patch Function - PyCon US 2018 （不過她不是用 pytest） pytest-regressions 將冗長的測試結果寫成檔案，每次測試都去比對跟上次產生的結果是否相同 尋找其他 plugins pytest - Installing and Using plugins pytest-dev 其他測試工具 tox 在各種不同版本的 Python 中做測試，幾乎是開源 Python 專案的標準工具 nox 基本上跟 tox 的功能相似，不過組態設定是使用 Python tox 跟 nox 推薦參考 Break the Cycle: Three excellent Python tools to automate repetitive tasks - PyCon US 2019 hypothesis 採用 Property-based testing，跟以往要自己產生測試資料不同，我們只需要給予資料的定義（e.g., 0 ~ 10000 之間的整數）， hypothsis 會根據定義來產生隨機的資料，也因此更容易包含到極端案例 推薦參考 Escape from auto-manual testing with Hypothesis! （PyCon US 2019， Zac 投了 talk, sprint, tutorial, poster，很用心在推廣這套工具） Reference Python Testing with pytest 快快樂樂成為 Coding Ninja (by pytest) - PyCon APAC 2015 Pytest: Rapid Simple Testing - Swiss Python Summit 2016 Demystifying the Patch Function - PyCon US 2018 Escape from auto-manual testing with Hypothesis! Break the Cycle: Three excellent Python tools to automate repetitive tasks - PyCon US 2019","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-test-2","loc":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-test-2"},{"title":"Python Table Manners - 測試 (一)","text":"設定完環境後，接著開始要開發程式的各項功能 要驗證程式正確性時，我們就會撰寫測試案例 為什麼要寫自動化測試 如果沒有自動化測試 必須手動去驗證程式的正確性，而且不能確定每次的測試方式都是相同的 （如果因為很麻煩懶得測試，變成讓客戶去測試，就會造成更多的麻煩了 😱） 增加重構 (refactoring）的風險，因為很難驗證程式的功能有沒有在重構的過程中被改動 加入新的功能不知道會不會動到原本沒問題的功能 最後就會像是這樣 總之，要寫測試！ unittest unittest 是 Python 標準函式庫的測試框架 起源於 jUnit 的做法，所以在函式的命名上和設計上比較不符合 Python 風格 雖然它不會是今天的主角，我也不太建議使用它 不過我們還是可以稍微看一下它的用法 以下取自 unittest 文件中的其中一個範例 import unittest class WidgetTestCase ( unittest . TestCase ): def setUp ( self ): self . widget = Widget ( 'The widget' ) def test_default_widget_size ( self ): self . assertEqual ( self . widget . size (), ( 50 , 50 ), 'incorrect default size' ) def test_widget_resize ( self ): self . widget . resize ( 100 , 150 ) self . assertEqual ( self . widget . size (), ( 100 , 150 ), 'wrong size after resize' ) 可以看到幾個特點 測試案例必須要繼承 unittest.TestCase 使用 setUp 函式來初始化 widget （如果有需要清除資源則會使用 tearDown ） 使用 assertEqual 來做正確性的驗證 pytest pytest 是現在 Python 專案建議使用的測試框架，也會是這篇文章的主角 為什麼要用 pytest 更符合 Python 程式碼風格 (Pythonic) pytest 支援舊有的 unittest 風格 扁平化（不用繼承） 只需要使用 assert ，不需要去記 assert.+ (e.g., assertEqual ) 等 API 更好的 測試探索 (test discovery) 更多的進階功能 (e.g., fixture, mark, parameterize and etc.) 強大的套件 以下是取自 pytest - Create your first test 的範例 相比於 unittest 寫法相對簡潔 # content of test_sample.py def func ( x ): return x + 1 def test_answer (): assert func ( 3 ) == 5 從 Unittest 到 Pytest 前面的比較其實不太公平，unittest 的範例要測的內容本身就比 pytest 的複雜 所以接下來會用 pycontw-postevent-report-generator 為例子 討論如何從 v1.0 的 unittest 風格改成在 commit 83e4 的 pytest 風格 如果想跟著程式碼跑，可以把專案 clone 下來 （當然能貢獻專案就更棒了 XD） # clone 專案到本地 git clone https://github.com/pycontw/pycontw-postevent-report-generator cd pycontw-postevent-report-generator # 切換到 commit 83e4 的前一個 commit (因為commit 83e4 已經完成修正) git checkout 83e4~1 # 設定環境 pipenv install --dev 測試探索 (test discovery) 原本在 REAMDE.md 中要跑測試的指令相當的冗長 而且還必須要切換到 test 資料夾 (i.e., cd test ) cd test python -m unittest discover -s ./ -p 'test_*.py' 不過這其實是一開始的設計有誤 以下是 test 資料夾的內容 └── test … ├── test_sponsor.py └── test_title.py test (或 tests) 本身也必須是一個套件 所以必須先在 test 內加入 __init__.py （這是我在寫程式初期想開始寫測試遇到一個很大的坎 😢） └── test ├── __init__.py ... ├── test_sponsor.py └── test_title.py 做了改變後，就能改用更簡潔的指令跑測試了 python - m unittest 因為 pytest 也支援 unittest 風格 所以也可以直接使用 pytest 指令跑測試 pytest 不過在前一篇有提到使用虛擬環境的概念了 所以應該要確保每個專案的指令，都只在虛擬環境中跑 （因為前一篇建議使用 pipenv，之後的範例都會用 pipenv） # 將 pytest 安裝到開發環境 pipenv install pytest --dev # 執行 pytest pipenv run pytest 這時候的測試其實會有許多錯誤 但執行後應該要能看到類似的畫面 ===================== test session starts ====================== platform darwin -- Python 3.7.3, pytest-5.3.5, py-1.8.1, pluggy-0.13.1 rootdir: /....../pycontw-postevent-report-generator plugins: mock-2.0.0, cov-2.8.1 collected 9 items test/test_sponsor.py FFFFFFFF [ 88%] test/test_title.py F [100%] =========================== FAILURES =========================== ...... F 表示測試沒有通過，如果出現 . 則表示成功 Step 0: 追朔程式碼 以 test/test_sponsor.py::TestSponsor::test_sponsor_number 為例 （在套件以及模組的層級後， pytest 會使用 :: 來區別不同的層級，試試 pipenv run pytest -v 指令） 原本 unittest 風格的程式碼中，做了三件事 使用了 setUp 做 self.sponsors 的初始化 在 test_sonpsor_number 取用 setUp 中初始過的 self.sponsors 使用 self.assertEqual 來看 self.sponsors 的長度是否等於 1 import unittest from atta.partner import sponsor class TestSponsor ( unittest . TestCase ): def setUp ( self ): sponsors = sponsor . get_all_sponsors ( './data/packages.yaml' , './data/sponsors.yaml' ) self . sponsors = sponsors ...... def test_sponsor_number ( self ): self . assertEqual ( len ( self . sponsors ), 1 ) ....... Step 1: 使用 fixture 取代 setUp / tearDown 將 unittest.TestCase 移除，改用 pytest 的 fixture 取代 setUp fixture 跟 setUp / tearDown 的概念上相近，都是用來 準備 / 清除 資源 但 fixture 更加的輕量且更有彈性 在 test_sponsor_number 中加入參數 sponsors pytest 會去找 fixtures 中是否有 sponsors 並將之代入 接著將較為冗長的 assertEqual ，改為 assert import pytest from report_generator.partner import sponsor class TestSponsor : @pytest . fixture ( scope = \"class\" ) def sponsors ( self ): return sponsor . get_all_sponsors ( \"test/data/packages.yaml\" , \" test / data / sponsors . yaml \") ...... def test_sponsor_number ( self , sponsors ): assert len ( sponsors ) == 1 ...... (p.s. 在這裡 atta 已經重新命名為 report_generator ) Step 2: 使用 mark.skip 跳過部分測試 原本的測試中有些邏輯錯誤 但我只想先完成風格的轉換，還不打算修正 因此先使用了 markers 在想跳過的測試案例前面加上 @pytest.mark.skip import pytest from report_generator.partner import sponsor class TestSponsor : ... @pytest . mark . skip ( \"No bronze sponsor in test case\" ) def test_sponsor_promotion_web_click_rank_bronze ( self ): answer = sponsor . NA_CONTENT_MESSAGE self . assertEqual ( self . bronze_sponsor . web_click_rank , answer ) 執行 pipenv run pytest 後，就會發現有部分的測試案例變成了 s ========== test session starts ========== platform darwin -- Python 3.7.3, pytest-5.3.5, py-1.8.1, pluggy-0.13.1 rootdir: /....../pycontw-postevent-report-generator plugins: mock-2.0.0, cov-2.8.1 collected 9 items test/test_sponsor.py ....ssss [ 88%] test/test_title.py . [100%] Step 3: 扁平化 - 移除不必要的 class 從上面的範例可以看到， self 其實並不必要 這些測試案例不需要是一個類別 因此可以更近一步，把 TestSponsor 類別移除 import pytest from report_generator.partner import sponsor @pytest . fixture ( scope = \"function\" ) def sponsors (): return sponsor . get_all_sponsors ( \"test/data/packages.yaml\" , \"test/data/sponsors.yaml\" ) def test_sponsor_number ( sponsors ): assert len ( sponsors ) == 1 不過這並不代表用類別就是錯的 一般我會在模組內測試案例比較多的時候，使用類別來將相似的測試案例歸在同一類 因為篇幅的關係，我決定把測試分成兩篇文章 絕對不是因為我寫不完了 盡請期待明天更深入的 pytest 應用 😄 Reference Python Testing with pytest 非常推薦用這本書上手 pytest 快快樂樂成為 Coding Ninja (by pytest) - PyCon APAC 2015 Pytest: Rapid Simple Testing - Swiss Python Summit 2016","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-test-1","loc":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-test-1"},{"title":"Python Table Manners - 虛擬環境和套件管理","text":"開始 Python 專案時，第一步都是建立一個專屬於專案的虛擬環境 會需要這麼做是為了避免不同的 Python 專案需要使用到不同版本的套件 假設專案 A 需要 lib==2.3.5 而專案 B 需要 lib==1.0.0 如果 lib 都被安裝在本機中，就會有其中一個專案跑不起來 所以只要兩個專案都有建立虛擬環境，它們就都能在自己的虛擬環境中安裝所需的 lib 版本 理想上，本機的環境是不需要安裝套件的 因為每一個專案都會在個字的虛擬環境內執行，並安裝各自的套件 venv 建立虛擬環境，最基本作法是使用 venv 透過以下幾個指令建立，並把需要的套件寫入 requirements.txt # 建立 Python 虛擬環境到 ./venv python -m venv ./venv # 啟動 Python 虛擬環境 (for Unix like) source venv/bin/activate # 將虛擬環境用到的套件寫入 requirements.txt pip freeze >> requirements.txt p.s. 基本上這個系列文會以 Unix 系統（macOS, Linux）為主 但這個做法會遇到幾個問題 忘記開啟/關閉虛擬環境 忘記把新安裝的套件寫入 requirements.txt pip freeze 安裝一些不必要的套件 一開始我會使用 pipreqs 來解決 pip freeze 所造成的雜亂 但是忘記更新 requirements.txt 跟開關虛擬環境的問題還是存在 常常我在本地測試成功，push 到遠端的時候又告訴我少了套件 只好再送一個 Pull Request 修正...... pipenv pipenv 可以用來同時管理虛擬環境跟套件 pipenv 不使用 requriements.txt ，而是使用自定義的 Pipfile 跟 Pipfile.lock 管理套件 它的好處是能透過單一指令將套件安裝到虛擬環境中，並且更新到 Pipfile 以及 Pipfile.lock 安裝 pipenv 根據不同的系統，可以在 Installing Pipenv 找到安裝 pipenv 的方式 不過最簡單的做法還是透過 pip 安裝 python -m pip install --user pipenv 初始化環境 # 初始化虛擬環境 # 如果 Pipfile 跟 Pipfile.lock 還不存在，則會產生 pipenv install # 指定用特定版本的 Python 來產生虛擬環境 pipenv install --python 3 .6.4 # 移除虛擬環境 pipenv --rm # 列出虛擬環境的所在位置 pipenv --where 初始化虛擬環境後，會產生 Pipfile 跟 Pipfile.lock Pipfile 是 toml 格式的檔案 source : 指定要去找套件的倉儲，預設是 PyPI ，也可以再加上私有的 PyPI dev-package : 開發環境所需套件 packages : 預設安裝套件（通常是 Production 用） [[source]] name = \"pypi\" url = \"https://pypi.org/simple\" verify_ssl = true [dev-packages] [packages] [requires] python_version = \"3.7\" Pipfile.lock 是 JSON 格式的檔案 同樣是記錄安裝的套件，但會同時記錄下套件相依的其他套件（假設安裝了 requests 套件，而 requests 相依於 urllib3 ，則 requests 跟 urllibs 都會列在這） { \"_meta\" : { \"hash\" : { \"sha256\" : \"...\" }, \"pipfile-spec\" : 6 , \"requires\" : { \"python_version\" : \"3.7\" }, \"sources\" : [ { \"name\" : \"pypi\" , \"url\" : \"https://pypi.org/simple\" , \"verify_ssl\" : true } ] }, \"default\" : {}, \"develop\" : {} } 通常沒有什麼特別的理由，可以不用動到 Pipfile 跟 Pipfile.lock 交給 pipenv 管理就好 安裝套件 pipenv 的另一個好處是，它的 API 基本上跟 pip 是一樣的 # 安裝套件 pipenv install <package> == <version> # 解除安裝套件 pipenv uninstall <package> # 更新套件 pipenv update <package> 以安裝 requests 為例 會更新在 Pipfile 的 packages 區段 [packages] requests = \"*\" Pipfile.lock 中除了 requests 外，還會列出 requests 的相依套件 urllib3 (Ref: setup.py#L47 ) { ...... \"default\" : { ...... \"requests\" : { \"hashes\" : [ \"sha256:11e007a8a2aa0323f5a921e9e6a2d7e4e67d9877e85773fba9ba6419025cbeb4\" , \"sha256:9cf5292fcd0f598c671cfc1e0d7d1a7f13bb8085e9a590f48c010551dc6c4b31\" ], \"index\" : \"pypi\" , \"version\" : \"==2.22.0\" }, \"urllib3\" : { \"hashes\" : [ \"sha256:3de946ffbed6e6746608990594d08faac602528ac7015ac28d33cee6a45b7398\" , \"sha256:9a107b99a5393caf59c7aa3c1249c16e6879447533d0887f4336dde834c7be86\" ], \"version\" : \"==1.25.6\" } }, ...... } 可以注意到每個安裝的套件會有三個欄位 index , version 和 hashes index : 套件從哪裡裝的 version : 安裝的版本 hashes : 下載這個套件時產生的雜湊值 (hashing) 只要套件內容有改變，就會產生不同的雜湊值 可以用於驗證下次安裝時，這個套件的內容是否跟這次相同 有些套件雖然改了內容，但沒有更新版本號 雜湊值可以用來避免使用者在沒注意到的情況下安裝了不同的套件 下面兩個指令就會運用到 hashes # 安裝時同時確認 Pipfile.lock ，如果 lock 檔跟實際安裝的有衝突，則會取消安裝 pipenv install --deploy # 直接使用 Pipfile.lock 安裝套件 pipenv install --ignore-pipfile 安裝開發環境套件 有些套件（e.g., 測試工具）不需要在 Production 的環境上安裝 以往會將不同的套件用不同的 requirements.txt 來管理 (e.g., requirments/dev.txt , requirements/prod.txt ) pipenv 則是將開發環境才需要的套件寫在 Pipfile 的 dev-packages 內 只要在安裝時後面加上選項 --dev e.g., # 安裝開發環境套件 pipenv install <package> == <version> --dev 在虛擬環境中執行指令 # 在虛擬環境中執行 [command] pipenv run <command> # e.g., pipenv run python your_program.py 雖然可以透過 pipenv shell 進入到虛擬環境，但我不太建議使用 原因是我常常會進入虛擬環境後，亂下 pip install <package> 的指令 然後就沒被 Pipfile 給記錄到... 其他功能 pipenv check : 檢查安裝的套件是否有已知的安全性問題 pipenv graph : 檢視整個相依套件的相依圖 pipenv open <package> : 開啟安裝的套件（不知道什麼時候養成了「懶得看文件，直接 trace code」的習慣...） Poetry poetry 是目前很多人說可以取代 pipenv 的工具 除了 pipenv 包含的功能外，它還能用來初始化專案、上傳套件 pipenv 被抱怨的原因 之前有相隔快兩年沒有新的版本釋出（2020 年倒是更新了幾次） lock 太慢 不會自動跟 setup.py 中的 install_rquires poetry 使用下來體驗還算不錯 而且它採用 pyproject.toml 來做配置設定，這點我就蠻喜歡的 我會建議如果要寫 Python 函式庫的話，可以使用 poetry 至於 Python 應用，使用 pipenv 還是 poetry 就看個人的喜好了 基本使用 # 初始化 poetry 專案 poetry init # 安裝套件 poetry install # 加入新的套件 poetry add <package> # 移除套件 poetry remove <package> 其他工具 pip-tools pip-tools 主要的功能是產生 hashes ，並不能用來管理虛擬環境 這套工具比較適合習慣使用 pip 跟 virtualenv ，但又想要有 Pipfile.lock 的功能的情況 dephell dephell 是個 all-in-one 的工具 當初看到覺得很有趣，但還沒有時間好好研究 目前使用到對我最有幫助的功能是它能在轉換不同的格式 (e.g., Pipfile → pyproject.toml) 自動偵測套件版本並適當升級的服務 pyup.io dependabot Bouns: pipx - 在系統安裝 Python 工具 雖然建議 Python 的套件都裝在虛擬環境，但如果平時要使用的工具 (e.g., invoke , awscli ) 都裝在虛擬環境 每次使用這些工具都得進入虛擬環境就太麻煩了 pipx 會為每個工具創建一個專屬的虛擬環境，並且設定好 PATH 安裝 pipx，並設定 PATH python -m pip install --user pipx python -m pipx ensurepath 安裝工具 pipx install [ package ] Reference 這樣的開發環境沒問題嗎？ - PyCon TW 2018 Pipenv: The Future of Python Dependency Management - PyCon US 2018 Python Dependency Management - PyCon DE 2018","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-dependency-mangement","loc":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-dependency-mangement"},{"title":"Python Table Manners 系列","text":"Python Table Manners - A Clean Style 是我在 PyCon CA 2019 給的一個分享 內容是介紹在開發 Python 專案時能用的工具們，並且把它們串成一個工作流 希望能讓剛接觸 Python 的朋友們，能在早期就碰到這些好用的工具，少踩一些雷 原本打算找個時間把這些內容整理成文章 但在沒人督促的情況下，當然就忘了 XD 剛好看到 連續七天寫作挑戰，解放你的技術創作力 就給個理由來督促一下自己 除了在 PyCon CA 分享中提到的內容外，還會多整理一些在貢獻 commitizen 學到的工具 目前預計會包含以下的內容 虛擬環境和套件管理 測試（ㄧ） / 測試（二） 程式碼風格 管理繁瑣任務 pre-commit: git commit 前做完檢查 Commitizen: 規格化 commit message 安全性檢查 文件 持續整合/部署 Cookiecutter 程式專案模板 當初整理 PyCon CA 2019 投影片的時候，大多是把這些工具應用到 pycontw-postevent-report-generator 這是 PyCon TW 用來自動產生會後分析報表的工具，歡迎一起來貢獻～ 當然能一起來當志工就更棒了 🎉 👉 PyCon Taiwan 志工招募 參考資料 有些文章會同時涵括多過我想提的主題，我會把那些參考資料放在這 如果是我聽過的 PyCon 演講，我會連結到我自己的 PyCon Note ，裡面會有該場演講的相關資訊和我的筆記 Understanding best-practice Python tooling by comparing popular project templates 這篇文章整理和比較了 18 個比較有名的 Python 專案模板 How to set up a perfect Python project 這篇文章整理上面那篇文章很推薦其中一個模板 My Python Development Environment, 2020 Edition Modern development environments for Pythonistas - PyCon JP 2019","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-series","loc":"https://wei-lee.me/posts/tech/2020/02/python-table-manners-series"},{"title":"pipenv 和 poerty 如何處理在不同作業系統下相依套件不同","text":"遇到的問題 用 twine 上傳 Python 套件 在 mac 的本地端測試有成功，但丟上 CI 跑在 Ubuntu 的 image 內會缺少 jeepney 套件 問題的根源 目前最新版 (3.1.1) 的 twine 相依於套件 keyring ( setup.cfg#L44 ) 而 keyring 在不同的作業系統中，相依的套件是不同的 ( setup.cfg#L30 ) install_requires = pywin32-ctypes ! = 0.1.0 , ! = 0.1.1 ; sys_platform == \"win32\" SecretStorage > = 3 ; sys_platform == \"linux\" jeepney > = 0.4.2 ; sys_platform == \"linux\" importlib_metadata ; python_version < \"3.8\" 我缺少的的確就是那幾個 sys_platform==\"linux\" 的套件 pipenv 怎麼處理 基本上 pipenv 不算有解決這個問題， pipenv 只會將目前系統的所需套件寫進 Pipfile.lock 以 twine 為例，在 macOS 透過 pipenv 安裝 ，跑 pipenv graph 指令 就會發現 keyring 只會直接相依於 importlib-metadata - keyring [required: >=15.1, installed: 21.1.0] - importlib-metadata [required: Any, installed: 1.5.0] - zipp [required: >=0.5, installed: 2.2.0] 但換到 Ubuntu 上跑，就會多了 SecretStorage 跟 jeepney - keyring [required: >=15.1, installed: 21.1.0] - importlib-metadata [required: Any, installed: 1.5.0] - zipp [required: >=0.5, installed: 2.2.0] - jeepney [required: >=0.4.2, installed: 0.4.2] - SecretStorage [required: >=3, installed: 3.1.2] - cryptography [required: Any, installed: 2.8] - cffi [required: >=1.8,!=1.11.3, installed: 1.14.0] - pycparser [required: Any, installed: 2.19] - six [required: >=1.4.1, installed: 1.14.0] - jeepney [required: >=0.4.2, installed: 0.4.2] 這個問題也有其他人提過 ( Cross-platform Pipenv.lock? #3902 ) pipenv 貢獻者給的建議是使用 pipenv install --keep-outdated 但這個指令的說明是 Keep out-dated dependencies from being updated in Pipfile.lock. 總覺得好像不是在這個 use case 下使用的 最後我的解決方案是是把那幾個平台相依的套件安裝進去 原因是在 production 的環境就是需要這幾個多安裝的套件，我在 local 多裝幾個套件好像也沒什麼差 但如果今天是相反的狀況，我可能就會傾向 local 跑在 docker 裡 Poetry 怎麼處理 poerty 對這個問題則是有比較好的解法 透過 poetry 安裝 twine 後 產生的 poetry.lock 會把 marker = \"sys_platform == \\\"linux\\\"\" 記錄下來 實際 poetry shell 進去看，的確也沒多安裝這些套件 [[package]] category = \"main\" description = \"Store and access your passwords safely.\" name = \"keyring\" optional = false python-versions = \">=3.6\" version = \"21.1.0\" [package.dependencies] SecretStorage = \">=3\" jeepney = \">=0.4.2\" pywin32-ctypes = \"<0.1.0 || >0.1.0,<0.1.1 || >0.1.1\" ...... [[package]] category = \"main\" description = \"Python bindings to FreeDesktop.org Secret Service API\" marker = \"sys_platform == \\\"linux\\\"\" name = \"secretstorage\" optional = false python-versions = \">=3.5\" version = \"3.1.2\" 總結 poetry 在處理不同平台相依套件不同的狀況，處理得比較好 它會把所有需要的資訊記錄下來，在不同的平台進行不同的安裝 如果要用 pipenv 則可以使用 pipenv install --keep-outdated 或者就直接多安裝這幾個不是每個平台都需要的套件","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/02/how-pipenv-and-poetry-stores-if-dependencies-platform-dependent","loc":"https://wei-lee.me/posts/tech/2020/02/how-pipenv-and-poetry-stores-if-dependencies-platform-dependent"},{"title":"透過 GitHub Action 自動發佈 Pelican 部落格文章","text":"最近因為在貢獻 commitizen ，開始碰到 GitHub Action （ Python 也有自己的 commitizen 了！！！） 記錄一下怎麼應用到發布部落格文章 Before GitHub Action 要發佈一個新文章，我會做兩件事 1. 將原始碼推到 GitHub 上 2. 透過原始碼產生靜態頁面，並且推到 gh-pages 這個分支上 只有第二步是必要的，但也沒不把原始碼推上去的理由 Pelican 初始化部落格時會產生 Makefile 和給 invoke 用的 tasks.py 裡面會包好如 build, publish 等常見指令 預設會透過 ghp-import 推到 GitHub Page Working on GitHub Action 將我原本做的事整理成 GitHub Action 該做的事，就會變成這樣 1. Check out : Check Out 到這個分支 2. Set up Python : 設定 Python 環境 3. Install dependencies : 安裝 Pelican 和相關套件 4. Build and Deploy : 產生原始碼推上去 --- name : publish post on : push : branches : - content jobs : publish : runs-on : ubuntu-latest steps : - name : Check out uses : actions/checkout@v2 - name : Set up Python uses : actions/setup-python@v1 with : python-version : '3.7' - name : Install dependencies run : | python -m pip install pipenv pipenv --version pipenv install - name : Build and Deploy run : | pipenv run inv github 這份設定檔要放在專案目錄的 .github/workflows/ 下 至於要命名成什麼都可以 另外建議使用 yamllint 來檢查 yaml 語法 我遇過太多次縮排造成的錯誤了 這份設定檔大致上算直觀 name: 這個 workflow 的名稱 on: 在什麼情況下才要執行這個 workflow jobs: 要執行哪些任務，目前我只執行 publish 這件事，下面的 step 則是描述我前面說要做的事 這麼做之後，我遇到了兩個問題: submodule 跟 ghp-import 我的部落格把主題跟套件都分出去各自成一個專案 所以要建立部落格必須要把每一個 submodule 都一併 clone 下來 所幸原本 GitHub Action 就有提供 (Ref: Check-out-submodule ) 加上下面這段就解決了 - name : Checkout submodules shell : bash run : | auth_header=\"$(git config --local --get http.https://github.com/.extraheader)\" git submodule sync --recursive git -c \"http.extraheader=$auth_header\" -c protocol.version=2 submodule update --init --force --recursive --depth=1 ghp-import 的問題則是，我沒有在上面的環境設定我的 git 資訊 他沒有權限推到 gh-pages 也可以透過把 URL 改成 https://${GITHUB_ACTOR}:${GITHUB_TOKEN}@github.com/${repo_name} 來解決 但我實在不太想再多去設定一些 credential 最後找到了 actions-gh-page 只要把靜態網頁在 GitHub 上 build 出來，再把結果透過這個 action 推到 gh-pages 即可 這樣我就只需要設定 {{ secrets.PERSONAL_ACCESS_TOKEN}} 這個我在其他 GitHub Action 也都用得到的 token - name : Deploy uses : peaceiris/actions-gh-pages@v2 env : PERSONAL_TOKEN : ${{ secrets.PERSONAL_ACCESS_TOKEN }} PUBLISH_BRANCH : master PUBLISH_DIR : ./output 另外，最近 GitHub 終於提供可以 rerun 的選項了 原本失敗的時候還必須要 git reset 來強制 GitHub 重新執行 Action After GitHub Action 下面就是我最後的 .github/workflows/publish.yaml --- name : publish post on : push : branches : - content jobs : publish : runs-on : ubuntu-latest steps : - name : Check out uses : actions/checkout@v2 - name : Checkout submodules shell : bash run : | auth_header=\"$(git config --local --get http.https://github.com/.extraheader)\" git submodule sync --recursive git -c \"http.extraheader=$auth_header\" -c protocol.version=2 submodule update --init --force --recursive --depth=1 - name : Set up Python uses : actions/setup-python@v1 with : python-version : '3.7' - name : Install dependencies run : | python -m pip install pipenv pipenv --version pipenv install - name : Build run : | pipenv run inv publish - name : Deploy uses : peaceiris/actions-gh-pages@v2 env : PERSONAL_TOKEN : ${{ secrets.PERSONAL_ACCESS_TOKEN }} PUBLISH_BRANCH : master PUBLISH_DIR : ./output","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/01/automate-publish-pelican-through-github-action","loc":"https://wei-lee.me/posts/tech/2020/01/automate-publish-pelican-through-github-action"},{"title":"EDBT-ICDT 2018","text":"整理筆記時，翻到兩年前去研討會的筆記 想說放著也不會增值，就整理出來了 雖然大部分的內容的印象都已經有點模糊了 不過就加減把當初的筆記湊起來 當時我覺得最有趣的論文是 Interactive Rule Refinement for Fraud Detection. 不過竟然沒有做到太多筆記 Day 1 - Keynote In theoretical CS Polynomial time → easy/fast However, that's not always the case e.g., \\(O(n&#94;{100})\\) When n grows, even \\(O(n&#94;2)\\) is not efficient We're stuck on many problems even just in \\(O(n&#94;2)\\) No \\(N&#94;{2-\\epsilon}\\) time algorithms known for String matching computational geometry graph problem in sparse graphs many problems from database many other problems Why are we stuck? The traditional hardness in complexity tells us little about runtime fine-grained hardness idea identify key hard problem ...... Large Scale Machine Learning: Where Do Relational Systems Fit In? (by Chris Jermaine) Currently, ML community cares about new models instead of theory and fundamental ML design ML vs AI ML is one approach to AI Classic AI: a programmer/expert imparting knowledge to a system ML is fundamentally statistical Intro to ML Distributed ML Most ML systems use a \"parameter server\" model Essentially a distributed key-value pair Negatives Parameter server compute model very limiting Data Parallel ML Each compute server runs same computation on different data Global state updated via aggregation Want to scale out to speed up learning? scale out ineffective in data parallel param server no easy way to add machines and have a graph execute faster Only easy way to scale out is to add compute servers Take-Home Point Current ML systems are easily applicable only to Relatively small model problems That is run on a single machine Detecting Database File Tampering through Page Carving Attack Vector: File Tampering Occurs at the OS level → outside DBMS control Bypass DBMS control Page Deconstruction Page Header Checksum PageID Row Count DBStorageAuditor Goal: find inconsistency in storage which is created by direct file manipulation Extracting Statistical Graph Features for Accurate and Efficient Time Series Classification Time series: Any data that is ordered Time Series Classification similarity-based kNN (e.g., kNN-ED, kNN-DTW) similarity can be unreliable Shaplets high computation complexity Why multiscale sometimes global features are more important while sometimes local features are more important in this research, both global and local are considered Visibility Graphs Multiscale Visibility Graphs","tags":"Tech","url":"https://wei-lee.me/posts/tech/2020/01/edbt-icdt-2018","loc":"https://wei-lee.me/posts/tech/2020/01/edbt-icdt-2018"},{"title":"[Book] 原子習慣","text":"終於把之前很多人在討論的這本書看完了 也許是太久沒看書了，看書的速度下降了很多 上一次好好看完一本書竟然是九月初的事了＠＠ 整體來說，這本書在講的跟 為什麼我們這樣生活，那樣工作 ? 差不多 但文字上淺顯易懂了很多 「習慣的四階段模型」 提示 渴望 回應 獎賞 基本原理 - 為何細微改變會帶來巨大差距 1. 原子習慣的驚人力量 造就成功的，是日常習慣，而不是千載難逢的轉變 如果花太多時間思考目標，卻花太少時間設計系統，會遇到這些問題 贏家跟輸家擁有同樣的目標 目標達成不過是短暫的改變 目標的達成只能暫時改變你的生活 結果並非問題所在，應該改變的是造成那些結果的系統 目標限制了你的快樂 目標與長期進步互相矛盾 設定目標的目的是贏得比賽，建立系統的目的則是持續待在比賽裡 在跨越關鍵門檻之前，小改變往往看似無足輕重。所有複利過程的強大成果總是遲來，你要有耐性 2. 改變習慣最有效的方法，是改變身份認同 改變的發生分成三個層次 結果 過程 身分認同 改變信念： 世界觀、你的自我形象、你對自己與他人的評價 在成為自我身分的一部分之前，改善都只是暫時的 目標不是讀一本書，而是成為讀書的人 目標不是跑一趟馬拉松，而是成為跑步的人 你之所以相信你現在的身份認同是因為你有證據 假如你每週日都上教堂，你就有證據證明自己是個虔誠的人 新的身分認同需要新的證據 決定你想要成為什麼樣的人 透過生活中的小勝利來向自己證明 3. 四個簡單的步驟，讓你建立更好的習慣 習慣可以讓你騰出自由思考與創意所需的心理空間 每當你想要改變一個行為 我要怎麼讓提示顯而易見？ 我要怎麼讓習慣有吸引力？ 我要怎麼讓行動輕而易舉？ 我要怎麼讓獎賞令人滿足？ 法則 1 - 讓提示顯而易見 4. 行為改變的過程始於察覺 習慣記分卡 Why 幫助你覺察自身習慣 行為愈是自動化，愈難有意識地想到它，也愈容易出錯 個人生活中，也需要 指差確認 系統 How 列出每日習慣的清單 「這是好習慣、壞習慣，或是不好不壞的習慣？」 好習慣: 標上正號（＋） 壞習慣: 標上負號（－） 不好不壞: 標上等號（＝） 如何判斷好習慣還壞習慣 → 「這個習慣能幫助我成為我想要成為的那種人嗎？對於我渴望的身分認同，這個習慣投的是同意票或反對票？」 目標只是要注意到實際發生的行為，請 不帶評價或批判地觀察自己的想法與行動 改變惡習的第一步，就是密切注意它們 如果覺得需要額外的協助，可以嘗試在生活中執行指差確認， 大聲說出你打算做的事，以及可能的結果 5. 開始一個新習慣最好的方法 執行意向: 我會於〔時間〕，在〔地點〕進行〔行為〕 對何時何地執行一項新習慣做出確切計畫的人，比較可能真的去執行 確切知道自己想要什麼、如何達成目標，可以幫助你拒絕干擾你前進、令你分心、讓你脫離軌道的事物 習慣堆疊: 「做完〔目前的習慣〕之後，我會執行〔新的習慣〕。」 先找出自己目前的每日習慣，然後把新的行為堆疊上去 修正習慣堆疊，讓時間點明確： e.g., 「午餐休息時，我會做十下伏地挺身。」 → 「當我闔上筆電、準備去吃午餐時，我會在書桌旁做十下伏地挺身。」 6. 激勵被高估了，環境往往更重要 情境是觸發習慣的提示 比起在相互牴觸的提示中建立新習慣，把新習慣跟一個全新的情境連結在一起比較容易 如果你每晚都在臥室看電視，想要早點就寢可能很難 如果客廳是你打電動的地方，想要在那裡專心讀書可能很難 步出平常的環境，你就把那些行為偏誤拋在腦後了。你不必對抗舊環境裡的提示，新習慣的形成也就不受干擾了 一個空間，一個用途: 倘若無法移動到全新的環境，就重新定義或重新整理當前的環境，為工作、讀書、運動、娛樂與烹飪區隔出不同的空間 盡量避免把一個習慣的情境跟另一個習慣的情境混在一起 當情境混合，習慣也會開始混合在一起 到頭來，獲勝的通常是比較輕鬆的 法則 2 - 讓習慣有吸引力 7. 自制力的祕密 所謂「自律者」只是擅長建構生活，好讓自己不需要展現超凡的意志力與自我控制力 → 不常讓自己處於充滿誘惑的情境 可以破除一項習慣，但不太可能忘掉它 習慣的心理紋路一旦被刻進大腦，幾乎不可能完全移除 → 抗拒誘惑是無效策略 短期內，你可以用意志力壓過誘惑；長久下來，我們終歸是所處環境的產物 要剷除一項壞習慣，最實用的方法之一就是 減少接觸會激發此惡習的提示 8. 如何讓習慣變得難以抗拒 習慣堆疊加誘惑綑綁 做完〔目前的習慣〕之後，我會執行〔我需要的習慣〕 做完〔我需要的習慣〕之後，我會執行〔我想要的習慣〕 ９ 家人與朋友如何形塑你的習慣 要打造更好的習慣，最有效的方法之一就是加入一個把你想要的行為視作常態的文化之中。當你看到其他人每天都在做，新習慣便顯得可行 沒有任何事物比「屬於某一族群」的感覺更能支撐動機，這種歸屬感把個人的追求轉化為共同的追求 加入的文化應該具備兩個特點 你想要的行為是常態 你跟這個群體本來就有某些共同點 10 如何找出並解決壞習慣的成因 目前的習慣不見得是解決問題的最佳手段，而只是你學會使用的手段 某個人也許學會用抽菸來抒解壓力，另一個人則學會用跑步來減低焦慮 與正面感受產生連結之後，習慣就有了吸引力 動機儀式: 練習把習慣與你很享受的某件事物聯想在一起，往後每當需要一點動機時，就可以把這個提示拿出來用 法則 3 - 讓行動輕而易舉 11. 精通習慣由重複開始，而非完美 想要精通一項習慣， 關鍵是由重複開始，而非完美 你不必詳細列出新習慣的所有特徵，只要開始實行就好了 12. 最小努力原則 讓習慣簡單到就算沒有意願也會執行 創造出一個讓正確的事情盡可能輕而易舉的環境 讓好習慣更加方便，你就更有可能貫徹 為了以後方便，把環境準備好 13. 如何運用「兩分鐘法則」停止拖延 兩分鐘法則：新習慣的開始應該要花不到兩分鐘 幾乎每個習慣都可以縮減為兩分鐘版本： 「每晚就寢前閱讀」變成「讀一頁」 「做三十分鐘瑜伽」變成「拿出瑜伽墊」 「用功讀書」變成「翻開筆記」 在覺得費力之前停止 14. 如何讓好習慣變得無可避免，讓壞習慣不可能發生 讓違背好習慣比開始執行好習慣更花力氣 e.g., 報名瑜伽課程並提前付款 買一個插座定時器，裝在電源和路由器中間，每天晚上十點，這個定時器會切斷路由器的電源；當網路斷線，就知道上床時間到了 法則 4 - 讓獎賞令人滿足 15. 行為改變的基本原則 行為改變的基本原則： 帶來獎賞的行為會被重複，帶來懲罰的行為會被避免 正面情緒培養習慣，負面情緒摧毀習慣 不是任何一種滿足都好， 我們追求的是立即的滿足 立即獎賞與延遲獎賞之間的不一致 壞習慣的後果被延遲，其獎賞卻是立即的 如何把「立即滿足」變得對你有利 本來就沒有行動時，很難讓人感到滿足。你所做的只是抵抗誘惑，這沒什麼好令人滿足的 一個解決方法是把情況顛倒： 讓避免變得可見 開一個存款帳戶，然後每跳過一樣東西不買，就在那個帳戶裡存進同等金額的錢 早餐沒點拿鐵？ 轉五美元進去 下個月不訂購 Netflix？ 轉十美元進去 值得注意的是，選擇的短期獎賞必須能夠強化你的身分認同，不能與之牴觸 16. 如何每天堅持好習慣 習慣追蹤器 最基本的形式就是找一本日曆，只要有執行例行事務，就在那天打個勾 Why 顯而易見 記錄上一個行動，可以創造觸發下一個行動的因子 有吸引力 最有效的激勵就是自己的進步 習慣追蹤可以產生一種成癮效果，每個小勝利都餵養著你的渴望 令人滿足 習慣追蹤還能幫助你專注於當下所做的事：把焦點放在過程，而非結果 不再執著於練出六塊腹肌，而是試圖讓連續紀錄延續下去，成為從不錯過健身行程的那種人 如何在習慣中斷之後快速回復 每當這種情況發生，我就會提醒自己守住一個簡單的原則：不要錯過兩次 問題不在於犯錯，而在於以為只要無法做到完美，就乾脆不要做 即使只是執行一點，也要執行 在狀態不佳（或忙碌）的一天繼續執行你的習慣，有非常大的價值 17. 問責夥伴作用大 習慣契約 - 讓違背承諾變成公開且令人痛苦的事 一份口頭或文字的同意書 表明你承諾投入某項特定習慣 未能貫徹時會有的懲罰 找一到兩人來擔任你的「問責夥伴」，與你一同簽署這份契約 18 基因如何影響習慣的養成 基因決定的不是你的命運，而是你在哪個領域會有機會 如何找到對自己有利的賽場 什麼事情對別人來說是勞苦，對我來說卻是樂趣? 什麼事情讓我忘記時間？ 什麼事情讓我比一般人得到更多報償？ 什麼事情對我來說是自然而然的？ 當你無法靠著「更好」來贏，可以憑藉「不同」勝出 透過結合自己的各項技能，你把競爭程度降低，讓自己更容易出頭 19. 如何在生活與工作中維持動力 維持動力並達到欲望最高點的關鍵： 執行「難度恰到好處」的任務 如何在感到無聊時保持專注 變動獎賞 但變動獎賞不會創造渴望 不能拿一個人們不感興趣的獎賞，以變動的間隔給，然後希望可以讓他們改變主意，但對於強化原本就有的渴望非常有效，因為變動獎賞能夠減低無聊 不管有沒有變動獎賞，任何習慣都無法永遠保持有趣。在自我精進的旅途上，到了某個時間點，每個人都會面對同樣的挑戰： 你必須愛上無聊 在討厭的時候、痛苦的時候、筋疲力盡的時候還是挺身繼續，這就是專業人士與業餘者的差別 專業人士堅守既定行程，業餘者接受生活的干擾 專業人士知道什麼事情對自己最重要，帶著決心奮力向前，業餘者則讓生活中的緊急事件拽離正軌 20. 建立好習慣的壞處 當習慣變得自動化，你對回饋就變得比較不敏感，落入無意識的重複之中 錯誤就比較容易趁虛而入 當你可以不假思索地把事情做得「夠好」，就不會去思考要怎麼樣才能做得「更好」 習慣 ＋ 刻意練習 ＝ 精通 作者使用的反省/複查模式 每年十二月，進行「年度審核」，反思過去的一年 為那年的習慣打分 發表了多少篇文章 健身了多少回 造訪了多少個新地方 and etc. 問自己以下問題，反思是否有進步 今年什麼事情很順利？ 今年什麼事情不順利？ 我從中學到什麼？ 六月，進行「誠實報告」 重新審視自己的核心價值觀，思考自己是否有依照這些價值觀行事 思索自己的身分認同，看看應該如何努力成為自己想要成為的那種人 問自己以下的問題 驅動生活與工作的核心價值觀為何？ 現在如何誠實地生活與工作？ 未來如何設定更高的標準？ 這兩份報告不會花太多時間，每年幾個小時而已，卻是精細改進的關鍵時期 如何破除妨礙你前進的信念 不要讓身分的任何單一面向決定你是誰","tags":"Book","url":"https://wei-lee.me/posts/book/2020/01/atmoic-habit","loc":"https://wei-lee.me/posts/book/2020/01/atmoic-habit"},{"title":"PyCon CA 2019","text":"隔了一個多月，終於有時間可以來補 PyCon CA 2019 的心得 這是我今年參加的第四場 PyCon 終於是因為當 Regular Talk 的講者參加 當初會想投稿的原因，就單純的是被 PyCon CA 的 Organizer 在 PyCon US 的閃電秀燒到 「秋天剛好是來加拿大看楓葉的好時間」 好像還沒來過加拿大就來投稿看看吧 XD 雖然這麼說，這個想法也是擱置了好一段時間 之後開始比較認真在構思，則是因為有其他想去北美一趟的理由 想想之後也會協助 PyCon TW 2020 議程組 來當講者看看，好像也會知道大家都在幹嘛（？？？ 講者宣傳 PyCon CA 每一位講者的議程都會發篇推特宣傳 而且會積極地邀請你一起來宣傳自己的分享 這點還蠻有趣的 會場 PyCon CA 辦在一個市中心的宴會廳 Keynote Speaker 的演講廳完全是大家可以邊吃飯邊聽議程的 XD 議程 提醒議程的方式很好玩 走廊會閃燈，提醒大家議程即將開始 原本以為是劇場的三明三暗，但好像都會閃超過三次 但還是蠻有趣的 第一場我去聽 Understanding autistic children using BioSensors and Python! 稍微詳細一點的筆記我都丟在 note 這場主要在講她們如何透過 sensor 來偵測自閉症 再來我去聽 My Favourite Errors - Tales From The Ops Side ( note ) 主要是講各種可能遇到的 HTTP 錯誤 除了前一場本來就是我非常有興趣的議題外，這場是我覺得 PyCon CA 數一數二精彩的議程 雖然跟 Python 完全沒有直接關係 XD 後來發現講者前一段時間才在 devops day 講過同樣的講題 接下來連三場，我跑去主持人，就沒特別花時間做筆記 畢竟用非母語主持其實還是有些吃力 主持完真的太累，就一口氣休息了幾場 Modelling user journeys with Keras and neural networks 第一場主持的太緊張了，沒有什麼聽到 XD Anomaly detection in the wild 主要講如何偵測異常值，舉的例子都還蠻有趣的 A Pythonista's intro to Kafka: no, it's not like Celery 如果對 Kafka 有興趣，這場很值得聽 第二天早上是閃電秀 登記閃電秀和其他活動的方式是上去改 PyCon CA 的 wiki 我也投了一個小小的閃電秀來宣傳一下明年的 PyCon TW ( slide ) 迴響還蠻不錯的，尤其是講到台南美食的時候 XD 倒是這天因為太冷了，我有點睡過頭，差點就趕不上閃電秀... 因為我是這天的下午分享，聽的議程就比較少 印象最深刻的是 Fun with compilers: exploring languages one Python at a time GitHub 之前有人問我 Python 到底是編譯還是直譯 這位講者給的答案是 Python 就只是個語言，要看用哪個 implementation 來跑 PySpark: avoiding common pitfalls and keeping your sanity ( note ) PySpark 跟 Python 語法上一些不同需要注意的地方 How to Level Up ( note ) 用什麼心態面對學習，才能讓自己的技術更上一層樓 當天因為體力跟時間的關係，還有不少議程沒聽到 這些是之後影片出來我會想要補的議程 My Favourite Errors Fantastic anti-patterns and where to find them: pinpointing performance bottlenecks Rust accelerated Pythons How to build bulletproof integrations Forecasting and observing airfare trends using Python and neural networks Operator overloading: you're doing it wrong Put Your Data in a Box Python is a weirdo The blameless post mortem: how embracing failure makes us better Pull requests: merging good practices into your project Python Table Manners - A Clean Style 我的分享主要是整理了一大堆工具，他們可能能在開發的各個不同環節用上 我把這次的分享定位在「讓你知道有這個工具，我怎麼用它，你如果會用到，可以自己研究細節」 因為介紹了很多工具，所以沒有辦法深入討論 當初也有點擔心這樣的內容會不會太淺 出發 PyCon CA 前，有先到 Taipei.py 分享一下 得到的迴響比我預想的還好些 PyCon CA 當天來聽的人也算不少，我想應該還算成功吧 slide 一個有趣的小插曲是 我原本介紹了一套 Java Script 的工具 commitizen 雖然 Python 也有 commitizen 但一開始用的時候，遇到了很多的 bug PyCon CA 前一個禮拜，覺得還是想介紹個 Python 的套件 就想說去貢獻看看，能不能把這些 Bug 修完 認真使用才發現功能大部分都沒問題，只是我剛好亂玩遇到 Bug...... 幸運的是 commitizen 作者回覆超快 PyCon CA 前，我就把遇到的 Bug 都修完了 既然都修完了，就順便把這段的投影片也更新一下 後來還拿著這個專案去主持一個 Sprint Development Sprint 參與的專案還蠻多的 在 PyCon CA 前，幾乎沒有人想填 wiki 都是到 PyCon CA 開始後，甚至是 Sprint 開始後才慢慢有專案出現 XD 原則上不供餐，鼓勵你和你的夥伴一起出去吃飯 其實我覺得挺好的 雖然第二天還是訂了 Pizza XD 雜談 雖然今年參與的 PyCon 都有讓我覺得比起之前跟參與者的交流更多 PyCon CA 給我的感覺是所有參與者之間最沒有隔閡的 大家就是一群來這裡的 Pythonists 不會因為你有不同的身份，而有不同 但也可能是我當了志工才有這樣的感覺 紀念品也還蠻有趣的，是當地很需要的毛帽 有一度想要買，因為真的很冷... 我在加拿大期間最冷的期間就是會期這兩天 -8 度真的很瘋狂，但又不能不出門......","tags":"Tech","url":"https://wei-lee.me/posts/tech/2019/12/pycon-ca-2019","loc":"https://wei-lee.me/posts/tech/2019/12/pycon-ca-2019"},{"title":"PyCon TW 2019 - Do you know PyCon JP","text":"每年的 PyCon TW 都是我在台灣蠻期待的研討會 雖然第一年來的時候，幾乎什麼都聽不懂 但還是被各種大家正在做正在研究的事有些震撼到 而今年跟往年不同的是，我誤打誤撞的成為了 PyCon TW 志工 多誤打誤撞呢 大概就是我在報名了 PyCon JP 參訪團後不久突然收到了這個訊息 我是到最近才確認了當初敲我的是誰，雖然一直有在猜 XD Being a volunteer 我大概到七月才加入，往年這都是辦完 PyCon TW 的時間了 所以我真的完全是菜鳥一枚 一進入議程組，就接了聯絡 Keynote Speakers 的工作 一開始就丟這種應該挺重要的工作給菜鳥真的是可以的嗎 XD 今年我主要工作是負責各式的英文書信 包含後來跟財務補助申請人的書信往來，我都有碰到 英文書信還真的不是一件簡單的事啊..... 每一封信常常還是要花我不少時間才能擬好 不過是真的蠻有趣的，會有更多跟來自各個國家的人相處的機會 每個 Keynote 都是很有個性的人 XD 會議期間，我大概有一半的時間都在當主持人 而且我大多都主持英文場 英文主持沒準備好，就真的很容易會卡 QQ 但當主持人真的是一個跟能跟講者多交流的機會，還蠻有趣的 話說這是我第一次站上了 R0 的舞台了呢（笑 所以就不要猶豫了，明年來加入議程組吧！ 或者加入各個你有興趣的組都好 總之先填單吧 XD PyCon TW 2020 志工報名 During the conference 不知道是不是因為我今年當了志工才有這樣的感覺 總覺得今年在於讓會眾交流這點，有做得比往年更好一些 至少我很努力的帶我拉來的人去認識各路的大大 雖然原本也在懷疑多擺個高腳桌到底是不是真的會促進會眾交流 但就結果來看，應該是真的蠻有幫助的（？ 今年的 PyNight 依然是少不了各式的音樂表演 我來 PyCon TW 聽音樂會 還有一位用機器學習做音樂伴奏的講者 直接在 PyNight demo 他的作品，真得挺有趣的 在走廊那邊，大家也玩白板玩得很開心 日本、波蘭、馬來西亞來的朋友，都在這個白板畫上了自己的 PyCon 甚至在 PyNight 後 除了帶各國 PyCon 來的朋友一起吃熱炒，還邀請了一些會眾一同參與 倒是有一個有趣（？）的小插曲是，我沒注意到波蘭的朋友帶來的酒其實很烈 我倒酒倒到一半的時候，當突然現場一片歡呼 我才知道我倒太多了... 今年特別擴大舉辦的 Open Space 在那個時段完全沒有其他的議程 算是想故意促成大家多交流，也是推廣 Open Space 這個概念 原本還在怕會不會沒有人想來主持，結果好像一開放沒多久就爆滿了 XD 這是我第一次主持 Open Space 雖然人不是特別多，而且大都是自己人 QQ 但聊聊各地的 PyCon 還是挺有趣的 PyCon [A-Z]+ or just traveling experiences ~~Help me decide where to go~~ 今年好像是第一年讓 Speaker Tour 成真（？ 原本抱著大概只會去一些台北觀光客景點的心態來參加 沒想到這個導覽真的超出我的預期 即使這些地方我都去過不知道幾次了，我還是覺得這趟挺有趣的 這還是我第一次從這個角度看台北呢 Talks 既然是技術研討會，總覺得還是要分享一下有趣的 talk 但我好像常常到處跑，沒有認真聽完太多的 talk XD 最近我們開始在上傳影片了，可以到 PyCon TW 的 Youtube 頻道 看這次的錄影 PEP 572: The Walrus Operator 在 PyCon JP 的時候，就有跟講者 Dustin 聊過 他說這場是他自己覺得最喜歡的 talk 我也是因為這樣才來的 不然單就標題，我可能不會特別感興趣 就結果來說這場非常的精彩 主要在講 PEP 572 造成整個 Python 管理階層重組的事件 Keynote: Programming Language Tourism: Leave Python and see the world! 這場主要在談 Python 以外的程式語言的各種特性 透過看其他語言的設計和想法，來重新看看 Python 的設計和未來 Python 能怎麼再改善 不過講者 Paul 提到的語言，我好像真的只有聽過 Golang 而已...... 想再多提一下 Paul，他是個相當有趣相當熱情的人 整個會議他都很積極跟我們交流，並參與我們的各種活動 Wait, IPython Can Do That? 這場主要在講各種 IPython 的神秘用法 btw 我也很喜歡講者 Sebastian 在第三天結束給的 Lightning Talk Keynote: The Different Paths We Take As Programmers 這場主要在從不同的角度看待 Programmers 其實還有很多人透過程式和不同的背景知識在解決不同的問題 而他們不見得是傳統認為程式很強的人 我們可以試著更接納來自不同領域的人，而不是把他們拒於門外 這才有助於讓這個社群更多樣、更好 In conclusion, there is no true programmer. 出去外面才知道台灣的好啊 XD 中研院這個場地真的是有夠高級 阿對了，還是要炫耀一下 我有搶到 Tracy 親簽的書 Do you know PyCon JP? 最後回來聊聊，副標 Do you know PyCon JP 是怎麼回事 這是起源於第一天的 Lightning Talk 第一天的五場 Lightning Talk 中，有四場都是來自 PyCon JP 的朋友 而且每一位都有一頁會提到 Do you know PyCon JP 第五位講者雖然不是來自日本，但也跟進了這個梗 連第二天的 Keynote Paul 都玩這個梗玩得很開心呢 So... Do you know PyCon JP?","tags":"Tech","url":"https://wei-lee.me/posts/tech/2019/10/pycon-tw-2019-do-you-know-pycon-jp","loc":"https://wei-lee.me/posts/tech/2019/10/pycon-tw-2019-do-you-know-pycon-jp"},{"title":"PyCon JP 2019","text":"當初在 PyCon US 看到 PyCon JP 上去介紹他們自己 不知道哪根筋不對，就覺得不然就來投稿一下吧 雖然後來投稿並沒有上，但突然發現 PyCon TW 想揪團一起去 想說這次不去，說不定就不會再有這樣的揪團了 就衝動的報名下去了 XD Development Sprint sprint 的報名有分 Leader 跟 Attendee 現場到的人大概 100 人 雖然不用錢，但就是要統計一下人數 而且他們還有不斷寄信提醒「如果無法出席，請釋出位置給想參加的人」 感覺人好像蠻多的 雖然他們的 sprint 辦在假日，這樣比好像不太公平 但感覺上比之前在台灣參加的 sprint 熱絡了不少 一開始會公佈有哪些專案可以參與 到結束前，大家各自分組討論和開發 最後來個 demo，分享大家一天的成果 總共十來個專案中，只有三個是英文的 有兩個就是台灣人 Host 的 所以就來試試看剩下的 awaitwhat XD awaitwhat 的目標是想挖到 async 更深的 traceback，讓 async 的除錯更方便 但我實在還沒有對 async 太熟 最後就是花了點時間對專案做了一些 refactor 雖然看起來改動很大，但其實貢獻真的很還好（笑 晚餐倒是很有趣，他們好像想把餐點排成一隻蛇 xD Welcome Party 只有上台 5 分鐘的 Lightning Talk 講者也能來參加講者晚宴（笑 場地沒有座位，只有圓桌 這樣的安排應該是方便大家隨意移動，就能促進更多人的交流 認真想想這樣的設計還蠻不錯的 然後每一個圓桌上都有啤酒 XD PyCon JP - Day 1 如果想看每場 talk 的細節的話，筆記都整理 PyCon TW Visiting Group 的 共筆 上了 我就不聊每一場的細節了 一開始有點不習慣他們的場地 Keynote 演講的空間後面馬上就是海報，在更後面就是贊助商 有時候聲音就會蠻發散的 不過後來聽前輩們說好像大部分的場地都是這樣 中研院真的是場地太好 倒是 Keynote 會有英日互轉的即時口譯，覺得還挺不錯的 海報的部分則是要感謝 Ohmura-san 幫 PyCon TW 做了精美海報 🙏 整天下來我最喜歡的 talk 是 Takanori-san 的 Automate the Boring Stuff with Slackbot 雖然只是被一些有趣的點打到了（笑 今年他總共參加了 8 場 PyCon 而且大多都是講者，就算不是講者也有帶海報過去 雖然 Noah 好像今年參加了 11 場？ 後來跟一些外國講者聊到 Noah，他們說不管到哪場 PyCon 都會遇到他 XD 因為明年是 Python 2 的 End of Life Designed by Lisa Roach 有好幾場 Talk 都跟 Python 2 to 3 相關，像是 \"It's 2019 and I'm still using Python 2. Should I be worried?\" 跟 Kir 大大的 \"SupportingPython3 in Large Scale Project\" 對於議程安排覺得還蠻不錯的一點是「同一個時段至少會有一場英文的 talk」 外國來的會眾不會在任何一個時段因為聽不懂日文就完全沒有能聽的 talk 後來跟他們聊到，這好像也是他們近期在努力的目標之一 Peer Reviewed Lightning Talk 最後想提到我的 Lightning Talk slide 跟 video 都已經釋出了 PyCon JP 的 Lightning Talk 還蠻特別的 分為 Peer Reviewed 跟 Same Day Peer Reviewed 必須先投稿，也需要經過審稿 (PyCon TW Visiting Group 包下了所有英文的 Peer Reviewed Lightning Talk XD) Same Day 則是當天投稿，當場抽籤決定誰是講者 我的 Lightning Talk 主要是要介紹 PyCon TW 我用「與人交流」作為 \"How to get more than PyCon in a PyCon\" 的核心 每一個點再帶到 PyCon TW 在做的一些努力之類的 但其實到了日本才發現，這邊的會眾超積極在跟人交流的啊 XDDD 果然只是我以前都待在舒適圈太開心，都只跟原本的朋友聊聊天 有一個小插曲是 大家湧入主會場的時候，網路就開始不穩定了...... 因為我到當天都還有再改 slide，還沒來得及抓最新的離線版本，讓我著實抖了一下 Peter 說得對 \"Never live Demo. Never Internet......\" 還好在我上台前，網路有稍微恢復，才沒有出包 雖然只有 5 分鐘，但第一次上台給全英文的 talk 還是挺緊張的 原本 PyCon JP 的 party 結束後 Takanori-san 很熱情的帶我們去續攤 PyCon JP - Day 2 這天的 Keynote Pythonで切り開く新しい農業 主要是在講他透過 Python 來分辨小黃瓜的故事 我很喜歡他對 AI 的註解 現在越來越少人要當農夫了 如果不做些什麼，農業的知識就會流失 而 AI 正好可以作為一種知識儲存和傳遞的工具 Dustin 的 Modern development environments for Pythonistas 也讓我印象蠻深刻的 主要是因為跟我要去 PyCon CA 講的內容相關 再加上，結束後我們一群 PyCon TW 圍著他問問題 XD btw Dustin 在 PyCon TW / US / ... 給的 talks \"PEP 572\"，真的非常精彩 錯過的話，非常推薦可以補帶 當然還有 KK 大的 When AI meets 3000-year-old Chinese Palmistry 其實我這次來比較少聽 AI 相關的 talk，但分析手相實在太有趣了 最後我有嘗試去聽一場日文的 talk 憑著我 50 音都背不齊的日文程度，果然還是太挑戰了 XD 當我以為我至少能看投影片的時候，他的投影片也是日文的 後來發現好像是台灣才是比較特例 即使是用中文給的 talk ，還是習慣用英文做投影片 最後閉幕的時候聽到 Python 這個商標在日本被 ARK 註冊走 PSF 要著手處理這件事了 最後大合照的無人機 某人把還沒打開的奶精加入咖啡 離開日本前， Visiting Group 小聚 Speaker Tour 會議結束後的一天，PyCon JP 還有帶講者們到淺草寺等有名的景點走走 可惜那天下著大雨 QQ Final Words 整體來說，我覺得 PyCon JP 辦得比我想像的來得更好 能跟著 PyCon TW 來，也讓我覺得跟人交流有比較容易一些 如果下次還有揪團，我應該也還會再來 恩對，大概就是這樣 在找一些東西的時候，發現同行的前輩 Kir 也發了一篇 PyCon JP 的文 My journey of PyCon JP/TW 2019 另外，這是發在 PyCon TW Blog 的參訪報告 - Visiting Group in PyCon JP 2019 整理了我們整團的所見所聞 如果喜歡這篇文章的話，你雖然沒辦法拍手 50 下 但可以在下面按一個 response，或留個 comment 跟我聊聊天 如果能在順手填一下 2020 年的 PyCon Taiwan 志工招募 就能給我更大的支持了 😄","tags":"Tech","url":"https://wei-lee.me/posts/tech/2019/10/pycon-jp-2019","loc":"https://wei-lee.me/posts/tech/2019/10/pycon-jp-2019"},{"title":"最近的念英文小結","text":"今年五月跑去 PyCon US 順便在美國晃了一個月後 發現自己的英文口說實在太爛了 下定決心要來練一下 回到台灣後，誤打誤撞加入 PyCon TW 當志工，負責跟外國講者聯繫 才發現不只是口說，連寫作也不行呢 ˊ_>ˋ 反正 VoiceTube Hero 也需要心得文 就順便整理一下最近念英文的方法 我只整理了聽、說、讀的部分 因為我沒有特別在練寫作，大概就先透過跟外國講者的書信往來吧 歡迎推薦好的英文寫作訓練法 XD 語言交換 - 說 不知道是不是我在台南沒主動去找這種資訊，才沒參加過 （台南真的很安逸啊 ˊ_>ˋ） 台北的 meetup 真的非常的多 以我想找的語言交換來說，一週七天都有不同的人在辦 而我就剛好參加了時間對得到的 English/Chinese language and cultural exchange 中英文語言文化交流 時間： 每週日早上 10:00 ~ 你想走或大家想走 地點： 忠孝新生捷運站旁的伯朗咖啡館 每次會有 20 ~ 40 人不等，外國人大概占 1 ~ 2 成 通常會有一、兩桌在學中文，其他都是在練英文 不得不說台北人的英文真的好好啊...... 除了希望你能在店家消費（畢竟都佔了這麼多的位置），沒有其他的費用 形式上很自由，沒有什麼規定 可以在各桌穿梭，這裡聊累了去那裡之類的 主辦人 Kieve 非常的友善，她原本在加州也有主辦一個同樣的 meetup 所以參加過的人有來台灣，通常都會順道過來一趟 通常也蠻有機會遇到去過各個國家的人 目前我只要週日沒有特別的事都會去參加（然後每次都遲到） 有興趣的人可以一起來玩 Audible - 聽、讀 Audible 是 Amazon 旗下的有聲書服務 收費方式我覺得很特別 屬於訂閱制，但又不是你訂閱後，就能聽裡面所有的書 而是每個月會給你一定數量的點數 除了點數以外，現在每個月還會再加贈兩本 Audible Original US $14.95: 一個月一點 US $22.95: 一個月兩點 每一點都可以拿來換任何一本任意價格的有聲書 這些書只要兌換後就都是你的，而且不會因為取消訂閱而消失 但印象中點數要在會員期間用完就是了 我通常都是列一個要買的清單，直接訂閱 $22.95 直到我要買的清單換完 不過最近發現 Kindle Store 上買電子書加有聲書，有時候會比較便宜 所以其實我現在也用不太到會員了 XD 雖然中間有停過一段時間，但我算是持續聽 Audible 快三年了 我盡可能地維持每天都要聽 1 ~ 2 個章節，時間平均大概是 20 ~ 40 分鐘 截至我寫這篇文章的時候，總聆聽時數差不多是 170 小時 在播有聲書的時候，我通常會把書一起拿著看 如果還沒有常接觸英聽，我會建議從青少年讀物 (Young Reader Books) 開始 雖然現在我已經有辦法單用聽的就大部分都聽懂 但有文字的輔助對一些細節的了解還是蠻有幫助的 更重要的是比較不會分心，只有聽故事實在太放鬆了 XD 因為我是一個 Star Wars 迷，到目前為止大多都是看 Star Wars 的小說 整體的體驗非常的好，你就像是看了一場電影一樣 說書人們 (narrators) 真的很厲害，大部分都是一個人配完裡面所有的角色 反正第一個月試用 audible 是免費的，可以先試試看 如果透過以下的連結去註冊，會間接的贊助到我很喜歡的 Youtuber audible trial 當然也可以找看看有沒有你喜歡的 Youtuber 有類似的連結 我看到好幾個頻道都有跟 Audible 合作 另外是， Audible 有換書機制，好像在一段時間內都可以換掉你不滿意的書 但我自己是從來沒用過 因為到目前為止，我每一本書都很滿意 如果還想要知道更多關於 Audible 的使用方式或心得 我很推薦看 小海嚴寫 的文章 我就是看了他的文章才入坑的 XD 另外，剛剛還有看到這篇 開始聽書吧！Audible 新手攻略 ，寫得也是蠻清楚的 VoiceTube Hero 零元挑戰 - 聽、讀、說 其實原本對 VoiceTube Hero 對我會不會有幫助感到很懷疑 不過回國剛好看到英文很好的朋友發了挑戰成功的文 再加上這段時間 CNN 10 放暑假去了，就決定跟進了 XDD （btw 有人能推薦一下 CNN 10 的其他替代品嗎） 我上的是高級課程，總共 30 堂課 但每一堂課要複習兩次，所以應該就可以看成 90 堂課 在兩個月內必須完成所有課程，而且每週有一定的課程數量要達到 一堂新課大概會花我 30 分鐘，複習課可能 20 分鐘可以完成 我大概抓在每天平均進度兩堂課，這樣最後的緩衝比較多 內容蠻多元的，財金、心理學、人際、國際情勢之類的都有 通常會把一個影片切成兩課 所以 30 堂課大概就是 15 個主題 看完影片後大概會問下面這幾種問題 文意理解選擇、單字聽打、單字字意選擇 單句口說錄音 單字填空 單字補充資料閱讀 片語 語句重組 對話口說錄音 只要中間有錯誤，這堂課就要重看一次影片 直到你把所有的錯誤都訂正完 這時候就會感受到自己怎麼時態都不注意、單字都沒在背 口說更是每次聽到錄音都覺得很悲劇 不過口說這部分都會有老師對每個句子講解，也會說明一些連音和發音的細節 比較可惜的是口說不會有任何的驗證正確與否的機制 不過口說要有人驗證的話，就不會是這個價錢了 雖然除了一兩個英式口音，我比較不習慣外 大致上課程不算太困難 但我的答對率其實還是蠻低的，大概 7 成左右吧 不背單字、不好好看完問題就會這樣 XD 最後我不小心太早完課 但每週基本任務（三堂課新課、三堂複習課）還是得繼續完成到跳戰結束 所以有幾堂課多上了幾次 倒是在結束後才發現還有一個功能是跟別人 PK 還挺有趣的，沒事可以來玩玩（？ 不得不說，客服的回應真的很快 真的是馬上就會有回覆那種 有一次我遇到系統錯誤，說我挑戰失敗（嚇死我了） 問完客服，馬上就修正了 好像應該來總結一下我對 VoiceTube Hero 的想法 我覺得他的課程還蠻不錯的 不是死板板的教科書對話，有時候還能獲取到一些原本不知道的知識 每次放出自己殘破口說的錄音，還是會逼自己多錄個幾次 拼字、時態都要很注意才能一次通過整個課程 我認為他最能幫助到的應該還是養成撥出時間唸英文的習慣 畢竟語言這種東西不太是一蹴可幾的 VoiceTube Hero 比較像是讓英文一直進步的開端","tags":"Gossiping","url":"https://wei-lee.me/posts/gossiping/2019/09/how-i-learn-english-recently","loc":"https://wei-lee.me/posts/gossiping/2019/09/how-i-learn-english-recently"},{"title":"COSCUP 2019","text":"事隔了兩年又再次參加了 COSCUP 上一次好像是還在中研院的時候 現在會議都會有共筆，就不太需要再另外做筆記 所以大概就是聊聊這次去比較喜歡的幾場 talk COSCUP 2019 共筆 好像前幾年就開始有把每一個軌的主題分得很清楚 也有可能是我以前去的時候沒發現 XD 這次參加最多場的應該是 開源與職涯 這一軌 尤其想聽 海外頭路：憂喜甘苦談 我明明已經提早過去了，沒想到隊伍從前 10 分鐘就排得很長了...... 是大家都想離開台灣了嗎 XD 聽到最有趣的是 talk 是 如何在两年内从初学者成长为流行开源项目维护者和技术书作者？ （ 共筆 附上） 講者分享如何在兩年內成為了 flask 的維護者，還寫了一本技術書 最重要的訣竅就是 不要工作 比起提供建議，我覺得這更像是是一個 call to action 用他的故事來告訴我們，要做到這些事並不見得那麼困難 有時候就是需要多一點衝動而已 不知道有沒有錄影，這場真的蠻值得再看一次的 XD 第一天最後是 Rust 核心成員 Steve Klabnik （ 共筆 ）帶來的 talk 原本還想說再講 Rust ，會不會聽不懂 不過後來講的內容跟開源專案的組織管理比較有關 其實還挺有趣的 第二天一早就被告台科大停電，臨時更換地點 不過還算是蠻順利的，除了換個場地，沒有網路了以外，倒是沒遇到什麼大問題 這天我大概都在會場亂晃，除了下面有筆記的兩場 talk 外，好像就都沒什麼印象了 XD 下面就放了一些我當天有做的筆記 有一些是從共筆補充過來 也有一些時覺得不知道怎麼整理上共筆，就留在這了 Day 1 Infra / DevOps 的養成之路與開源工具 共筆 slide - 開源與職涯 - Infra 的養成之路與開源工具 slide - 系統工程師的大怪升級之旅 Ref: 奮鬥吧！系統工程師 開源與職涯 - Infra 的養成之路與開源工具 CV 要夠詳細 只有打 Linux 五個字沒有人看得懂 → 細說你會什麼 社群 選擇你最舒服的方式參與 開源社群 List 系統工程師的大怪升級之旅 DevOps 三步工作法 由左自右的流動 從右自左的回饋 文化 推薦讀物 自我成長: 學徒模式 DevOps: The Nature of Software Development Q & A Q1: 撰寫 DevOps 部落格時如何避開機密、公司智財權等？ 自己複製出環境、資料等，自己把找到的技術在自己的環境複製一次，執行成功之後才記錄下來 Learn to test and then test to learn Material slide Pitfalls of End-to-end Testing High learning curve Hard to build and maintain Not easy to identify defects Slow feedback Not realistic enough Test to learn 透過寫測試，紀錄學習歷程，下次回來看就知道怎麼用了 Wrap Up Unit Testing is the foundation and hard to learn Mock and wrapper help you isolate your system boundaries To make your code unit-testable, you'll learn to write better code. Test to learn 海外頭路：憂喜甘苦談 共筆 荷蘭 Why Not The Netherlands 荷蘭文難學 食物難吃 外食很貴 房租很高 稅很重 (up to 51.75%) Why The Netherlands 英文可存活 簽證好辦 薪水 多元文化 氣候宜人 (冬天頂多 0 度) 房貸比房租便宜 30% Ruling （高技術外國人的稅務優惠） Bonus 在歐洲正中間，方便旅遊 大麻？（其實是非法，但政府明確表明不抓 xD）紅燈區？ 荷蘭對 Work from Home 的政策算蠻鬆的 日本 Mercari Backend Engineer What is Mercari？ 主要做二手拍賣 主要使用 Go Lang, php How many leave do you have? 10 days leave + 3 days summer leave + 10 days sick leave Are you usually late for work? 彈性工時 (12:00 ~ 16:00 一定要在公司) How many foreigner in you project? Engineer: 50% foreigners Do you have lots of nomikai（應酬）? 一季一次 一次約 ￥4,000 Q & A Q: 日本階級制度很重？ 是，但因為是外國人，所以可以裝作不知道 Q: 怎麼找到海外工作的？ LinkedIn, location 換到當地後，就會有收不完的邀約了 Q: 不會日文可以去日本工作嗎 只會講英文的話，建議去 Line, Rakuten, Mercari ，小公司至少要有 N2 比較順利 Q: 日本薪水大概是多少 New Grade 年收 400 萬日幣， Senior 則要怎麼談 Q: 荷蘭 engineer 職缺多嗎？ 很多，目前最大是 Uber ，另外有很多新創 因為英國脫歐，最近荷蘭職缺比較多 Q: 荷蘭的永久居留證？ 雖然荷蘭不能雙重國籍，但因為不承認台灣是個國家，所以申請上會特別容易，不會被刁難 Q: 台灣人到歐洲最大的障礙是什麼 自己煮飯，其他都還好 Q: 會遇到歧視嗎？ 日本 - Lilith Peng 女性歧視有點大 排外的社會 → 沒有解法，各憑本事 荷蘭 - 呂行 除非到鄉下才會有歧視，但大城市還好 Q: 除了薪資以外，為什麼想出國 體驗不同文化、生活方式 Q: 為什麼 荷蘭/日本，而不是北美 荷蘭 - 呂行 因為北美簽證不好拿，不習慣美國的生活方式 日本 - Lilith Peng 日本有高度人才證 會日文，英文不好 XD 日本離台灣近 稅率比歐洲好 房租便宜 Q: 日本/荷蘭 的面試文化？ 荷蘭 會有白板題 一關問架構 一關問經歷 日文 履歷表用 Excel 寫，會加分 履歷是一致的格式 面試分兩種 外商派 日本傳統派 西裝外套、打領帶、皮鞋、公事包...... 90度鞠躬 他們就是看感覺錄取 ← 他們認為人才是可以被培養的 XD Q: 會不會有天花板 日本工程師大概 1,500 萬就是天花板，除非轉管理職 荷蘭不算特別明顯 Day 2 源碼在哪裡 grep 可以對二進位檔直接做文字搜尋 Technical / Development History Firsthand Mailing lists , IRC, HipChat, Slack, Issue trackers, Forums, Journals / Papers Summary Wiki, Tech News, Tech Document, White Papers, Blogs, Books, Review papers Management Source Hosts Github / Bitbucket and etc., SourceForge, Launchpad Local Deployment FHS, Language-specific path Distributed Deployment Auxiliary services (e.g., Open Stack, web) Version Major.Minor.Patch Do you Select PostgreSQL or mysql slide Difference between MySQL and PostgreSQL Server architecture MySQL → multi-thread PostgresSQL → multi-process Licence MySQL → GPL v2 or Commercial License PostgresSQL → PostgresSQL License The Development Style MySQL → Oracle PostgresSQL → Community Advantage of MySQL Extensibility Good at fetching by primary key and primary key update Flexible replication Multi source replication Group Replication → Multi Master Document Store JSON type → schema-less table Advantage of PostgreSQL Parallel Query but not to increase number of workers beyond number of CPU core Materialized View Foreign Data Wrapper → an external table handle for your own table (other DBMS) support WHERE, JOIN, GROUP BY, DELETE & UPDATE Any data store is acceptable GIN INDEX & Function INDEX + JSON","tags":"Tech","url":"https://wei-lee.me/posts/tech/2019/09/coscup-2019","loc":"https://wei-lee.me/posts/tech/2019/09/coscup-2019"},{"title":"[Book] The Ultimate Guide to Remote Work","text":"This is an excerpt of Zapier's book The Ultimate Guide to Remote Work . I had a good time chatting with Zapier in PyCon US and then found this book on their website. Since I currently work remotely, I thrive on making myself a better remote worker. Hope this excerpt would help if you're working remotely or considering it. Chapter 1: How to Run a Remote Team Important ingredients to remote work Team Tools Process Team Hire Doers → default to action Hire people you can trust Trust the people you hire Hire people who can write Communication is one of the most important parts of a remote team. Hire people who are ok without a social workplace It'll be important to try to create some social aspects with a remote team. But the truth is that remote workplaces are usually less social than co-located ones. Tools Slack → If you're in Slack then you're at work Trello Trick to avoid getting card overload Each card needs to have Detailed description of the feature Why it's important the results of a successful implementation of it should look like GitHub 1Password Google Docs & Quip Zoom HelloSign Process Everyone does support Culture of shipping Weekly Hangouts Air Buddies Weekly One-on-Ones A culture of accountability People often ask \"how do you know if employees are actually working?\" → Friday updates Building culture in person Automate anything that can be automated Chapter 3: How to Hire a Remote Team Propensity towards action Ability to prioritize Proficient writing Trustworthy People with Local support system Chapter 5: How to Build Strong Relationships in a Remote Team Performance Review combines the following 3 aspects Manager's own opinions Thoughts from co-workers A self-evaluation from the actual employee If you're setting up phone or video calls to meet your new teammates, try setting a time limit of 15 minutes. Putting aside our own desires to contribute to the conversation and instead asking short, open questions like how, when, and why. Replying on Text the Right Way Stay Up to Date Remember Hanlon's Razor: We should always assume ignorance before malice Asserting Yourself When Needed set up rules ahead of time e.g., set up your focus time and ask others not to message you at this time Find a way to share the context of your situation with your teammates. Keep in mind all the information you have about how you feel and your current needs that your teammates don't have. They need all the information you can give them to work with you in the best way they can. Chapter 10: How to Work Faster in a Remote Team \"If employees don't have freedom and independence to make decisions, remote work will be less effective.\" How to deal with vast numbers of emails? Company and department updates, project specs, design mock-ups, and individual \"Friday Update\" reports moved from email to our private internal blog Team and department feedback, along with questions and discussions, moved to Slack, which replaced one-on-one email threads with its private messaging feature, too. Whether it's working in your own home or a nearby coffee shop, there's another aspect that pushes remote employees to work faster: You're responsible for your productivity . Completely unplug from the communication tools. Do this, and then put 100% focus on writing in a distraction-free environment. Chapter 11: How to Find Your Optimal Work Environment and Boost Productivity If you have different types of work, grouping similar tasks into time \"chunks\" can make you more productive than switching between different types of work. Small, simple tasks can be saved for the periods when you're low in energy, or in-between meetings. Work on the big, intense projects first, and work on smaller tasks that don't have deadlines as you go through the day. Chapter 12: How to Work in Different Timezones Manage projects in an asynchronous way Break things up into chunks that can be worked on individually Find time to sync back up on what's been done, and make sure each person can self-direct their work Work in an asynchronous way Check in with your team before you start your workday and make sure you're on the same page as everyone else. To work effectively with a time shift, you'll also need to work in public. In other words, communicate, and make sure everyone knows what you're working on. Write what you've done that day, share where you're hung up on a project, and ping others with ideas. Chapter 13: How to Avoid Burnout in a Remote Team Establish and Maintain a Routine Set and Stick to Priorities 'Have I done the most important work I could do today?' when I can say yes to that, then I can log off, recharge, and invest in the other areas of my life. Create and Keep Boundaries Find your rhythm and protect it to avoid burnout. For me, that rhythm means taking time to reflect and celebrate progress when planning, and setting boundaries like working outside of my apartment at a co-working space or scheduling deliberate non-work time into my week. Take Short and Long Breaks Take a three-day weekend every now and then. Make sure to get away from everything for a week or two each year. Make Time for Human Interaction Prioritize your social activities, because they are a form of self-care. Recruit - 4 essential traits You're tech-savvy You're an efficient communicator You're independent and trustworthy You've mastered time management Where to Find Remote Jobs FlexJobs is a job board that showcases not just telecommuting openings, but also job postings for other types of flexible arrangements, such as freelance or part-time work. Price: $14.95/month to $49.95/year Jobspresso allows you to search for jobs in specific categories, such as marketing, copywriting, project management, and support. All of the jobs listed are curated for remote workers. Remote.co is passionate about remote work and partners with startups that feel the same way. We Work Remotely is sponsored by Basecamp and their book Remote, which delves into all things related to working remotely. The job board is updated daily, and you can subscribe to the site's RSS feed to get informed of new job postings. Working Nomads provides a curated list of remote jobs for individuals who want to travel while they work. How to Apply and Interview for a Remote Work Job Prepare for the video interview If you're positive, curious, and articulate in the video chat as well as other parts of the application process, hiring managers will be more confident about you. Try out the video app before the interview. Find a quiet space where you can focus on your interview and won't be distracted. Dress professionally and stay engaged during the interview. Explain why you want the exact position. Just wanting to work at a remote company is usually not enough for specialized roles. You might be asked about or want to mention things like Successful solo projects you've started or team projects you've led. Your reasons for wanting to work remotely. What makes you fit for working on a remote team? (independence and trustworthiness) Previous writing experience and other communication skills How do you choose the communication tool for different situations? (communication skills) Your daily routine and methods to stay focused. What are your optimal work hours? What's your workspace like? How do you prioritize tasks? How do you balance work and personal life? (time management skills) Questions you should ask to make sure the company is really serious about remote work How many people do you have working remotely full-time? Is occasional travel needed to meet with co-workers? How does the remote team usually communicate? What would my typical schedule and day look like? How often would I be in touch with my manager? If you're applying for an employer in another country, before accepting a position it's a good idea to find out: How will taxes be taken care of from my paycheck? Will I need to buy my own health plan? Would I need to get a work permit when visiting the employer? Chapter 14: The Remote Workers' Toolkit Mind Maps: Usage: collaborative brainstorming, project planning MindMeister Program Blockers: SelfControl Cold Turkey More options: 14 Tools to Help You Avoid Distractions and Stay Focused at Work","tags":"Book","url":"https://wei-lee.me/posts/book/2019/08/the-ultimate-guide-to-remote-work","loc":"https://wei-lee.me/posts/book/2019/08/the-ultimate-guide-to-remote-work"},{"title":"How was PyCon US 2019","text":"既然自稱 Python 的信徒 總是要來世界最大的 PyCon 朝聖一下 XD （我還因為寫了 GitHub ，被以為是 GitHub 的員工 XD） 簡介一下 PyCon US PyCon 總共跨了 9 天 除了主會議外，還有各種不同的活動跟討論 5/1 ~ 5/2: Tutorial 5/3 ~ 5/5: 主會議 5/6 ~ 5/9: Development Sprint 今年辦在 Cleveland 的 Huntington Convention Center 會眾大概有 3000 人 會議期間除了同時會有 6 個軌的 talk 以外，還會有好幾間的 Open Space 最大的會議廳長這樣 參加前，我有看了這篇 \" How to have a great first PyCon \" 對我這次去參加 PyCon 很有幫助 Tutorial 我參加了兩場 Tutorial Getting started with Kubernetes and container orchestration Kubernetes 的使用介紹的蠻清楚的，我覺得對入門 Kubernete 很有幫助 Building Evolutionary API with GraphQL and Python 主要是在講 GraphQL 的概念，我覺得偏簡單，原本希望可以多聽到一些設計上的想法 一場 Tutorial 大概是三個小時 一天參加一場，我的體力上比較負荷的來 但中午吃飯跟其他會眾聊天的時候，遇到了好幾個人都是兩天參加滿四場 Tutorial ... 好幾個會眾都推薦了 David Beazley 的 Lambda Calculus from the Ground Up 這場 Tutorial 的介紹開宗明義就說了 You will learn nothing practically useful in this tutorial. 但大家還是都很推薦這場 聽說 David Beazley 是很有名的 Speaker（請原諒我的孤陋寡聞 QQ） 我甚至遇到一位會眾說看到名字就報名了，也不用看是什麼主題 Talks 稍微簡介幾場我還有印象的 talk 也許之後有時間會把筆記好好整理一下分享出來 Day 1 Keynote - Russell Keith-Magee Python's Black Swan 你現在覺得 Python 的存在很自然，但 10 年後 Python 還會在嗎？ 我們要怎麼做些什麼才能讓 Python 在 10 年後還存在 5 Calls to Action Start thinking about Black swans (before it's too late) Improve resourcing of maintenance and R&D efforts Value contributors and their contributions Get out your wallet Contribute API Evolution the Right Way 更新 API 並且淘汰舊的版本，你需要注意的幾個設計細節 如果想直接看文字不要補影片的話，可以直接看講者的文章 API Evolution the Right Way Programmatic Notebooks with papermill Netflix 推銷自己的開源工具 papermill 用一個 jupyter notebook 當作範本，由外部輸入幾組不同的參數，一次產生多個相對應 jupyter notebooks（為什麼我在弄碩論的時候沒發現有這樣的工具 QQ） Everything at Once: Python's Many Concurrency Models 介紹跟比較 5 種 Python 的 Concurrency Model (asyncio, Python threads, GIL-released thread, multiprocessing, distributed tasks) Supporting Engineers with Mental Health Issues Enginner 常常因為壓力太大造成一些心理的狀況，該如何正視自己的狀況並試著調適或尋求幫助 Lightning Talk - Overthinking T-Shirts with Scipy 這是他們用自己公司的產品 Demo 他們計算要帶多少 T-Shirts 來發，並且快速的視覺化 其實講題蠻瞎的，但講者講的真的很有趣很精彩 XD Day 2 Keynote - Shadeed \"Sha\" Wallace-Stepter \"How many people here are on probation or parole?\" （這個開頭害我以為我是不是英文真的太差誤會了什麼...... ） Sha 訴說自己如何一個從犯人變成創業家的故事，如何在獄中學習 Python，並在出獄後重新融入社會 Keynote - Jessica McKellar 上一場像是實例的現身說法，這場則是在同一個主題下的 call to action Jessica 想做的是改變美國的監獄系統 如果出獄的人並不能融入社會，社會也不願意接受他們，那他們就會很容易再犯再回到監獄，而這會產生很大的社會成本 如果能讓他們在獄中學習技能，並說服一些公司慢慢接受這群人，我們就能讓這些人重新融入社會，並成為社會的生產力 工程師的工作不就是該修復系統嗎？ 這兩場 keynote 非常的精采，是整場 PyCon 最多人起立鼓掌最久的 Talk 很不幸的這兩場的影片剛好消失了，目前只能從 Jessica 的 twitter 看到文字版的內容 The Zen of Python Teams 將 Zen of Python 應用到建造更好的團隊 Does remote work really work? 怎樣的人適合 remote work？ (Remote work is not for everyone.) 你要注意些什麼才能成為一個好的 remote worker Python Security Tool 這場很實際地提了幾個跟 Python 有關的 Security Tool Lightning Talk - Writing Selfless Python 無私的 Python： 有了 selfless 我們不用在 Python 中寫自私的 ( self fish) class 也能有同樣的功能 Lightning Talk - One Weird Trick for people to see your name in lunch 因為 badge 太長了，吃午餐的時候其他人會看不到你的名字 那就在 badge 後面打個結，讓帶子短一點，大家就能看到你的名字了 恩對，這場 Lightning Talk 就真的是這樣而已 XD Lightning Talk - 3 Quick Tips for Software Blogging Set a Purpose Why do you want to blog? Publish info, guides, help Personal journalling /notes connect with others electronic biz card be self-motivated Don't become famous make money from ads Write new, helpful content Don't repeat existing content. Make something new! Tools and Platforms Don't Matter (Content matters) Day 3 Keynote - Python Steering Council 現在的 Python 政府討論 Python的過去與未來 Python Governance PEP 8000 PEP 13 Q: Where to start to become a core dev? Python Developer's Guide Keynote - Nina Zakharenko - Light up you life with Python & LEDS! 現場 Demo MicroPython ，如何用 Python 操控硬體 我想這場主要是想展示用 Python 能很簡單地做到一些原本想像中可能會比較困難的事 Watch List 我跟在 PyCon 認識的朋友整理了一些之後會想補帶的 talk API Evolution the Right Way The Zen of Python Teams Releasing the World's Largest Python Site Every 7 Minutes Time to take out the rubbish: garbage collector Getting Started Testing in Data Science Escape from auto-manual testing with Hypothesis! Ace Your Technical Interview Using Python Migrating Pinterest from Python2 to Python3 Scraping a Million Pokemon Battles: Distributed Systems By Example Practical decorators Break the Cycle: Three excellent Python tools to automate repetitive tasks Open Space 畢竟 talk 都會錄影，而且很快就上傳了（大概結束後兩天就會上傳） 所以後來我就越來越常去 Open Space 而且相較之下 Open Space 會比較有跟人互動的機會 除了一些比較技術性的討論外 也會有不少娛樂性的 Open Space（通常在晚上） 像這個就是揪團要一起看 Game of Throne XD 大部分討論性質的 Open Space 會像這樣圍成一圈 這是我去參加 Vim 討論會的照片 當天就有人分享了討論的筆記 ( Vim BoF @PyCon2019 ) 我還有參加到一場幫忙做履歷健檢的跟討論 Tech Interview Job Fair / Poster Job Fair 主要就是跟各個公司聊天，看看他們的工作性質跟開了什麼缺 有聽到幾間 remote 的公司還蠻有趣的 不過其實也不用等到 Job Fair 才問 Job Fair 的公司反而比較少，不過應該就是專注在有開缺的公司 前幾天的攤位反而更有機會聊聊 Poster 也是一個能跟人互動蠻好的機會 不過那些比較有趣的，通常旁邊都會圍著一群人 XD Hypothesis 好像整個 session 人都沒少過 （話說 Hypothesis 還真的從 talk, tutorial, sprint 到 poster 每個場合都出現了） Development Sprint 自從上次在 PyCon TW 參加了 PyBee 的 Sprint ，就覺得這樣一群人協作開源專案很有趣 所以這也是我這次 PyCon 幾乎最期待的活動 在 Development Sprint ，開源專案的作者會帶自己的專案找大家一起來協作 沒有帶專案來的人就可以看自己對哪個有興趣加入貢獻 參加 Development Sprint 是貢獻開源專案還蠻好的入門方式 畢竟原作者跟 core contributor 就在旁邊 有遇到什麼問題想問馬上就可以問 我這次參加了 pallets , cpython , pybee , OpenEdx 的 Sprint 每一個專案，我在最後都有提交至少一個小 PR 這次最有成就感的大概就是成功提交了一個 flask 跟 cpython 的 PR （雖然 cpython 的其實還在 review 中） 這幾個專案之中，我覺得 pybee , OpenEdx 算是最新手友善的 Sprint 的這幾天還蠻常看到 Guido 在走廊走來走去 也蠻多人去找他搭話跟拍照的 不過害羞的我就有點不敢過去了 QQ 記錄一下這四天丟了哪些 PR pallets Pull Request Fix MethodView inheritance Error (#3138) #3179 Beeware Pull Request Fix the CAPSLOCK typo in toga_cocoa #679 Fix open file not working when using open command and double click files #686 Fix the error that UP arrow won't go the previous page #28 CPython Project Python Developer's Guide The Ultimate Guide to the CPython Source Code Pull Request (not yet merged) bpo-36841: Supporting customization of float encoding in JSON OpenEdx Project Contributing to Open edX open edx slack openedx-slack-invite.herokuapp.com Sites powered by Open edX Pull Request Add pull upstream reminder in contribute INCR-236 給自己下次去的建議 多跟人交流、多跟人交流、多跟人交流 這是我感受到跟在台灣參加研討會最不一樣的地方 （也可能是我在台灣的研討會都在舒適圈中...） 只要你願意，在會場中幾乎每個人都很樂於跟你交流 可能你只是站在一個桌子上吃早餐，就會有人過來跟你聊聊 這個體驗真的蠻有趣的 練好英文口說 原本覺得自己英文程度雖然稱不上好，但應該也沒到太差吧 至少在旅行上是沒遇過什麼問題 但這種程度跟要跟人討論或聊天還是差太多了 當然要說點話是沒什麼問題，但要流暢表達自己就還是蠻困難的 一對一的聊天還算勉強有辦法 到了團體討論就真的很吃力 光在聽力上要跟上大家在討論的就有點辛苦 就更不用說要加入討論了 剛到 PyCon 的前幾天對於這件事還真的蠻挫折的 準備好一段短的招呼語跟自我介紹 一開始有人來找我聊天，還是會有些緊張，不知道要說什麼 畢竟在台灣真的也沒什麼這樣練習英文口說的機會 後來多跟幾個人聊過後 自然而然就形成了一套跟人開頭的招呼語跟自我介紹 之後話題就能比較順利地一直接下去 留點緩衝時間給調時差 這次到美國的隔天就已經要開始 PyCon 了 一到了傍晚就會開始想睡 所以前幾天的 After Party 我參加一下就走了 後來也沒去參加 Facebook 一來是我也有點不知道怎麼在這種場合應對 二來是真的太累了... 保留體力 - 不用每個活動都參與到 剛來的時候會覺得，都花了這麼多錢特地跑來，一定要把握時間每 就會勉強自己盡可能每個時段都要塞滿 但 PyCon 的 talk, open space and etc. 實在太多了 真的要塞滿，體力就有點負荷不來，後來就都是邊睡邊聽...... 中間可以留一些時間在 Quiet Room 稍微休息 與其多衝一些場數，不如專注地把幾場真正想聽的專心聽完 多去 Open Space 相較於 talk ， Open Space 除了沒有錄影可以補帶以外 也是一個跟人們可以更有互動的機會 有時候說不定也能聽到一些不能在 talk 說的事（笑 而且我覺得在這應該是蠻有機會交到一些朋友的場合 （雖然我後來認識的大多是在走廊上或吃飯遇到的 XD） 事前對有興趣的 talk 準備好想問的問題 雖然說看現場的感受跟看影片還是不一樣 但既然都去聽了，如果能跟講者討論自己遇到的問題，應該會更有收穫 將當下的熱情紀錄下來，並列出 action items 參加的當下的感受還蠻強烈的，但回來台灣好一段時間後 當初的熱情跟想法，就會慢慢被生活給磨光 所以立刻把明確的 action items 記錄下來，也許會讓這些事情成真的機會高一點 寫下這篇文章，某種程度上也是想記錄下這次參加的感受呢 食物 （20190703 update） 既然有人問了，就來補充一下吧 XD 首先是從 Tutorial 開始到 Sprint 結束的九天 每天都有星巴克可以喝 雖然到 Sprint 的時候好像已經把經費花光 臨時又有廠商在贊助才能撐到結束 議程以外那幾天大多是自助式 大概都是這樣的沙拉 議程那幾天就有點像是餐盒 有豬、牛、素、水果幾種可以選 像這個就是牛排，吃起來就還不錯 這個也是牛排 但吃起來很可怕...... 上面那個餅皮我真的努力要吃過了，但我失敗了＠＠ 這是我待在美國這一個月最難吃的食物...... 恩，大概就只有這樣xD 雜談 一開始對於要不要飛一趟去美國還蠻猶豫的 畢竟 PyCon 的 talk 網路上都看得到，花這一大筆錢真的值得嗎？ 而且自己一個跑到一個人生地不熟的地方也是挺可怕的 其實這些問題我到最後也沒給自己一個好的答覆 反正就覺得現在如果不衝動地做這件事，也許就不會有下次了 就毅然決然的買了機票跟門票 逼得自己沒有退路，一定得要去 以結論來說，我覺得非常值得 而且如果有可能，我明年還是會想去 PyCon 2020 in Pittsburgh 在 PyCon 體驗到一些我在台灣比較不會接觸到的事 平常也許可以看看文章，聽別人說說這些故事 但這跟實際現場的體會真的太不一樣了 最大的感受是「那些原先覺得做不到的事，似乎變得不再那麼遙遠」 當然我在美國其實待了一個多月，也是去了不少地方 說不定哪天有空也會寫篇遊記 這篇快速整理了一下我現在想到的，也許之後還會再補點內容","tags":"Tech","url":"https://wei-lee.me/posts/tech/2019/06/how-was-pycon-us-2019","loc":"https://wei-lee.me/posts/tech/2019/06/how-was-pycon-us-2019"},{"title":"[Book] OKR 做最重要的事","text":"Ch2 - OKR 之父 「目標」和「關鍵結果」 目標就是方向 e.g., 我們要主導中檔微電腦元件市場 關鍵結果是里程碑，必須明確可測量 e.g., 替 8085 贏得10款新設計 葛洛丈博士的 ORK 要訣 少就是多 由下而上設定目標 不強制規定 保持彈性 敢於失敗 工具而非武器 要有耐心，也要堅定 Ch4 - 超能力 1: 專注投入優先要務 與目標配合的關鍵結果，應強調工作品質 e.g., 產量目標： 三項新功能 品質目標： 品保測試中，每項功能少於五個錯誤 Ch 10 - 超能力 3: 追蹤當責 追蹤、審視 OKR 時，可以採用的選項 繼續： 處於綠燈區（進度符合預期），不需調整 更新： 處於黃燈區（需要關注），視流程或現實狀況調整時間和資源 啟動： 隨時可以依需要啟動一組新的 OKR 終止： 處於紅燈區（「處於危險中」）且目標不再有用，應直接放棄 總結 OKR 時，可以思考的問題 是否全部達標？ 如果是，哪些因素貢獻良多？ 如果不是，遇到了什麼障礙？ 如果重設一項可以完全達成的目標，應該如何修改？ 學到哪些教訓，可以改變下一週期 OKR 的做法？ Ch 15 - 持續性績效管理: OKR 與 CFR CFR (Conversations, Feedback, Recognition) 主管與部屬對話涉及的五個關鍵面向 設定目標和反省 了解最新進度 互相指導 事業發展 輕量的績效考核 附錄一 - Google 的 OKR 攻略 目標代表 What ，應該要 表達目標與意圖 進取但可行的 實在、客觀且明確 成功達成的目標必須提供明確的價值 關鍵結果代表 How ，應該要 表達可衡量的里程碑，一旦實現將有利於達成目標 必須描述結果而非活動 必須含有完成工作的證據，且必須可取得、可信和容易發現 e.g. 變化清單、文件連結、筆記以及已公布的指標報告 如何判斷 OKR 好不好 只花五分鐘寫下的 OKR → 很可能不好 目標無法一行寫完 → 不夠簡潔 關鍵結果只能用團隊內部術語表達 → 不夠好 e.g., 推出 Foo 4.1 → 推出 Foo 4.1 以提高註冊率 25% → 提高註冊率 25% 寫下真實的日期 如果每一項關鍵結果，都發生在一季的最後一天，很可能沒有切實可行的計畫 確保關鍵結果是可衡量的 e.g., 提高註冊率 → 5月1號前提高註冊率 25% 確保指標是不含糊的 如果寫下來的 OKR 未涵蓋團隊努力中相當顯著的部分，則需要再添加一些 OKR","tags":"Book","url":"https://wei-lee.me/posts/book/2019/06/measure-what-matters","loc":"https://wei-lee.me/posts/book/2019/06/measure-what-matters"},{"title":"SITCON 2019","text":"SITCON 都過了兩個禮拜 好不容易才騰出個時間整理一下想法 想想去年的 X-Village 的想法也一直還沒好好寫完 兩個禮拜似乎也不算太久（？ 不過這次在 SITCON 的分享也算是把 X-Village 的想法都整理起來了 就當作整合進這篇吧 xD 第一次站上中研院的舞台 這是我第一次以講者的身份站在中研院的台上 主要分享去年 X-Village 辦課程的經驗 不過不出意外的，這樣的議題大家不會太感興趣 XD 而且同時的 R0 又很精彩 如果我不是這場的講者，我應該也會去聽吧 原本不想花太多時間，就只投了十分鐘的 Espresso 不知道是不是我的介紹看起來好像內容很多 就被問要不要改成 40 分鐘的 Presentation 了 既然都被問了，那就來挑戰看看吧 只是很不幸的 我的工作就在 SITCON 錄取我後開始忙碌起來 一直都沒時間好好準備簡報 我的第一版簡報甚至要到了台南試講的前一兩個小時才做完 原本想說彩排前還有兩個禮拜可以改 但我還是一直忙到前幾天才有時間好好改... 這才親身體會到，直到要講的前一天才弄簡報不是傳說啊 xD 工程師真是沒看到死線就不會覺悟（笑 所幸不管是試講還是彩排，我應該都講得還不算太差 至於議程當天 除了人不太多以外，一切都還蠻順利的 時間掌握上，也比我想像得順利得多 雖然現場沒人提問，Sli.do 倒是有不少人留下問題 不過問我 Python 問題的人大概就佔了一半 xD 我想是因為我開頭就介紹了我是 Python 的信徒吧 xDD 這次會想來當講者 主要就是想訓練自己公開演說的技能 總覺得好像好一段時間都沒有點這項技能了 也想讓去年累個半死辦的 X-Village 有多一點人看到 即使我們的經驗中有很多錯誤的嘗試 還是希望有人多少能從中帶走一些什麼想法，讓下一個這樣的資訊教育辦得更成功 如果沒參加到我的議程，對我的內容有興趣的話 我有把我的簡報公開出來，我也在會後把 Sli.do 上的問題都回答完了 我應該算還蠻認真的講者吧 xDD 之後沒忘記的話，我應該也會把錄影補上來 Slide 共筆 身為會眾 比起之前參加的幾場 SITCON 這次應該是我參加的議程最少的一次 大概有一半的時間都在外面的攤位閒晃 xD 倒是 R2 的三場 Espresso 都聽了 每一場的內容跟表達方式都很有趣 當然每年還是要參與一下編輯器大亂鬥 今年終於不再是 vim 跟 emacs 互鬥，然後還把對方擦掉了 xDD 講者晚宴 這也是這次 SITCON 我蠻期待的一個活動 難得有機會能這樣子跟各路大神交流 不然每次參加 conference ，好像都沒有交到新朋友 當然也有可能只是我太邊緣了 大家真的都好早就開始碰程式了 同桌之中，最老的就是我ＱＱ 最年輕也有國高中的講者呢 相比他們，我國高中的時候沒有什麼特別的想法 只是跟著大家認為正確的升學道路走 甚至高中還蠻討厭寫程式的呢 沒想到最後竟然還是走上了程式這條路 出來混，早晚還是要還的嗎xD","tags":"Tech","url":"https://wei-lee.me/posts/tech/2019/04/sitcon-2019","loc":"https://wei-lee.me/posts/tech/2019/04/sitcon-2019"},{"title":"[Note] Effective Python","text":"第二次看過終於有辦法把原本看不懂的部分都看懂了 那些看不懂的大多是很抽象化的技巧 但是啊，看懂了這些語法 現在的我還是沒有能力，將這些抽象化應用在我自己的程式中 不過其他大部分比較簡單的在看過一次 還是提醒我在每一個眉眉角角都還要再更注意 上次看過的還沒有全部都應用到我寫程式的習慣中呢 第一章： Pythonic 思維 作法02： 遵循 PEP8 風格指南 PEP8 (我只把我認為容易被忽略或特別重要的幾點留下來) Whitespace 過長的 expressions 要接續到其他文字行時，除了原本的縮排層次，應再加上額外的 四個空格 來縮排 Naming protected instance attributes → _leading_underscore private instance attributes → __double_leading_underscore Class, exceptions → CapitalizedWord model-level constant → ALL_CAPS Statements 使用行內否定 (inline negation, e.g., if a is not b )，而非否定正向的運算式 (negation of positive expressions, e.g., if not a is b ) 別用查驗長度的方式 ( if len(somelist) == 0 ) 來檢查空值。使用 if not somelist 避免單行 if , for , while , except ，將它們分多行描述以清楚表達 import module 永遠用絕對名稱 e.g., 用 from bar import foo 而不是 import foo import 順序 standard library modules third-party modules your own modules 用 pylint 來檢查風格 作法04： 撰寫輔助函式而非複雜的運算式 將複雜的運算式移到輔助函式 (helper function) 內，特別是在你需要重複用到同樣的邏輯的時候 與其在運算式中使用 or 或 and ，不如使用 if/else 讓程式碼更易讀 my_values = { 'red' : [ '5' ], green : [ '' ] } # or, and red = int ( my_values . get ( 'red' , [ '' ])[ 0 ] or 0 ) # if/else red = int ( red [ 0 ]) if red [ 0 ] else 0 # even better if/else if red [ 0 ]: red = red [ 0 ] else : red = 0 # helper function def get_first_int ( values , key , default = 0 ): found = values . get ( key , [ '' ]) if found [ 0 ]: found = int ( found [ 0 ]) else : found = default return found red = get_first_int ( my_values , 'red' ) 作法05: 知道如何切割序列 省略 zero index, 最後的索引來降低視覺雜訊 用 a[:5] , a[5:] 而不是 a[0:5] , a[5:len(a)] copy value v.s. copy reference # copy value b = a [:] assert b == a assert b is not a # copy reference b = a assert b is a 作法07: 使用 list comprehension 而非 map 和 filter 避免用 map , filter ，因為使用他們時需要建立一個 lambda ，這是種視覺雜訊 a = [ 1 , 2 , 3 , 4 , 5 ] # list comprehension squares = [ x ** 2 for x in a ] # map squares = map ( lambda x : x ** 2 , a ) 作法09: 考慮使用 generator 取代大型 list comprehension 對於大型輸入來說 list comprehension 可能耗用相當大量的記憶體 作法11: 使用 zip 來平行處理 iterables a = [ 1 , 2 , 3 , 4 ] b = [ 'a' , 'b' , 'c' , 'd' ] # without zip for i , x in enumerate ( a ): print ( x , b [ i ]) # with zip for x , y in zip ( a , b ): print ( x , y ) 如果提供了不同長度的 iterables ， zip 會 truncate 掉較長的 input 作法12: 避免在 for 或 while 後面使用 else 區塊 # avoid for i in range ( 3 ): ... else : ... 作法13: 善用 try/except/else/finally 中的每個區塊 finally 即使例外發生，但也想要在例外發生時執行清理用的 cleanup code else 如果 try 沒有丟出例外， else 區塊就會執行 用來最小化 try 區塊的程式碼量 → 讓 try 區塊只出現會丟出例外的程式碼 第二章： 函式 作法14: 優先選用例外處理而非回傳 None 回傳 None 帶有特殊意義的函式容易出錯，因為 None 與其他的值 (e.g., 0 , [] , '' )，在做條件運算式運算的結果都是 False 作法20: 使用 None 與 Docstrings 來指定 mutable default arguments default arguments 只會被 evaluate 一次：模組載入時、函式定義時。對於動態值 (e.g., {} , [] ) 來說，這可能導致奇怪的行為 from datetime import datetime def func ( default = datetime . now ()): print ( default ) # The two results would be the same but should be different func () func () Fix from datetime import datetime def func ( default = None ): \"\"\"Demonstration Args: default: current datetime \"\"\" if not default : default = datetime . now () print ( default ) 作法19: 以 keyword argument 提供選擇性的行為 (Related to 作法21) # original def flow_rate ( weight_diff , time_diff , period ): return ( weight_diff / time_diff ) * period # with default argument def flow_rate ( weight_diff , time_diff , period = 1 ): return ( weight_diff / time_diff ) * period 不像「作法21」全面採取 keyword argement的原因是為了達到 backwards compatibility 作法21: 強制使用僅限 keyword argument 來讓程式碼更清楚易懂 使用 keyword-only arguments 來強制要求呼叫者提供 keyword argument 以避免混淆，特別是在接收多個 Boolean flag 的函式中 # * indicates the end of positional arguments def safe_division ( number , divisor , * , ignore_overflow = False ): ... 第三章： 類別與繼承 作法22: 優先選用輔助 class 而非使用 dictionary 或 tuple 來管理紀錄 如果還不需要用到較有彈性的完整 class，請使用 namedtuple 來製作輕量化、不可變的資料容器 namedtuple 不能指定預設引數值，如果資料有許多 optional properties，則還是適合用 class 作法25: 使用 super 來初始化父類別 class Implicit ( BaseClass ): def __init__ ( self , value ): super () . __init__ ( value * 2 ) 作法27: 優先選用公開屬性而非私有屬性 為什麼私有屬性的語法不強制施行嚴格的可見性限制呢？ We are all consenting adults here. 選擇私有屬性，只會讓子類別的 overrides 或 extensions 動作變得更麻煩更容易出錯 一般來說最好選擇使用 protected attributes 唯一得認真考慮使用 private attributes 的時機，是擔心子類別會有名稱衝突的時候 第四章： 元類別與屬性 作法33, 34, 35 Metaclass 的應用 驗證 subclass 是否有被正確定義 註冊 class 的存在 在一個 class 被實際使用前，修改其特性 第五章： 共時與平行處理 共時 (concurrency): 作業系統會在單一處理器快速切換多個執行程式 平行處理 (parallelism): 真正在同一時間執行許多工作的處理方式 作法38: 使用 Lock 來避免執行緒中的 data race class Count : def __init__ ( self ): self . count = 0 def increment ( self , offset ): self . count += offset 如果用 thread 去跑 increment 會造成 data race 原因是 counter . count += offset 實際上執行了三個 operation 等效於以下的程式碼 value = getattr ( counter , 'count' ) result = value + offset setattr ( counter , 'count' , result ) 這時候必須在 increment 加上 Lock 避免 data race class LockingCounter : def __init__ ( self ): self . lock = Lock () def increment ( self , offset ): with self . lock : self . count += offset 作法39: 使用 Queue 來協調執行緒之間的工作 from queue import Queue queue = Queue () def consumer (): print ( 'consumer waiting' ) queue . get () print ( 'consumer done' ) thread = Thread ( target = consumer ) thread . start () print ( 'Producer putting' ) queue . put ( object ()) thread . join () print ( 'Producer done' ) 作法41: 考慮使用 concurrent.futures 來達成真正的平行處理 from concurrent.futures import multiprocessing 藉由執行額外的直譯器作為 child processes。因為這些 child processes 跟主直譯器是分開的，所以它們的 GIL 也是分開的 使用 multiprocessing 的成本很高 因為 main process 和 child processes 的溝通需要透過 serialization 和 deserialization multiprocessing 適合 isolated: 不必與程式其他部分共用狀態的 function high-leverage: 在 main process 和 child processes 只需要轉移少量的資料，就能進行大量計算的狀況 multiprocessing 最好只用到 concurrent.futures 的 built-in module 和 ProcessPoolExecutor class 其他部分過於複雜，建議避免 第六章： 內建模組 作法34: 考慮使用 contextlib 與 with statement 來建立可重用的 try/finally 行為 from contextlib import contextmanager @contextmanager def log_level ( level , name ): logger = logging . getLogger ( name ) old_level = logger . getEffectiveLevel () logger . setLevel ( level ) try : yield logger finally : logger . setLevel ( old ) with log_level ( logging . DEBUG , 'mylog' ) as logger : logger . debug ( 'This is my message!' ) logging . debut ( 'This will not print' ) yield 前是 contextmanager 的 __enter__ 會執行的部分，之後則是 __exit__ 作法45: 本地時鐘使用 datetime 而非 time 搭配 pytz module 來使用 datetime built-in module 在不同時區的時間之間作轉換 處理過程中，永遠用 UTC 來記錄，呈現給使用者前才轉換 第七章： 協作 作法49: 為每個 function, class, module 撰寫 Docstrings General Docstring Guide 用3個 double quotes ( \"\"\" ) 開頭 第一行應該是單一句子，來描寫用途 接下來的文字含有使用者應該知道的作業細節 class 將重要的 public attribute 和 method 在 class level 的 docstring 寫出 public function / method 寫上 function 的特殊行為, argument 和 return value 如果沒有 argument, return value，單句描述應該就夠了 如果不會回傳任何東西，就不要提到 return value，而不是寫 \"return None\" 如果有用到數目不定的 argument , keyword-argument，應該用 *args , **kwargs 來描述 如果有 default argument 都應該被提及 如果是一個 generator，應該描述 iterate 時會 yield 什麼 如果是 coroutine，應該描述 會產生什麼 預期從 yield 收到什麼 什麼時候會停止 作法50: 使用 package 來組織 module 並提供穩定的 API Python 可以透過 module 或 package 的 __all__ 特殊屬性來限制要暴露給 API 使用者的「表面積」 如此即使重構也不會影響到使用者 這在提供明確、穩定、給外部使用的 API 是個很好的做法 如果只是在建置自己 module 間使用的 API 則是應該避免的做法 盡可能使用 from x import y ，而不是 import * import * 可能造成變數名稱複寫，而且不容易被 debug 作法51: 定義一個 root exception 來隔離呼叫者與 API 為什麼要自定義一個 root exception? 讓使用者知道他們以錯誤的用法使用了你的 API 幫助你找出 API 中的 bug → 只要不是提出這些自定義的例外，就很可能是 bug 的所在 作法52: 知道如何打破循環依存性 最好的做法是重構程式碼 但有時候清楚的劃分相當困難，或 cost 太高了，因此還是需要知道如何打破循環依存性 解法一： 重新安排匯入順序 這是一個比較不好的做法，違反了 PEP 8，且容易讓程式碼稍微的修改就造成問題 解法二： import, configure and execute 讓 module 只作定義 function, class 和 constant，不做實際執行 每個 module 提供一個 configure 函式，讓所有 module 都完成匯入後才呼叫 許多狀況下都能運作良好，並且讓 dependency injection 變得可能 缺點 很難重新組織程式碼架構 因為物件的定義和 configuration 在不同的地方，造成程式碼更難閱讀 解法三： 動態匯入 通常是最簡單的解法 在 function/method 中才使用 import 但一般來說來是最好避免， import 的 cost 並沒有小到可以被忽略 第八章： 推出產品 作法57: 考慮使用 pdb 來進行互動式除錯 在程式碼加入以下這行，就能讓程式執行到這一步時停下，開啟互動式的 python shell python import pdf; pdf.set_trace() 檢視執行中的程式 bt : 印出目前 call stack 的 traceback up : 上移 call stack down : 下移 call stack 恢復程式的執行 step : 執行程式，直到下一行 next : 執行程式，直到遇到目前函式的下一行 return : 執行程式，直到目前函式回傳 continue : 執行程式，直到下一個 breakpoint 或 set_trace 再被呼叫 作法58: 最佳化之前先進行效能評估 使用 cProfile module 而非 profile module 因為對程式效能的影響較小 from cProfile import Profile from pstats import Stats # some program to test import test profiler = Profile () profiler . runcall ( test ) stats = Stats ( profiler ) stats . strip_dirs () stats . sort_stats ( 'cumulative' ) stats . print_stats () 作法59: 使用 tracemalloc 來了解記憶體用量或是否有洩漏 Python 的預設實作 CPython 中，記憶體管理的方式是使用 reference counting Python 3.4 以後可以使用 tracemalloc import tracemalloc tracemalloc . start ( 10 ) time1 = tracemalloc . take_snapshot () # some code that waste memory time2 = tracemallo . take_snapshot () stats = time2 . compare_to ( time1 , 'lineno' ) for stat in stats : print ( stat )","tags":"Tech","url":"https://wei-lee.me/posts/tech/2019/01/effective-python","loc":"https://wei-lee.me/posts/tech/2019/01/effective-python"},{"title":"[Book] 電腦玩物站長的筆記思考術","text":"去年剛看完這本書的時候，實在覺得跟想像的很不一樣 直到現在終於有空好好的再翻過一遍，做一些紀錄了 原本以為會是很明確的 xxx筆記法...如何在生活中實用之類的 不過這本書主要在講的「如何用記錄下來的東西帶起自己的行動」 至於怎麼做筆記（e.g., 什麼格式），就不是它的重點了 雖然跟原先期待的不一樣，但我反而蠻喜歡這樣的內容 尤其我自己也有一套反省、紀錄生活的方式 翻著它就感嘆「原來還能這麼做啊」xD 這本書大概不會是那種即刻有效的考試筆記術之類的 它所提的想法和技巧，都是需要時間慢慢融入自己的生活當中 但相信這些思考都會對如何管理自己的人生很有幫助的 一、筆記技巧 記錄過去是為了改變未來，試著思考這些問題 為什麼會這樣？ 我是怎麼想的？ 我想要變成怎樣？ 筆記有用與否的重點在於 「付諸行動」 筆記時，就要思考筆記怎麼使用 我可能怎麼利用它 我想利用它來達到什麼目的 筆記的三層思考空間 行動層 → 我的行動 我要採取什麼行動來改變 構思層 → 我的想法 (最精華的筆記內容) 當下的想法 列舉大綱 收集到的資料重點 封存層 → 我的紀錄 (雜亂但可能具有參考價值的思考過程和零散資料) 參考資料 DRAW 計畫筆記法 Destination 確認目標： 我想要達成的目標，達成是什麼樣的具體景象？ Roadmap 畫出路線圖 Action 列出行動步驟 Warnings 評估風險 建立觀點的筆記練習 「寫作輸出」可以加速學習與成長、訓練獨立思考 練習條列重點 抓出看到或想到的重點 用關鍵字句濃縮重點 條列重點，並思考重點的排序 跳開原文，嘗試用自己的話說明重點 找出原文沒提到的重點 練習窮舉範疇 從一個事件，思考背後的現象 窮盡現象背後所有的面相 幫這個現象做分類定義 練習分析追問 「為什麼...」, 「因為...」 對習以為常的結論，重新練習追問為什麼？ 練習翻轉想法 「如果... 會怎樣」, 「還有可能...」, 「為什麼不？」 不同的前提會導出不同的結論 → 練習以不同角度觀看同一件事 精煉過去的元經驗筆記 不只是寫下經驗了什麼，而是拆解出經驗背後的結構、規則 → 重複利用、方便組合的元經驗 → 累積自己的 SOP 清單 二、筆記整理 資料本身是死的，把它收納整理好，他更加無法行動 除非不是整理資料，而是納入真正行動的工作流程中 如果稍後閱讀違背了「好好讀完一篇文章」的本意，而變成「收集現在沒時間讀的文章」的工具，那長久下來就會變成一個問題「為什麼我總在沒時間讀的時候看文章？然後不斷收集沒時間讀的文章？」 整理是要處理，而不是收集用不到的東西 學習經驗背後的邏輯、方法，而非照著經驗的結果做 對於新工具先體驗，不需要搞懂 先試試看 透過多試錯理解工具或方法背後設計的意義 試錯後回頭看文章和說明更能理解上面的意思 → 體驗後，才能加快學習與研究 嘗試後開口問，才有辦法問出有價值的問題 三、時間筆記 時間管理不是完成所有事情，而是選擇重要的事情完成 處理壓力 承認有壓力，看到自己的困境 認知到壓力是情緒，不是現實 清空大腦的筆記法 讓煩惱「儲存在外部清單」，也讓期待可以被「客觀看見」 把雜事列成清單 整理清單，給雜事不同的權重與判斷 把焦慮和壓力，置換成下一步行動 克服拖延 列待辦清單時，之所以做不到，常常是因為我們寫下了「困難到我不想去行動」的任務 什麼時候不會有拖延? 很想做的事 簡單又立即有成效的事 ← 把下一步行動變得簡單又立即有成果 截止期限快到，而感到迫切的事 每日 135 專注法則 讓每天的代辦清單控制在這個數量以下 一件重要任務 三件中等任務 五件小型瑣事 訂定切合實際的目標，如果多餘的時間完成更多事，也能提升自己的成就感 每週重新上膛的子彈計畫 每個週末一個小時，做出下週行動清單 反省前一週的行動 不能只是記錄，而是找出問題，進而找到下週準備怎麼解決這個問題 清空大腦 檢查一遍下週行事曆 事先確認下週已經安排好的重點工作 從下週已安排好的部分，得知下週可運用的時間籌碼 決定下週行動清單 任務清單是一回事，決定要採取的行動清單才是重要的 下週有限的時間籌碼，要投注到哪些可以自我實現的標的物上？ 筆記如何幫你保持專注力 有效地專注方式 列好清單 挑選重要的事 拆解成可以立刻執行的步驟 常常無效的專注方式 排出長專注時間 挑選困難的事 跳過零碎時間 四、人生筆記 不問優缺點的 KPT 日記法 你需要看到的不是優缺點，而是下一次怎麼做會更好 KPT Keep: 歸納有哪些部分是下一次要繼續維持的 Problem： 找出哪些部分是這一次還有疑問的，下一次要解決 Try： 提出下一次可以改進的測試行動 並非構想真正的解決辦法，因為事實上我們通常不知道哪個才是最佳解法，唯有「先測試才知道」 用 KPT 進行個人反省日記 Keep: 覺得自己應該繼續維持的習慣 Problem: 反省可能有問題的某些習慣與步驟 Try: 思考如何解決問題的具體方法，並在下一次實際測試看看 建立你的技能學習系統 收集 有了念頭就收集起來，可以增加學習的可能性 行動 針對這個主題的學習，必須採取什麼行動 反省 記錄學習的過程，嘗試改進的行動 額外加上「下一次想要怎麼改進或變化」的待辦清單 把學習過程中的「最好成果」記錄下來 → 把最好的流程在反覆地看筆記練習中變成習慣 利用 讓大腦更開心的快樂筆記 記錄那些美好時光 當你的筆記本中，有這些讓人開心的筆記，那麼每次打開筆記準備開始工作時，會擁有更好的心情 待辦清單裡不要只有工作 在自己的時間排程中「有了生活的位置」，不再只是工作，把人生的主導權拿回自己手上 讓興趣真的被實踐，而不只是口頭說說 筆記不重要的事 寫下念頭：讓那些現在不做的事，以後有機會做 寫下想要擁有的經驗 寫下臨時的、想到一半的點子，期待它成長 寫下那些現在還無法回答的問題，記下來給未來的自己 寫下生活中的好事，讓筆記不沈重 寫下感動自己的方法或東西，累積自己的創意箱 相信自己可以改變 - 元經驗模式 常常檢視自己的習慣、行為模式 找出裡面其他可能性 用行動去「實驗」這些可能性 把更好的、獲得確認的可能性，變成自己的新行動 最後會發現自己原本沒有發現的新世界 每日不一樣的練習筆記 強迫不一樣的新發現 其實真的有很多豐富的選擇「已經存在」看似一成不變的生活中 只是我們容易被平常的慣性，或外在條件擔心害怕，而掉入了選擇的侷限","tags":"Book","url":"https://wei-lee.me/posts/book/2019/01/think-through-note-taking","loc":"https://wei-lee.me/posts/book/2019/01/think-through-note-taking"},{"title":"[Note] Clean Code","text":"既然都把 The Clean Coder 做完了 就順便把原本在 GitBook 的 The Clean Code 一起搬過來好了 Lee-W @ 2020-10-08 隔了兩年又再回來翻這本書 這次除了打算把後面的章節全部看完外，也會重新把筆記順過一次 第四次把前十章看完後，感到一些原本似懂非懂的概念，變得理所當然 但依然會對巧妙的地方感到讚嘆 第1章：無暇的程式碼 LeBlanc's Law: 待會而等於永不 待會兒再回來整理程式，等於讓程式一直限於髒亂 髒亂的程式只會讓開發速度更慢。 趕上期限的方法是隨時都確保程式儘可能的乾淨 What is Clean Code? 只做好一件事 可以被原作者以外的開發者閱讀與擴充的 Beck's rules for simple code 通過所有測試 沒有重複的程式碼 充份表達系統設計的構思 具有最少的 entities (e.g., class, methods, functions, and etc.) 每一次修改程式碼之後，都得讓程式碼變得比修改之前再更乾淨 童子軍原則: 每次你到過的營地，離開後要比之前更乾淨 第2章：有意義的命名 Variables, methods, classes 要能解釋他們為什麼在這、做什麼用和怎麼使用它 變數名稱要唸得出來 (e.g., genYMDHMS ) 較小的名稱如果能表達足夠的意義，通常比較長的名稱好，儘量減少再命名上不必要的文字 不要用變數型態作為變數名稱 e.g., accountList → accountGroup or accounts 要區別名稱，用 讀者能分辨的區別方式 ！！！ e.g., moneyAmount → money customerInfo → customer 命名的長度應該要與 scope 大小對應 一個常用到的變數或常數，最好給它一個容易被搜尋的名子 詞性 class, object → 名詞 method → 動詞 替單一的概念選一個詞 e.g., get, fetch, retrieve 混用是一件很糟的事 避免用雙關語，或可以表達兩個意思的字 e.g., 加入一個新的值 : add → append, insert 第3章：函式 寫一個好的函式有兩個守則 簡短 比簡短來得更簡短 準則 每行應該少於150字，函式應該少於20行 但最重要的是， 每個函式都要能清楚的告訴你本身的意圖，並帶領你到下個函式 別去害怕取較長的函數名稱 長但具描述性質 > 註解 > 短而無法理解 降層準則： 由上而下閱讀的程式 Don't repeat yourself at any cost!!! if , else , while 這些敘述最好都只有一行，而那行通常是函式呼叫 避免巢狀結構， 函式內的縮排不該超過一或兩層 函式應該只做好做一件事情 做一件事的函式不應該被合理的分成不同的段落 (e.g., 宣告區, 初始區... and etc.) 函式要能 做好某件事 ，或 回答某個問題 ，而這代表 兩者不該同時發生！！！ if ( set ( \"username\" , \"bob\" )) ...... // refactored if ( attrExists ( \"userName\" )) { setAttr ( \"userName\" , \"bob\" ); } 錯誤處理 用例外處理取代錯誤碼回傳 而錯誤處理是會混淆程式結構的，比較好的作法就是把 try catch 區塊提出來 if ( deletePage ( page ) == E_OK ) { if ( registry . deleteReference ( page . name ) == E_OK ) { if ( configKeys . deleteKey ( page . name . makeKey ()) == E_OK ) { logger . log ( \"page deleted\" ); } else { logger . log ( \"configKey not delete\" ) } } else { logger . log ( \"deleteReference from registry failed\" ) } } else { logger . log ( \"delete failed\" ); } // refactored try { deletePage ( page ); registry . deleteReference ( page . name ); configKeys . deleteKey ( page . name . makeKey ()); } catch ( Exception e ) { logger . log ( e . getMessage ()); } // even more refactored public void delete ( Page page ) { try { deletePageAndAllReferences ( page ); } catch ( Exception e ) { logError ( e ); } } private void deletePageAndAllReferences ( Page page ) throws Exception { deletePage ( page ); registry . deleteReference ( page . name ); configKeys . deleteKey ( page . name . makeKey ()); } private void logError ( Exception e ) { logger . log ( e . getMessage ()); } 參數 函式最好是不使用到參數，可以的話不要超過3個 除非有非常特殊的理由，否則都不該超過3個 別傳flag參數(e.g. isSutie)進入函式 ，那代表這個函式一定做超過一件事！！！ 單一參數函式 問與這個參數有關的問題 (e.g., fileExists(\"MyFile\") ) 對這個參數進行操作，並且 回傳 事件，利用參數去改變系統的狀態 2 ~ 3 個參數 注意參數順序性 利用建立物件的方式，減少函式參數的數量 Circle makeCircle ( double x , double y , double radius ); // refactored Circle makeCirecle ( Point center , double radiue ); 避免使用輸出型參數，這十分的讓人困惑 appendFooter ( s ); // refactored s . appendFooter (); 如何寫出這樣函式？？？ 一直修改和重構，直到足夠精簡 不用一開始就要寫到最精簡，實際上那也是辦不到的 第4章：註解 不要替糟糕的程式碼寫註解 ─ 重寫它！！！ 即使是適當的使用註解，也只是用來彌補程式碼表達意思的失敗 每次要寫註解時，先思考是否能 直接用程式碼表達 註解只應該描述附近的程式碼，不要在區域性註解內放入系統全域資訊 替只做一件事的小函式選一個好名稱，多半比將註解寫在函式標頭優雅 有用的註解 提供資訊的註解 //format matched kk:mm:ss EEE, MMM dd, yyyy Pattern tiMatcher = Pattern . compile ( \"\\\\d*:\\\\d*:\\\\d* \\\\w*, \\\\w* \\\\d*, \\\\d*\" ) 對後果的告誡： 警告會出現某種特殊後果的註解 TODO 公開 API 中的 Javadoc 糟糕的註解 大部分的註解 多餘的註解： 沒比程式碼本身透露更多資訊的註解 class Person () { # The name of this person private String name ; } 每個函式，每個變數都該有註解來說明 。 不，別這麼做 把暫時無用的程式碼註解掉並留著，是很惱人的 → 版本控制會幫我們記下它 第5章：編排 選擇一些簡單的縮排規則，並持續的運用它 如果在一個團隊，所有成員都該依循著一套統一的編排規則 團隊合作時，事先決定編排方式是值得的 該在哪裡放括號 縮排寬度多少 如何命名變數、類別、方法 編排是一種溝通方式，可以嚴重影響可讀性，所以我們要很重視它 垂直邊排： 一份程式檔大概多長比較好？ 一份重要的大型專案也可以在大多數程式檔都只有200行左右的情況下完成 這沒有硬性規定。但要知道 簡短的程式檔總是比大型的程式檔容易理解 變數應該被宣告在接近它被使用的地方 區域變數應該在函式的最上方被宣告 迴圈的控制變數應該在回圈敘述內宣告 函式間的編排 如果一個函式呼叫了另一個函式，這個函式最好放在被呼叫函式的上方 概念高度相似的函式也應該垂直的放在一起 也許是類似的命名或相同工作的變異版本，就算沒相互呼叫，還是應該放在一起 談到了垂直的寬度後，那水平的寬度呢? 雖然我們喜歡較短的程式碼，但只要是 不需要用到捲軸捲到右方就可以稱為適當的寬度 有時候if, while或簡單的函式，可以被縮減為一行，讓我們違反一般的縮排規則， 不建議這麼做 public String render () throws Exception { return \"\" ;} //better public String render () throws Exception { return \"\" ; } 使用空行、空白 每一段程式碼都代表一個完整思緒，而我們用空行來區隔它們 而如果程式碼們是相關的，它們就該是垂直緊密的 相似的概念應該要放在同一份檔案中 我們用水平的空白來區分高度和低度相關的概念，也可以作為強調用，下面的程式碼是書中一個很棒的例子 注意到return那行，這裡用空格來強調運算子的優先權 public class Quadratic { public static double root1 ( double a , double b , double c ) { double determinant = determinant ( a , b , c ); return ( - b + Math . sqrt ( determinant )) / ( 2 * a ); } ...... } 第6章：物件及資料結構 資料結構容易新增函式，而物件容易增加新類別。 反之亦然 模組不該知道它操作的物件的內部操作 別使用一連串的程式呼叫 final String outputDir = ctxt . getOptions (). getScratchDir (). getAbsolutePaty (); //refactored Option opts = ctxt . getOptions (); File scratchDir = opts . getScractchDir (); final String outputDir = scratchDir . getAbsolutePath (); 第7章：錯誤處理 例外處理應該要能提供 有用的錯誤訊息 ， e.g, 哪裡發生錯誤、錯誤型態是什麼 別回傳 null，試著拋出例外事件是更好的作法 函式回傳 null 已經夠糟了，但傳遞 null 進去更是糟糕透頂 Wrapper: 從呼叫者的角度定義例外class -> 減少依賴 Wrapper Example // original ACMEPort port = new ACMEPort ( 12 ); try { port . open (); } catch ( DeviceResponseException e ) { reportPortError ( e ); logger . log ( \"Device response exception\" , \"e\" ); } catch ( ATM1212UnlockedException e ) { reportPortError ( e ); logger . log ( \"ATM1212UnlockedException\" ); } catch ( HMXError e ) { reportPortError ( e ); logger . log ( \"Device response exception\" ); } finally { ... } // refactored LocalPort port = new LocalPort ( 12 ); try { port . open (); } catch ( PortDeviceFailure e ) { reportPortError ( e ); logger . log ( e . getMessage , e ); } public class LocalPort { private ACMEPort innerPort ; public LocalPort ( int portNumber ) { innerPort = new ACMEPort ( portNumber ); } public void open () { try { innerPort . open (); } catch ( DeviceResponseException e ) { throw new PortDeviceFailure ( e ); } catch ( ATM1212UnlockedException e ) { throw new PortDeviceFailure ( e ); } catch ( GMXError e ) { throw new PortDeviceFailure ( e ); } } } 第8章：邊界 學習型測試： 不在產品程式（production）裡實驗新的東西，而是另外寫測試程式，來了解第三方軟體 學習型測試不會花太多額外時間（因為原本就要研究 API），而且能用來 確認第三方軟體是否能照我們預期的執行 如果沒有這種 邊界測試 來減輕版本更新時的整合負擔，我們 只能一直停留在舊的版本 避免我們的程式過度的使用第三方軟體的特殊之處，最好是依靠在可以控制的程式之上。免得到最後反而受到第三方軟體的控制 使用尚未存在的程式（e.g., 尚未開定義好） 自行定義介面，並用 adapter 封裝與 API 的互動 額外的好處是如果 API 升級，也只需要改動 adapter 第9章：單元測試 為什麼要寫測試？ 測試讓程式保有彈性 不用怕修改程式會造成程式結果不如預期 測試程式跟產品程式一樣重要，一樣需要整潔 可讀性 造就了整潔的測試程式 但是測試程式並不需要產品程式一樣的有效率 整潔測試程式的 5 個原則 F.I.R.S.T. Fast: 能快速的被執行 Independent: 測試程式不該相互依賴 Repeatable: 可以在任何環境重複執行 Self-Validating: 輸出 boolean ，你不該手動比較兩個檔案才知道有沒有通過測試 Timely: 單元測試要在恰好能使其通過的產品程式 之前 不久撰寫 BUILD-OPERATE-CHECK 建立測試資料 操作測試資料 檢查「操作測試資料」後的結果是否如預期 一個測試只能有一個assert → 一個測試只測試一個概念 TDD (Test Driven Development) 三大法則 在撰寫一個單元測試前，不可撰寫任何產品程式 只撰寫剛好無法通過的單元測試，不能編譯也算無法通過 只撰寫剛好能通過當前測試的產品程式 第10章：類別 Java的慣例 類別以變數開頭 public static final → private static → private >>>>> public (幾乎很少有理由要用到) public 函式緊跟在變數 private 的工具函式，會跟在呼叫它的函式後 不用過度執著於封裝，有時候為了讓測試程式存取， protected 是必要的 設計程式時，一次只專注在「讓程式運作」或「讓程式整潔」之一，而兩者是同樣重要的 系統應該要由很多小的 class 組成，而不是少數的大 class 組成 我們架構的系統，在未來想新增或修改功能時，應該要儘可能不動到其他程式碼 開放閉合原則 ： 類別應該要對擴充有開放性，對修改有封閉性 相依性反向原則 ： 類別應該要相依於抽象概念，而不是相依在具體細節 職責 class 除了簡短還是要簡短 在函式計算行數，class算的是 職責的數量 class的命名要能足夠描寫他的職責 如果無法取個明確的名稱，這個 class 可能就太大了 模稜兩可的名稱，代表 class 可能包含愈多的職責，而這是我們不希望的 用 25 個字詞為這個 class 寫出簡短的描述，而不使用到模糊的字眼，這樣的 class 就是職責數量恰當 單一職責原則 ： 一個 class 或 module 應該有也只能有一個修改的理由 凝聚性 class 只應該要有少量的實體變數， class 的每個方法都應該操作一個或更多這些變數 不用也不太可能產生最大凝聚性類別 但當凝聚性增加，就代表方法和變數結合成一個邏輯的整體，這是我們所希望的 class 累積越來越多實體變數，但只有少數函式操作著他們，就會開始喪失凝聚性 而這就是應該拆開 class 的時候了！！！ 不用重新撰寫程式，而是應該改變它 先寫好一套驗證的測試程式，一次一個地改變 每一次變動都重新驗證是否如預期執行 重構完成","tags":"Tech","url":"https://wei-lee.me/posts/tech/2018/11/clean-code","loc":"https://wei-lee.me/posts/tech/2018/11/clean-code"},{"title":"[Note] The Clean Coder","text":"過了幾年又重新看過這本書才慢慢能感受到裡面說的 Uncle Bob 的書真的每個階段看都會有很不一樣的感覺 很值得買回來收 xD 幾年前第一次看這本書的時候 寫程式大多只是交作業，頂多就跟其他的同學一起交大一點的作業或開發一些小專案 能不要被雷（或不要雷別人）就很不錯了 當時記錄下的摘要也就沒什麼內容（ [Book] Clean Coder ） 到了現在。加減算是做過稍微大一點的專案，也帶過一些小專案 重新看過這本書，就慢慢理解了一點 Uncle Bob 想說的 關於本書 什麼是軟體專業人士？ 軟體專業人士如何行事？ 軟體專業人士如何處理衝突，「應對」緊湊的開發進度表？如何和不切實際的管理人員打交道？ 軟體專業人士何時應該說「不」？怎麼說？ 軟體專業人士如何「應對」壓力？ 第一章：專業主義 擔當責任 專業人士如果犯了錯，只好 自己 收拾殘局 專業主義就代表著 「擔當責任」 你說的沒錯。軟體發展太複雜了，不可能沒什麼Bug。但很不幸，這個理由並不能為你開脫。人體太複雜了，不可能完全理解，但醫生仍誓言不傷害病人。如果他們不拿人體的複雜性做託辭，我們又怎麼能拿上述理由，開脫自已的責任呢？ 程式難免出現 bug ，但這不意味著你不用對他們負責；沒人能寫出完美的軟體，但這不代表你不用對不完美負責。 每次 QA 找出問題時，或者更糟糕的是「用戶找出問題」時，你都該震驚羞愧，並決心以此為戒。 自動化測試 寫一些隨時都能執行的「單元測試」，然後盡可能地多執行 要測試多少程式碼呢？ → 當然是全部！全部都要測！ 但有些程式碼不是很難測嗎？ 沒錯。但之所以難測，是因為設計時沒考慮如何測試 唯一的解決辦法就是要設計 「易於測試的程式碼」 結構 想證明軟體易於修改，唯一的辦法就是「做些實際的修改」 如果發現這些修改不如想像中簡單，就應該改進設計，讓後續的改變更簡單 職業道德 你應該計畫每週的60小時中 40小時給雇主 20小時給自己 （大約每天 3 小時） 不為雇主工作，為自己的職業發展工作 了解你的領域 每個專業軟體發展人員 至少 必須精通的事項 Design patterns GOF POSA Design principles SOLID Methods XP Scrum Lean Kanban Waterflow 結構化分析 結構化設計 and etc. Disciplines TDD 物件導向設計 結構化程式設計 CI Pair Programming Artifacts UML DFD (Data Flow Diagram) 結構圖 Petri net 狀態遷移圖表 流程圖 決策表 學習 自我學習 讀書, 關注 blog, tweets, 參加 conference, 訪問用戶群, 參與讀書會 and etc. 協作 輔導 專業人士會「視輔導新人為己任」，他們不會放任未經輔導的新手胡打亂撞 了解業務領域 如果撰寫財務系統，你就該對財務領域有所了解 你未必要成為該領域的專家，但你仍需要勤勉，付出相當的努力來認識業務領域。 最不專業的做法是，只簡單地按照規格說明來撰寫程式碼，但卻對於那些業務為什麼需要做那樣的規格定義不求甚解。相反的，你應該對該領域有所瞭解，能辨別、執行規格說明書的錯誤 第二章：説「不」 Do or do not ! There is no try! —— Yoda 專業人士敢於說明真相而不屈從於權勢。專業人士有勇氣對他們的經理說「不」。 難道不該照你老闆說的去做嗎？ 不該。只要你是一名專業人士，那就不該 奴隸沒有權利說「不」。勞工或許也對說「不」有所顧慮。但是專業人士應該懂得說「不」 你的經理要求你在明天之前完成登入頁面，這就是他在追求和捍衛的一個目標，那是他的工作職責。如果你明知第二天之前不可能完成登入頁面，嘴上卻說「好的，我會試試看」，那麼便是你失職了。這時候，唯一盡責的方式便是說「不，這不可能」 可能得最好結果 是你和你的經理共同追求的目標。 最關鍵的是要找到那個「共同目標」，而這往往有賴於「協商」。 「為什麼」重要嗎？ 如果你的主管恰好有「技術背景」和「好脾氣」去傾聽理解，這些解釋也許有用 另一種狀況是，主管會不認同這樣的結論或做法不對，可能會說出不用做完整的測試和程式碼審核 有時候，提供太多細節，只會變成一個口令一個動作的管理方式。 第三章：説「是」 作出承諾包含三步驟 口頭上說自己將會去做 心裡認真對待自己所做出的能諾 真的付諸行動去做 識別「缺乏承諾」的徵兆 need / should 我們需要把這工作做完 我需要減肥 有人應當負責去推動這件事 hope / wish 希望明天我能完成這個任務 希望改天我們能見宴嗎 但願我有時間做這件事 但願電腦更快點 Let's (而不是「讓我」) 讓我們回頭見 讓我們把這工作做完 真正的承諾聽起來是怎樣的 我將在...之前... e.g., 我將在星期二之前完成這個任務 你對自己會做某件事做了清晰的事實陳述，而且還明確說明了完成期限 之所以沒成功，是因為我寄望於某某人去做這件事 你只能承諾自己能 完全掌控 的事 如果最終目標依賴於他人，那麼你就應該採取些具體行動以接近最終目標 之所以沒成功，是因為有些時候我真的無能為力 如果你無法兌現承諾，那麼最重要的就是「儘早向你承諾對象發聲預警，越快越好，越早越好」。 如果你不儘早告訴他人可能的問題，就錯失了讓他們幫你兌現能諾的機會。 第四章：寫程式 做好準備 寫程式是件累人的事，你必須做到 讓程式碼能正常工作。理解當前要解決的問題和如何解決，並且確保程式碼忠實的依循解決方案 幫客戶解決問題 很多時候，客戶提出的需求其實並不能真正解決他們自己的問題。這有賴於你去發現這些問題並與客戶交流，以確保能滿足客戶的真實需求 。 程式碼必須和現有系統整合，並妥善管理好各種相依關係，不能讓系統僵化 寫程式時必須遵循穩工程原則 其他的程式設計師必須能讀懂你的程式碼 這包括寫好註解、精心淬煉程式碼，這可能是程式設計師最難精通的一項。 感到疲勞或心煩意亂， 千萬別寫程式 奉獻精神和職業素養更主要的意義在於「遵守紀律原則」而非成為「長時間的工作狂」 要確保自己已經幾睡眠、健康和生活方式調整到最佳狀態，這樣才能做到每天的8小時工作時間內 全力以赴 創意輸入 「創意輸出」依賴於「創意出入」 → 廣泛閱讀 保持節奏、知道何時應該離開一會 軟體開發是一場馬拉松，不是短跑衝刺 沒解決這個問題不能回家 噢不，你可以回家，而且是應該回家！ 創意和智力來自於大腦的高速運轉，當你感到疲勞時，它們就不翼而飛了 進度延遲 即使是最優秀的程式設計師、最敬業的員工，也不能避免碰到延遲 管理延遲的要訣就是 早期檢測和保持透明 根據目標定期衡量進度，使用三個考慮到各種因素的期限， 不要把預估和期望混淆在一起 樂觀預估, 常態預估, 悲觀預估 不要經受不住誘惑盲目衝刺 你無法更快的寫完程式碼。試圖這麼做，最終只會讓自己變得更慢，同時也只能製造出一堆混亂，讓其他人也慢下來 交付失敗 程式設計師所能表現的不專業中，最糟糕的就是，明知道還沒有完成任務卻宣稱已經完成 明確定義「完成」 最好的方法是讓業務分析師和測試人員建立一套自動化的驗收測試，只有完全通過這些驗收測試，開發任務才能算已經完成 幫助 作為專業人士，你要以能隨時幫助別人為榮 你的工作不可能重要到你不能花一丁點時間來幫助別人 這並不是說你不需要獨處的時間 → 直接、禮貌的讓人知道某個時間區段不希望受到干擾，其餘的時段敞開大門樂於幫助他人 要學會如何請求幫助 輔導 花時間親自輔導手底下的年輕程式設計師，是資深程式設計師的「專業職責所在」 同樣的道理，向資深導師尋求輔導，也是年輕程式設計師的「專業職責」 第五章：測試驅動開發 TDD 的三大法則 在撰寫一個單元測試（測試失敗的單元測試）前，不可撰寫任何產品程式 只撰寫剛好無法通過的單元測試，不能編譯也算無法通過 只撰寫剛好能通過當前測試失敗的產品程式 TDD 的優勢 確定性 缺陷注入率 勇氣 擁有一套值得信賴的測試，便可完全打消對修改程式碼的全部恐懼。當看見糟糕的程式碼時，就可以放手整理 文件 單元測試就是文件。他們描述了系統的最底層設計細節 設計 基於測試先行的需要，會迫使你去思考什麼才是 好的設計 與採用測試先行方式編寫的測試程式碼比起來，後寫的測試在深度和捕捉錯誤的靈敏度方面要遜色很多 第六章：練習 自身經驗的拓展 老闆通常只會限定一種語言、一種平台，以及程式設計師工作目標的專業領域。這樣會導致經驗不夠豐富的程式設計師，其領域和思維都被侷限 程式設計師發現，面對這個行業的週期性變化造成的新局面，自己並沒有做好準備 保持不落伍的一種方法是為 open source project 貢獻程式碼 嘗試對自己不習慣的語言、平台、領域做出貢獻 第七章：驗收測試 定義驗收測試 「業務方與開發方合作編寫的測試」，其目的在於確認需求已經完成了 「完成」意味著 所有程式碼都寫完了 所有的測試都通過了 QA 和需求方已經認可 測試的協商與被動推進 身為專業開發人員，「與撰寫測試的人協商並改進測試」是你的職責。絕不能被動接受測試，更不能對自己說：「噢，測試就是這麼要求的，我又得這麼做。」 層級 對象 單元測試 系統內部 呼叫特定類別方法 驗收測試 系統外部 通常在 API 或 UI 層級進行 結論 細節交流是件麻煩事。尤其開發方和業務方交流關於程式的細節時，更是如此。 通常，各方握手言歡，以為其他人都明白自己的意思。雙方以為取得了共識，然後帶著截然不同的想法離開，這種事屢見不顯。 要解決開發方和業務方的溝通問題，我 (Uncle Bob) 所知道的唯一有效辦法是「編寫自動化的驗收測試」。 第八章：測試策略 職位 測試面向 業務人員 正常路徑測試 (happy-pathtest) QA 包含極端狀況 (corner)、邊界條件 (boundary)的異常路徑測試(unhappy-path) 自動化測試金字塔 測試 覆蓋率 測試介面 人工探索式測試 ~5% 系統測試 ~10% gui 整合測試 ~20% api 元件測試 ~50% api 單元測試 ~100% 單元測試 目的： 在最低層次上定義系統 先寫測試，在寫程式碼 這些應該作為 CI 的一部分執行，以確保程式設計師的程式碼意圖沒有遭到破壞 元件測試 需要使用合適的 mocking 或 test-doubling，解開「系統和其他元件」的耦合 由 QA 和業務人員編寫，開發人員提供輔助 整合測試 目的： 確認系統架構層面結構正確 只對元件很多的較大型系統才具有意義 由系統架構師或 lead designers 來編寫 系統測試 針對「整個整合完畢的系統」來執行的自動化測試 不會直接測試業務規則，而是測試系統是否以正確組裝完畢 應包含產能測試和性能測試 由系統架構師和 technical leads 來編寫 人工探索式測試 目的： 驗證預期行為時，探索系統預期以外的行為 第九章：時間管理 會議 關於會議，有兩條真理 會議是必須的 會議浪費了大量的時間 離席 仔細管理自己的時間是你的責任。如果你發現參加某個會議是在浪費時間，就應當想個禮貌的辦法出來 顯然，你不該大喊「這會議真讓人厭煩」，沒有必要採取粗魯的辦法。可以選個適當時機來問問大家，你的出席是否必要。你可以解釋說，自己抽不出更多的時間用於這場會議，問問有沒有辦法加快討論，或者另選時間 繼續參加對你沒有太多意義的會議，是不專業的行為 爭論 / 反對 如果觀點無法在短時間（5 ~ 30 分鐘）內達成一致，就永遠無法達成一致 唯一的解決方法是「去取得資料，讓資料來說話」 「既然其他人想要這樣做，就這麼做吧」這可能是非專業的行為中最糟糕的了，千萬千萬不要這麼做 如果你同意了，就 必須 拿出行動來 專注力 Manna 專注力是稀有的資源 如果你用光了自己的專注力 Manna，必須花一個小時或更多時間做不需要專注力的事情來補充它 專業開發人員會安排好他們的睡眠，保證清晨有飽滿的專注力 Manna 去上班 肌肉專注力有助於改善新制專注力，而不僅僅是簡單恢復 定期訓練肌肉專注力，可以提升心智專注力的上限 要避免的行為 優先順序錯亂 無論什麼原因，我們都可以找到辦法逃避真正的工作。提高某項任務的優先順序，之後就有藉口延後真正急迫的任務 專業開發人員會評估每項任務的優先順序，排除個人的喜好和需求，按照真實的緊急程度來執行任務 死胡同 專業開發人員不會執著於不容放棄也無法繞開的 idea。他們會保持開放的頭腦來聽取其他建議，所以即便走到盡頭，他們仍然有選擇 第10章：預估 承諾 v.s. 預估 承諾是必須做到的 預估是一種「猜測」，不帶任何承諾的色彩。之所以要預估，是因為不知道要花多少時間 PERT (Program Evaluation and Review Technique) 三元分析法 O: Optimistic Estimate 一切都很順利的完成時間 N: Nominal Estimate 一般來說的完成時間 P: Pessimistic Estimate 遇到各種意外地完成時間 $ \\mu = \\frac{O+4N+P}{6} $ 任務期望完成的時間 $ \\sigma = \\frac{P-O}{6} $ 任務完成機率分布的標準差 大數法則 把大任務分成許多小任務，分開預估再加總，結果會比單獨評估大任務要精確得多 第11章：壓力 避免壓力 承諾 避免對「沒有把握達成最後期限的工作」做出「承諾」 業務方總是期望能夠拿到這些承諾，因為他們想消除風險。我們要做的就是日風險量會，必將他們陳述給業務方，這樣他們就能做好相對的準備。 有時，有人會代我們做出承諾 出於責任感，我們必須主動協助找到方法來兌現這些承諾，但是一定 不能接受 這些承諾 危機中的紀律 如果在危機中你改變了行為，就說明你並不是真的相信常規行為中的紀律 如果在平時你會注意程式碼整潔，但在危機時刻，你卻會產出髒亂的程式碼，就說明你並不真正相信混亂會導致速度下降 應對壓力 不要驚慌失措 溝通 讓你的團隊或主管知道你身陷困境。告訴他們你為走出困境置地的最佳計畫。請求他們的支援與指引。避免製造意料之外的詫異 依靠你的紀律原則 依靠那些你已經知道確實有效的東西 - 你平時遵守的紀律 尋求幫助 Pair Programming 第12章：協作 專業程式設計師的主要職責是滿足雇主的需求 這意味著要含你的經理們、業務分析師們、測試工程師們和其他團隊成員有良好的協作，並且 深刻理解 業務項目 你需要理解 「手上正在撰寫的程式碼，其業務價值是什麼」 ，了解雇用你的企業將如何從你的工作中獲得回報 「需要長時間努力思考一個問題」、「任務極為簡單、和另一個人一起工作變成一種浪費」時單獨工作是正確的 但一般來說和其他人緊密協作、大部分時間採取 Pair Programming 是最好的作法 程式設計意味著「與人協作」 我們需要和業務人員一起工作，我們之間也需要互相合作 第13章：團隊與專案 形成有凝聚力的團隊是需要時間的 可能需要6個月，甚至是1年 團隊成員首先要建立關係。他們需要學習如何互相協作，需要瞭解彼此的癖好、強項、弱項，最終才能 凝聚成 團隊 有凝聚力的團隊通常有12名成員，多可以有20人，最少可以只有3人 e.g., 12名 7名程式設計師 2名測試人員： 編寫「自動化測試」確認程式正確性 2名分析師： 開發「需求」，為需求編寫「自動化測試」確認業務價值正確 1名專案經理： 跟蹤團隊的「進度」，確保成員理解「專案時間表」和「優先順序」 團隊比專案更難建置 組織穩健的團隊，讓團隊在一個又一個專案中整體移動、共同工作是較好的做法 團隊有了凝聚力，但卻因為專案結束了便將這樣的團隊解散，是極為荒謬可笑的做法 第14章：輔導、學徒期與工藝典範 學校能夠傳授的是電腦程式設計的理論 但學校並不會、也無法傳授作為一名程式設計工匠所需要掌握的原則、實踐和技能 這些東西只有經由師徒個體間多年的細心監督和輔導才能獲得 Appendix A: 工具 Source code control e.g., git IDE / Editor e.g., vi, emacs, IntelliJ, TextMate 問題追蹤 e.g., Pivotal Tracker, Lighthouse, wiki, Board (To-Do/ Doing/ Done) CI e.g., Jenkins 單元測試工具 快速便捷的執行測試 在通過或失敗要有清楚的視覺提示 對於測試進度也要有清楚的視覺提示 避免 test cases 之間的彼此通訊 讓編寫測試變得容易 元件測試工具 理想的情況是「業務分析師和QA」能夠使用這些工具來 編寫 規約 e.g, FitNesse, RobotFX, Cucumber 整合測試工具 e.g., Selenium, Watir UML / MDA","tags":"Tech","url":"https://wei-lee.me/posts/tech/2018/11/the-clean-coder","loc":"https://wei-lee.me/posts/tech/2018/11/the-clean-coder"},{"title":"[Book] 告別菜尾時代","text":"The plain fact is that the planet does not need more successful people. But it does desperately need more peacemakers, healers, restorers, storytellers and lovers of every kind. It needs people who live well in their places. It needs people of moral courage willing to join the fight to make the world habitable and humane. And these qualities have little to do with success as we have defined it. –– David W. Orr 第一篇：如果舒適圈一點也不舒服 「再重新想一遍。你認為的舒適圈，真的舒適嗎？」 有些人會說，那是因為他們有錢，才能夠擺脫「飢餓威脅」。 可是我的好友M就曾憂心忡忡地告訴我，他身上有龐大的貸款要償還：瑞典人Ｎ在找房子時，也說他沒辦法租太昂貴的房子，因為每個月能花的費用有限：澳洲人S也總是在研究空擋去醫院兼職打工。 這些人並非是天之驕子，都是跟你我一樣為了錢而煩惱的凡人，但他們卻勇於暫時放下外人或自己人生的「飢餓威脅」，嘗試走到世界闖一闖。 美國人Ｍ與Ｋ就告訴過我，若不是在南美、非洲的那幾年，他們不會知道自己想成為一個怎樣的醫生。 You Are In Your Time Zone. 比起年齡，更應該焦慮的是 - 有沒有在做自已喜歡的事 不要用已經付出的「沈沒成本」來限制人生的決定 美國的學校最喜歡能展現領導力的學生，且招生標語總是希望培育出「未來領導人」，因此，進了美國職場後，就算我是整個實驗室裡輩份最小的，同事和老闆也總是告誡我：「 我們要你未來也能成為領導人。千萬不要小看自己，人總是會往上爬，有一天你也會成為主管，而我們希望到那個時候你是『準備好的』 」。由此可知，他們不只把我當個「員工」而已 ，還會花時間教我各種領導能力，例如，有效運用自己的時間，學會取捨、面對無謂的要求要懂得說「不」、學著主持會議、還教我如何與其他老闆社交......等。 如果你因為旁人的負面思考與意見被侷限而不放膽嘗試，那麼，你的最佳狀態就只會是現在的模樣，不會再進步了。 對未來缺乏想像力這件事，或許不能完全怪在台灣的學生身上...... 如果你沒有看過別人成為什麼，便很難去想像自己可以成為什麼 。 「你應該要先去想想，二、三十年後，你想成為一個怎麼樣的人？為了成為這樣的人，十五年後應該要達成什麼樣的位置？又必須做出多少的努力，才能達到二、三十年的目標？以此回推，如果要達成十五年的位置，那麼到了第十年你該做些什麼？第五年呢？第一年呢？ 慢慢逐步推回來。因此你現在應該要為了一年後，做什麼努力？ 」 他點出了我們應該要先放膽去想，二、三十年後想做什麼？然後再慢慢回推現在該做什麼努力，而非以現在能看到的視野、擁有的資源，規劃我們三十年後想成為的樣子。 第二篇：只要敢闖，世界就是你的 聯合國與哈佛的面試： 你的 Commitment 是什麼？ 我還特地問他（組織內的行政助理）：「難道美國人/西方人比較看重承諾？畢竟我過去從未在面試時被問到這樣的問題，就連我進醫學系的時候也沒有。」 他說：「真的！因為 Commitment 是個很慎重的字。」他沈默了也思考一下，然後說：「我的人生中還沒有在面試時被問到這個問題，但我可以想見， 我們(哈佛大學)或聯合國想要找到對於這個世界有熱情、有理想的申請者，才會在面試的時候這麼詢問。 」 第三篇：站在語言、文化與價值觀的十字路口 當你開始在異鄉生活，英文就再也不是考試上那一題題的單選或複選題了，而是工作、讀書，或是生活上的溝通「工具」。就英文程度需求最低的生活層面來看，如果你到了另一個國家，無法聽得懂對方的解釋，又無法清楚表達自己的想法，那麼，在國外吃虧時，該要如何幫自己爭取權益呢？ 第四篇：在地球的另一端，從異鄉看家鄉 只用旅行構成的世界觀並不完整 因為在旅行途中，大部分的時間是快樂的，然而，在當地生活是酸甜苦樂並存的，甚至是時間的苦悶。 透過長住的機會，使我有不一樣的「成長」。這個「成長」，來自於我每天使用非母語的語言，每天努力融入另一個族群的文化、每天拼了命去學習全新的思考模式，然後在空閒時間，好好看著離家半個地球遠的當地風景。 有一位我十分敬重的某 NGO 創辦人來台灣演講時，有學生問他：「如果我有四萬元，你希望我把四萬元捐給你？還是希望我用四萬元買一張機票，去看看你所創建的孤兒院呢？」 NGO創辦人豪不猶豫地說：「 我希望你買一張機票來看看，因為當你買了那張機票，你才會明白我所說的一切貧窮、困苦都是真的。你會把這些震撼與故事帶回到你的生命裡，然後，我要你用你那四萬塊的機票，發揮你生命的影響力，把故事傳出去，讓更多人知道什麼是貧窮，在貧窮裡生活又是如何超乎你原本生活想像的艱難。 」 往後，我看到許多偏鄉志工、國際志工，不論是捐錢、捐物資等，也有相似的行為漠視：半吊子的助人，認為「有幫總比沒幫好」，或是助人後，完全不檢討自己的行為是否為對方帶來傷害、是否有改善的空間，也因此，我開始深刻的體會「做好事，不是只有善意就好」。 Cambodia's Orphanage Business Ethiopia food aid dependency 為善，應該要更柔軟與敏感 心存善念幫助他人的同時，不要只憑一股衝勁去做，完全缺乏事前的評估，也沒有細心調查服務對象的需求，更不要在事後，完全沒有檢討、追蹤與改善。 這就好像待人處事一樣，是需要互相尊重與同理心的，更不是自己的地位比受助人高。別忘了，今天的你只是相對幸運，能夠擁有比較多的資源，説不定，有天你也可能會成為需要幫助的人。行善之前，請試著多想一些。 尤其做好事的人，內心往往要比一般人更柔軟與敏感才是。 The road to hell is paved with good intensions. 同場加映作者的文章: 「愛台灣，就是畢業了先不要回來。」──現在我明白，這句話背後的沉重","tags":"Book","url":"https://wei-lee.me/posts/book/2018/11/it-s-time-for-the-young-generation","loc":"https://wei-lee.me/posts/book/2018/11/it-s-time-for-the-young-generation"},{"title":"MOPCON 2018","text":"今年其實是因為拿到去年講者用不到的邀請票才來參加的 xD 總結來說，我覺得這趟來還算是蠻有收穫的 幾年前有去過一次 MOPCON 也許是去慣了台北的研討會都在中研院豪華的場地，就覺得 MOPCON 的場地很普通 （其實連國際級的會議 EDBT 的場地都沒中研院好呢 那年的議程也沒給我多大的收穫，之後就沒再來過了 兩天的會議下來，原本自己有做了一些筆記 但後來覺得自己保留一份筆記實在沒什麼意義... 共筆上面的內容還比我多，就把我自己的部分也都更新上共筆了 共筆連結 Day 1 第一天比較有趣的是 從菜鳥警察到資料戰警 , 用 Drone 改善團隊自動化測試及部署流程 原本讓我有考慮來 MOPCON 就是想來聽聽 Drone 的使用 不過果然還是要自己玩玩看才會知道怎麼用啊 xD 感覺聽這樣的 talk 大概就是讓我決定要不要花時間來試新工具 聽說還蠻多場都只是在介紹自家的產品的 還好我很巧妙的避開了（？？？ Day 2 第二天我就幾乎都在 Unconference 了 一般議程只聽了開頭 jserv 的 智慧電網背後的軟體建設 跟結尾的 Flutter 踩雷心得 其實會都待在 Unconference 也是一場意外 xD 原本想說還有五分鐘才正式議程，所以就先過去晃晃 但 創業的辛酸與奧義 實在太精彩了，就一直聽下去了 這場可是讓 Unconfernce 的場地全部坐滿，外面還圍了一整圈的人呢 接下來的 工程師與設計師都該知道的事 也很精彩 還好我有跑去 Dcard 的攤位跟講者要 slide 裡面的內容都還蠻有用的，但實在有點來不及作筆記 而且 Unconference 真的沒什麼人會去更新共筆 這場的整份筆記只有我在更新 QQ 最大的 takeaway 是 UI堆疊的太念 好像是來自 How to fix a bad user interface 這篇文章 Flutter 踩雷心得 也是出乎意料有趣的議程 Flutter 是一套可以拿來用在 iOS 和 Android 的框架 整場聽下來學到了不少 mobile 開發的知識 還有如何叫老闆買新電腦（誤 Lighting Talk 話說今年好像彩蛋題太難解，好多場 Lighting Talk 都在講要怎麼打 MOPCON 的官方 APP xDDD","tags":"Tech","url":"https://wei-lee.me/posts/tech/2018/11/mopcon-2018","loc":"https://wei-lee.me/posts/tech/2018/11/mopcon-2018"},{"title":"[Book] 做孩子的重要他人","text":"跟蘇老師合作了半年下來 這還真的是我第一次真的有時間好好的看完這本書 第一次知道這本書大概是幾年前政大書城打得很大的標語 我的研究若做好，只幫了幾個人，但走入偏鄉，我要影響的是我們的下一代。 這本書交錯著蘇老師的成長歷程跟在偏鄉看到的事 我想大概還是偏鄉的那段故事比較吸引我 看著不同生長背景的人的故事，讓我更有能力去理解用不同方式去思考的人們 （ 同場加映： 做工的人 ） 我也同樣的記錄下，讓我比較有感的句子 許多人認為偏鄉的孩子沒有進取心，但問題可能在於我們不曾提供希望，讓他們知道向上爬的可能性。 我在教導程式書寫的過程中發現，如果我一味將孩子訓練成寫程式的工匠，而不讓他們知道為什麼要寫這些程式，將來他們只有當代工的命 - 在別人設定的規格下，做出別人要的制式化的東西。 因此訓練學生思考「現在面對的問題是什麼？」「如何解決這些問題」「電腦程式可以為解決這個問題幫上什麼忙？」甚至是「為什麼人們需要解決這種問題？」這一系列問題的替換，塑造他們思辯判斷的能力，才能培養出這個時代需要的領導人才。 孩子們需要的是長期的陪伴，蜻蜓點水式的關係，反而可能造成傷害。 真正的能者不會要求別人給你「公平」，反倒會努力爭取機會，把「公平」分給別人。 我們有什麼資格用「弱勢」二字來形容人家？說不定我們自己才是真的「弱勢」呢！ 裡面有些內容讓我想起去埔寨當國際志工的事 對我來說，那絕對是一趟收穫很多的經歷 但我是不是真的對當地帶來了幫助 回過頭來看，我對此是很懷疑的 我想反而是我從他們身上得到的還比較多 我們離開時，有人問當地的小朋友對我們的想法 我們突然來到他們的生活，卻又突然的離開 其實他們是很難過的，覺得我們這樣是很過分的 也許真的想要做些什麼，還是需要很長期的付出和陪伴 我們以為的幫助，反而卻帶來了傷害","tags":"Book","url":"https://wei-lee.me/posts/book/2018/10/be-someone-to-the-children","loc":"https://wei-lee.me/posts/book/2018/10/be-someone-to-the-children"},{"title":"Blog 風格修正","text":"一直以來都有發現 Blog 的風格有點小問題 但都懶得去好好地找出問題 這次終於下定決定修好它 起源其實是我的上一篇文被嘴了 QAQ 整理下來大概有三個問題 大小標的 margin 英文前後也空一格 第二行縮了四分之一字元 1. 大小標的 margin 這應該是三個問題中最簡單的 但我有點懶得動 CSS ，所以就先不修了 xD 2. 英文前後也空一格 剛好最近看到了 中文文案排版指北 才發現原來 「有研究顯示，打字的時候不喜歡在中文和英文之間加空格的人，感情路都走得很辛苦，有七成的比例會在 34 歲的時候跟自己不愛的人結婚，而其餘三成的人最後只能把遺產留給自己的貓。畢竟愛情跟書寫都需要適時地留白。與大家共勉之。」 ——vinta/paranoid-auto-spacing 總之，這也不是特別難處理的問題 只要透過 add-space-between-latin-and-cjk 再加上 os.walk() 就能解決了 不過還是會遇到一些不該加空格的地方，也被加空格了 但也只要用 git diff 再確認一下哪裡有被 script 修改過就可以了 3. 第二行縮了四分之一字元 這個問題就比較頭痛了 因為我在模板找到這段的內容是 {{ article.content }} 也就是説這個多的空白是 pelican (我用的 static blog generator) 所產生的 我沒有辦法透過單純的修改 HTML, CSS 來修正這個問題 必須要找到 pelican 是從哪產生出這個空白的 於是就開始我的 trace pelican 的之旅 接下來，就是一連串的 trace 過程 不想看可以透過 傳送門 直接跳到解法 pelican/readers.py (first try) 要找到 Markdown 是在哪被 parse 並產生內容的並不困難 ( pelican/readers.py 的 334行 ) 透過一些測試，發現這段的行為是因為有了多的 \\n 造成了多的空白 第一個猜想是某些情況下的 \\n 沒有成功的被移除掉 所以只要加一行 content.replace('\\n', '') 確保全部的 \\n 都被移除，應該就可以了 一開始問題也真的解決了 直到我用到 markdown中的 ``` 語法才又出現問題 在整個 code block 中的 code 全部都黏在一起沒有斷行 看來這個做法是行不通... 只好認命的從我平常產生文章的指令一步一步追回去 trace 的過程還有踩到一個雷是「pip 裝的 pelican 並不是 master 上的版本」 所以我還必須要切到 3.7.1版 才能開始解決我遇到的問題 setup.py 平常我都是透過 pelican -r -o output -s pelicanconf.py 這個指令來產生文章 所以第一步就是要從 setup.py 找出 pelican 這個指令是哪裡來的 ... 'pelican = pelican:main' , ... pelican/ init .py 既然在 pelican 這個 package 中沒有 main.py 那 Python 還能找到 main 就只剩下 __init__.py 扣除掉一些 parse 指令參數的程式碼 接下來最像是產生文章的程式碼就是 147行 的 run for p in generators : if hasattr ( p , 'generate_context' ): p . generate_context () 下一步就是要從 generators 找出 generate_context 這個函式 from pelican.generators import ( ArticlesGenerator , PagesGenerator , SourceFileGenerator , StaticGenerator , TemplatePagesGenerator ) pelican/generators.py generators 中看起來最有關的就是 ArticlesGenerator 這個 class 也找到了 generate_context try : article_or_draft = self . readers . read_file ( base_path = self . path , path = f , content_class = Article , context = self . context , preread_signal = signals . article_generator_preread , preread_sender = self , context_signal = signals . article_generator_context , context_sender = self ) 這裡找到的是文章被產生的地方 只要能在找到文章中的內容是在哪產生，應該就能解決我的問題 所以下一步就是要再去找到 Readers pelican/reader.py Readers 在這個檔案的 486行 接著 trace 這個 class 到 526行 就真的是文章內容第一次被產生的地方 到目前為止，文章的內容還是沒有多餘的空白 所以順利的話只要從這繼續 trace 下去就能找出問題 content , reader_metadata = self . get_cached_data ( path , ( None , None )) if content is None : content , reader_metadata = reader . read ( path ) self . cache_data ( path , ( content , reader_metadata )) 最後發現問題是出在 555行 if content : content = typogrify_wrapper ( content ) 只要不對 content 做 typogrify_wrapper 就不會產生多餘的空白 typogrify typogrify 是 pelicanconf.py (pelican 的設定檔) 中的一個設定 TYPOGRIFY = False 只要關掉 typogrify 就不會再產生出多餘的空白 typogrify 看來是某種加強 HTML 的工具 我試過要把 <br> 跟 &nbsp 加入 TYPOGRIFY_IGNORE_TAGS 不過看來還是沒辦法解決 最後只好把 typogrify 整個關掉了 後記 其實這也只是個無傷大雅的小問題 但真的是花了我不少時間才找到真正的問題所在 前幾次都能透過 trace 原始碼，找到 library 的一些小問題 也丟了幾個 Pull Request 不過看來這次沒能再多貢獻什麼 雖然好像有找到可能從 typogrify 解決掉這個 issue的方式 但要再把它加入 pelican 變成一種 config 還是有些麻煩 xD","tags":"Tech","url":"https://wei-lee.me/posts/tech/2018/10/fix-blog-style","loc":"https://wei-lee.me/posts/tech/2018/10/fix-blog-style"},{"title":"X-Village 課程設計","text":"要一次說完整個 X-Village ，還是有點太花時間 先來聊聊我這次接觸到跟課程設計有關的部分 我在 X-Village 中，主要的工作還是在規劃、管理跟行政的部分 所以我要上的課也不多 跟課程相關，我接觸比較多的大概是這幾個部分 Review 「程式設計基石」(a.k.a. Python 課) 「資料結構」第三天下午的練習 「網頁開發、資料庫、雲端運算」第三天後半課程 1. Review 「程式設計基石」 課綱 起初，我和另一位核心助教規劃了 Python 課程的大綱 但這份課綱對初學者還是太難 因為身上處理的事在太多 這些工作就逐步派給其他助教 過了一週後，我們得到了一份更難了很多的課綱 xD 畢竟大家沒有太多的教學經驗 一開始就要設計好一份適當的課綱，本來就很困難 而且初期 Target Audience 一直不太明確 造成課程難度很難抓 陸續討論了幾週後，這就是我們正式課程前的版本 Topics Day 1 Opening Python Intro Editor Git Day 2 HackMD 淺談電腦基本運作 如何自己解決問題？ (Google, Stack Overflow) Python Basic(I) (Synyax, Data Types) Day 3 Function Module/Package Class Day 4 OOP Introduciton Day 5 Exception Handling File String Coding Convention Day 6 Recap Built-in Day 7 Regular Expression Python 套件管理 requests Day 8 Beautifulsoup Visualization Day 9 Decorator Iterator Generator Context Manager Day 10 Broaden Horizon Rehearsal Rehearsal 的時候，我看到了蠻多值得學習跟反省的地方 不愧是從醒獅團的人們，我看到了一些很有趣的教學方式 看著每個人不同的教學風格和內容 我在思考著 是不是有些人在以往學習程式上比較順利，比較知道如何自己找到解學辦法？ 對這樣的人來說，要如何把知識傳遞給學習不那麼快的人，就會需要比較多的學習 回想起我寫程式的歷程，可是一點都不順利 我在寫 Lisp 的時候，連 Syntax Highlight 都不懂 還要不斷數括號數量，才知道程式能不能跑的 e.g., (cond ((eq 'a 'b) 'first) (atom 'a) 'second)) （其實上面有少一個括號 xD） 課程正式開始 課程的前兩週因為在準備碩士論文口試 我沒有投入教學，也沒辦法整天跟課 但我中午跟晚上幾乎都會去 拿便當、飲料 關心課程狀況 課程開始後，我們要不斷看大家的狀況跟課後的回饋來調整課程的進度 因為這是密集課程 所謂的調整課程就是「今天馬上要改完，明天馬上就要上場」 而且助教們晚上也會留下來陪學員晚自習 造成大家幾乎是沒什麼休息的時間 因為第一次辦，完全無法預期大家的學習速度 只能先用一個版本出來教教看 再來看現場狀況隨時調整 不過有了這次的經驗，明年應該就比較有底了（如果還有明年的話 xD） 2. 「資料結構」第三天下午的練習 Exercise ipynb: DS-Exercise Day3 雖然先前大概有稍微想了一下準備怎樣的 Exercise 但我前一天下午才口試完 我其實只有大概一個晚上的時間準備 ... 可是「資料結構」的老師又是我找的 總覺得還是得要負起一些責任 早上的課程會由老師教理論，下午由助教來帶一些練習 我帶練習的那天早上則是教排序 在教學上我並沒花多少時間 就是帶了一些影片，讓大家 Recap 一下白天老師教的內容 我主要把時間都花在 Exercise 的設計上 Exercise4 用 Python 做排序 (ex4.py) some_list = [ 65 , 81 , 65 , 19 , 6 , 28 , 86 , 40 , 72 , 27 , 76 , 46 , 22 , 98 , 49 , 57 , 52 , 46 , 47 , 14 , 29 , 15 , 59 , 74 , 61 , 47 , 20 , 33 , 89 , 99 , 65 , 82 , 84 , 63 , 93 , 1 , 42 , 13 , 54 , 58 , 84 , 17 , 5 , 18 , 14 , 14 , 19 , 42 , 60 , 77 , 17 , 29 , 2 , 42 , 42 , 31 , 47 , 67 , 15 , 16 , 71 , 56 , 98 , 46 , 18 , 20 , 14 , 36 , 42 , 23 , 87 , 7 , 5 , 5 , 52 , 78 , 76 , 91 , 92 , 88 , 38 , 66 , 13 , 18 , 68 , 96 , 23 , 51 , 77 , 93 , 35 , 18 , 9 , 64 , 51 , 76 , 76 , 96 , 5 , 18 ] 寫過 Python 的人，一定馬上就會想到用 sort 或 sorted 但我故意把練習時間拉長到 20 分鐘 中間一直會有學員、助教問我「真的可以這樣寫嗎？」 恩，可以哦 在早上教完「資料結構」後，馬上帶這樣的練習 很容易讓人直接聯想到要實作排序演算法 我想帶來的想法是「在要下手去做什麼之前，先找找是不是有什麼現存的工具」 回想以前的我，肯定也是埋頭就下去硬幹 甚至我第一次用 Python 爬選課系統的時候，連 json 模組都不會用 只會照著 json 規定的格式，慢慢地做字串處理 e.g., json_str = '{\"' + course_name + '\": \"' + course_id + '\"}' 因為在我的 Knowledget Base，對函式庫的概念還是很模糊 也不知道為什麼要用，好處在哪 大二下的 C++ 寫的 ncurses 反而感覺像是造成我更多的麻煩 xD 因為我並不知道如果不用 ncurses ，要做同樣的事會多麻煩 所以試試看讓學員真的做一次很麻煩的處理 透過痛過，來知道為什麼要使用工具 Exercise5 深入淺出 Python 排序 (ex5.md) Q1: Python 的 some_list.sort() 跟 sorted(some_list) 差別在哪 Q2: Python 的 sorted() 是用哪種排序演算法 ? 這兩個問題其實並不困難 第一個問題是我以前寫 Python 常遇到的錯誤 同時也想讓大家去想想「如果有不同的做法都能解決問題，他們不同的地方在哪」 第二個問題則是想激起大家的好奇心，試著去探究看似理所當然的東西 最後 Exercise 4, 5 我幾乎直接把答案都公佈了 即使是在這之後才用我公布的方法，我也是會計分 因為這個思考的過程才是重要的，答案一點也不重要 Exercise6 用 Python 做排序 我給了一筆 PTT 爬下來的資料，根據某個 key 做排序 早上才從八卦版剛爬下來的（好像有爬到一些奇怪的東西 ...） 靈感就只是前一天跟學員聊天，聊到他們的視覺化作業要用 PTT 的資料 這個練習目的在於用實際的資料 讓大家感受到程式是真的能解決實際的問題 而且並不如想像中的那麼困難 回想我大一不斷的學習用好的架構寫一個 BMI 的程式 總覺得要寫一個稍微有用的程式是非常非常遙遠的事 所以大二下的 C++ ，對我來我說是寫程式很大的里程碑 這題的解答也是差不多一行而已 data = sorted ( ptt_data , key = lambda x : x [ 'some_key' ]) 但我認為這對新手來說，已經會是相對挑戰的練習了 至少以初學的我來說，我可能就要花不少時間去 survey 、去思考 這個練習中，我還埋了一個坑是「key 可能是空的」 我前一天設計這個練習的時候也入坑了，此坑不能只有我入 我也會下去跟大家討論要怎麼解決這個問題 這個問題本身有很多種不同的解法 我自己的解法是使用 filter 過濾掉空值 但我也遇到學員們有很多不一樣的想法，我覺得挺好的 Bouns Bonus 3 實作各種 sort 作法 Bouns 4 分析各種 sort 適合的情境 因為課程的速度放慢，有些學過的就會覺得比較無聊 這兩個 Bouns 就是設計給這樣的人 至少在這的兩個小時不要是浪費時間 Bouns 4 我也沒有正確解答 我蠻好奇會不會有人能給我一點想法的 不過這麼機車的題目最後看來是沒人寫 xD 「資料結構」練習後記 後來有一次跟學員聊天的時候 學員跟我分享他覺得這樣的練習設計，帶著大家思考很有幫助 看來前一天沒什麼睡到是值得的 3. 「網頁開發、資料庫、雲端運算」第三天後半課程 Slide: CRUD in Flask Sample Code: web-acccounting-example 前面的課程中有由博安老師指導的 Database 跟 Flask Introduction （博安老師的課程可是在 Web 課程中唯一零負評的，真不愧是博安老師！） 而我的內容則會注重在 view 的撰寫上 我先讓大家對要做的東西有概念 (i.e., 記帳程式 ) 在寫程式前，我帶著大家看市面上做出來的記帳程式是長怎樣的？ 這些記帳程式有什麼功能？ 如果用我們這幾天教的想法，我們要怎麼去思考這個後端的系統？ 接著才真正要進入程式 我基於博安老師前一個半小時的程式碼在做延伸 從最原始的 0.1 版 每次只做一點點的修改，每一個修改都給那個 commit 一個 tag 在 slide 的右下角，也會放目前到哪個版本 也希望能從這樣的做法，帶到 frequent commit 的重要 講解程式碼之前 我會先讓大家打過程式碼，並確認可以執行 再來才會解釋每一行程式碼在做什麼 但它們組合起來不見得是對的 xD 尤其剛開始講 view 的 0.2 版更是幾乎沒一個功能是對的 但程式是能跑的 除了聽跟照著做以外 希望能讓大家去發現哪裡有奇怪的地方 試著去想想要怎麼解決這些奇怪的地方 直到 1.0 版才看起來像是一個可以動的網站 但就算到這裡，還是有一個小錯 xD 我想從這裡帶出測試的重要性 統整一下，我整個課程設計想帶給學員的思考 如何思考一個後端架構 ? → 其他人的記帳程式 溝通在寫程式是很重要的 → README.md , requriements.txt 如何除錯？ → 滿是錯誤的 view, postman 的使用 為什麼測試是重要的？ → 整個網站雛形都出來了，還有埋錯 整個構想聽起來是很美好 但這次的嘗試，得到的評價不是很好 其中一份回饋告訴我 「他不太喜歡這樣先複製程式碼在學習如何修改的教學方式 因為一開始看不懂程式碼，只能照著我說的改，會很不知道自己在改什麼」 很感謝願意給我建設性回饋的學員 我也在思考 到底是這樣的方式不適合初學者？ 還是我沒有把這樣的內容表達好？ 如果還有下次的機會 除了思考課程的內容外，我還要多花點時間準備在台上的表達","tags":"Gossiping","url":"https://wei-lee.me/posts/gossiping/2018/09/X-Village-Course-Design","loc":"https://wei-lee.me/posts/gossiping/2018/09/X-Village-Course-Design"},{"title":"從 Andromoney 到 MOZE","text":"最近不小心被 MOZE 的介面燒到 一個衝動就從 AndroMoney 轉到 MOZE 這篇算是來記錄從 AndroMoney 把資料轉換到 MOZE 的過程 一些無關本文的前言 雖然 X-Village 暫時告一個段落，好像應該來寫個什麼 但真的要寫起來還要再花一點時間 上次 Blog 發文都已經是一年前的事了 但點閱率竟然有一點在上升（雖然還是很低 QAQ） 還有一些人看了我在 Logdown 的 LineBot 文跑來找我討論 覺得蠻開心的 xD 但這邊還是一直都沒辦法被找到 QQ 以後考慮同步發到 Medium 好了 不過好像該進入本文了 xD 為什麼換到 MOZE 當初在 Android 上使用 AndroMoney 就只是因為他免費，而且還算是好用 剛好換到 iOS 的時候，這款 app 也在 App Store 有上架 懶得轉換資料的情況下就繼續買了 用下來覺得 AndroMoney 好像還是在 Android 上比較好用 AndroMoney 的各種功能都很方便，只是介面上就比較普通 xD 而且 AndroMoney 各個平台都有，就算哪天想換 Android 的手機也不怕轉換問題 但是啊， MOZE 的介面就是好看 xD 再來就要說說其他我喜歡 MOZE 的原因 AndroMoney 沒有 (或我不會用) 的功能 借款事件 MOZE 會幫我記住我借錢給誰，而且會一直提醒我誰跟我借了錢 以前都還要特地記錄到其他 app 而且借出的錢，不會算在我的支出，所以也不會影響到我的預算 算是蠻方便的功能 繳費事件 提醒我信用卡要繳費的時間 也會有跟借款事件差不多的提醒 動態改變每天剩餘的預算 這是一個我還蠻需要的功能 我會想知道前幾天花的錢如何影響我這個月剩下的日子的預算 而不是一個從月初的預算直接除以 30 都不改變的數字 帳戶 icon 每個帳戶都能加入自己的 icon 只要是付費版的 MOZE 就會有各家銀行的 icon 雖然他說是付費圖示，但其實這幾個是免費的 只有其他類別的彩色圖是要購買 但我是覺得原本的我比較喜歡 xD 另外，也可以自己製作想要的 icon 匯入 ~ 電子發票載具 以前都沒有什麼要用電子載具的誘因 就完全忘了這回事 現在這個可以直接幫我記帳就很吸引我 而且他也有支援 wideget ，給店家掃過後，馬上就能用 Apple Pay 另外，我原本以為從雲端載下消費紀錄，一定會要再創一個紀錄 但其實這是可以連結到某一筆過去的紀錄 這對我也是蠻重要的功能 只是目前好像還不能針對轉帳或借款事件歸帳 希望這些能透過 MOZE 3.0 會有的分帳功能解決 拆帳 (MOZE 3.0 才有) 雖然目前還沒有，但這個功能我現在很期待 所以還是想列一下 xD MOZE 沒有 (或我不會用) 的功能 專案不能跨幣別 我之前去歐洲的那些紀錄就因為這樣，必須用標籤來分類 QQ 不過聽說 MOZE 3.0 會新增就是 不能將單一紀錄不計算在花費中 主要是有些特別的花費我不會想要扣在我的預算中 這樣那個月剩下的天數的預算就都會是 0，好像也不太對 ... 【AndroMoney 功能教學目錄】 這個我真的覺得超棒的 他把目前能用他現有功能做到的事，全部整理起來 現在 MOZE 還是比較需要去爬舊文翻，或直接問粉專 但不得不說 MOZE 回復速度真的超快 AndroMoney to MOZE transformater 身為一個攻城獅，當然還是要寫自動化的程式來幫我轉換資料格式 手動要處理 5、6000 筆帳務紀錄有點太累了 btw MOZE 有說之後會提供 web 版的匯入工具 在 MOZE 首頁 FAQ 可以找到要如何匯入資料 ( MOZE 格式 ) 基本上就是照著他的格式就能轉換大部分的資料 當然我也寫了一個小 script AndroMoney_to_MOZE_transformater Script 使用方式 python transformater.py --input_file \"Your input filename\" extract 在轉換的過程中，會有一些資料還是要手動輸入的 其實後來大多時間是花在這 ... 會抓出的資料有 帳戶（以及其起始金額） 專案 主類別、次類別 後來發現還有另一個問題是不同幣別的轉帳， AndroMoney 匯出的資料不會有轉入的金額 所以沒辦法自動化，這點倒是比較麻煩 python transformater.py transformat --input_file \"Your input filename\" --output_file MOZE.csv 再來就是要把原本 AndroMoney 的紀錄轉成 MOZE 的格式 只要把這個 MOZE.csv (一定要是這個檔名) 丟到 Dropbox 的 應用程式/MOZE MOZE 就能找到，並能選擇匯入 踩到的一些坑 寫這個 script 的過程中，其實踩到蠻多坑的 匯入了好幾次才成功 一來這是我第一次從 argparse 換到 click 原本想說 argparse 已經算是蠻好用的了 click 真的又更直覺了一點，難怪這麼多人推薦 第一個遇到的問題就是轉帳的「相關行數」 一開始不知道這個行數是從多少開始 以寫程式來說，我就直接去抓那個 row 的 index 所以抓到的 index 是 0-based 後來想到可以試試看 1-based，還是無法匯入成功 最後才發現還要把標頭也考慮進去 第一個 row 其實 index 是 2 第二個問題是轉帳的類別 文件其實只說不用「子類別」，沒說「主類別」要怎麼處理 xD 我試了各種可能的類別後 自己去匯出了一筆轉帳紀錄，才解決 原來轉帳的主類別分別會是「轉入」跟「轉出」 後來弄完後有再去看一下文件，才發現下面其實有寫 ...... 這些問題我都跟作者反應了，他都超快就回了 他是說之後會透過 web 版的工具匯入 Future Improvement 其實我還是蠻喜歡 AndroMoney 的 所以也許會找個時間寫怎麼把 MOZE 轉回 AndroMoney 的功能會寫個 MOZE to AndroMoney 避免我哪天又想回到 Android 了 xD","tags":"Tech","url":"https://wei-lee.me/posts/tech/2018/09/from-andromoney-to-moze","loc":"https://wei-lee.me/posts/tech/2018/09/from-andromoney-to-moze"},{"title":"GitHub Resume","text":"最近發現了這個可以自動從自己的 Github 上產生履歷的東西 GitHub Résumé 實在有點有趣，就來玩了一下 只要在 repo 上按了 star，你就可以透過 他的頁面 產生你的 GitHub 履歷 基本上就是各種以往的專案和貢獻的統整 我的 GitHub 履歷 果然我光 Python 跟 Jupyter Notebook 加起來就六成了 XD","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/08/GitHub-Resume","loc":"https://wei-lee.me/posts/tech/2017/08/GitHub-Resume"},{"title":"Practical Vim","text":"每天一回一回的看，終於把 Practical Vim 看完了 不過到了後期，大部分就真的都看不太懂了＝ ＝ 所以大多還是只記錄了前期我比較看得懂的一些 tip Ch1: The Vim Way Tip2: Don't Repeat Yourself . command: Repeat the last change Command in normal mode The insert mode between two normal mode Repeatable action and how to repeat them Intent Act Repeat Reverse Make a change . u Scan line for next character f ; , Scan line for previous character F ; , Scan document for next match /pattern <CR> n N Scan document for previous match ?pattern <CR> n N Perform substitution :s/target/replacement & u Execute a sequence of changes qx @x u Ch2: Normal Mode Tip10: Use Counts to Do Simple Arithmetic <C-a> : Add number <C-x> : Sub number What if the cursor is not on a number? Operate on the number after the cursor Combine and Conquer Operator + Motion = Action When an operator command is invoked in duplicate, it acts upon the current line (e.g. dd) Trigger Effect c Change d Delete y Yank into register g! Swap case gu Make lowercase gU Make uppercase > Shift right < Shift left = Autoindent Ch3: Insert Mode Tip13: Make Corrections Instantly from Insert Mode If we make a mistake while composing text in Insert mode, we can fix it immediately Keystrokes Effect <C-h> Delete back one character(backspace) <C-w> Delete back one word <C-u> Delete back to start of line The keystrokes above can also be used in bash shell Tip14: Get Back to Normal Mode <C-o> Switch to Insert Normal mode Tip15: Paste from a Register Without Leaving Insert Mode <C-r>0 : Paste the text that we just yanked at the current cursor position Tip19: Overwrite Existing Text with Replace Mode R : Enter replace mode Ch5: Command-Line Mode Tip28: Execute a Command on One or More Consecutive Lines range :{start, end} : from line \"start\" to line \"end\" . : current line % : all lines Tip31: Repeat the Last Ex Commands @: : Repeat the last Ex command Tip32: Tab-Complete Your Ex Commands <C-d> : Reveal a list of possible completions Tip33: Insert the Current Word at the Command Prompt <C-r><C-w> : Get the word under cursor in Ex mode Ch8: Navigate Inside Files with Motions This chapter is extremely practical Ch9: Navigate Between Files with Jumps Tip55: Travel the Jump List Command Effect [count]G Jump to line number //pattern<CR>/?pattern<CR>/n/N Jump to next/previous occurrence of pattern % Jump to matching parenthesis ( / ) Jump to start of previous/next sentence { / } Jump to start of previous/next paragraph H / M / L Jump to top/middle/bottom of screen gf Jump to file name under the cursor <C-]> Jump to definition of keyword under the cursor / Jump to a mark Ch12: Matching Patterns and Literals Tip74: Use the \\V Literal Switch for Verbatim Searches Put \\V before words when searching can cancel regular expression Ch13: Search Tip81: Preview the First Match Before Execution Use <C-r> <C-w> to autocomplete when searching Ch14 Tip88: Find and Replace Every Match in a File %s/word1/word2/g","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/06/Practical-Vim","loc":"https://wei-lee.me/posts/tech/2017/06/Practical-Vim"},{"title":"Python@Instagram","text":"Lisa Guo, Hui Ding Keynote PyCon 2017 slide 終於好好花個時間看完今年 IG 在 PyCon US 的 Talk 了 的確蠻值得大家花這個時間去看的 如果要看懶人包 Google 一下「PyCon」、「Instagram」有很多很清楚地整理 我也整理了一點點我覺得特別有意思的 Why Python? (一開始主要是歷史因素，因為當初的創辦人就這麼用了 XD) Use Proven Technology Users do not care what database Instagram runs on. They certainly don't care what language Instagram develop in. Focus on scoping and solve real problems rather than getting stuck on language detail. But Python is still slow, right? At instagram, our bottlenecck is development velocity, not pure code execution The conclusion is that you can get to a few hundred million users with Python before worrying about the performance of framework and language Python Efficiency Strategy Build extensive tools to profile and understand performance bottleneck Moving stable, citical compenents to C/C++ Cythonization Async? New Python runtime? Road to Python3 這一段講到 Instragram 如何從 Python2 轉到 Python3 的過程 我覺得很精彩，所以大家就自己去看吧 XD 我只紀錄一個我覺得特別有趣的東西 如同大家所知道的 Python2 跟 Python3 一個很大的不同點，就是對於 byte 跟 str 的處理 這就會導致我們必須先確認他的型態是否符合預期 如果不符合就要在做 encode 或 decode 可能就會像下面這樣 value = 'abc' if isinstance ( value , six . text_type ): value = value . encode ( encode = 'utf-8' ) mymac = hamc . new ( value ) Instagram 處理這種問題的功能實作成 ensure_binary , ensure_str , ensure_text 這類的 helper function 這也是我之前在 trace transitions 的 source code 發現有一個 listify 的 function 雖然是蠻簡單的小技巧，不過還算蠻實用的","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/06/Python-at-IG","loc":"https://wei-lee.me/posts/tech/2017/06/Python-at-IG"},{"title":"PyCon TW 2017 - Sprint","text":"這天的 Sprint 是由今年的 Keynote Speaker - Russell Keith-Magee 帶來他的開源專案 BeeWare 讓大家一起來貢獻 這個專案還蠻有趣的 主要就是要讓 Python 能在各平台上跑 (i.e. web, mobile) 而且這個專案對新手還蠻友善的，文件中就有提供 First Time Contributor 第一次貢獻的人建議貢獻的專案是 voc (Android) 和 batavia (JavaScript) 而且在裡面的 issue 還會標注 first timer only 雖然我其實對 Java 跟 JavaScript 都不熟 但比起來還是對 JavaScript 多了一點愛 所以我就來貢獻 batavia 了 雖然其實我的貢獻大多就是文件上少寫跟一些錯誤 最後還有幫 Python 的 list 轉成 js 加了幾個小 method 原本想解決 args 跟 kwargs 的 issue，但果然還是對 JS 太不熟了ＱＱ 不過覺得整體來說是蠻好玩的 Russell 都會很友善地回答問題 像我一開始採的雷就是 batavia 還沒支援到 Python3.6，他也很熱心幫我解決 我問了好幾個專案的小問題，Russell 都會說 \"That's can be a pull request\" 只要送了 PR 就可以得到 Challenge Coins 拿到這個 challenge coin 其實還蠻開心的 xd 最後再附上在 twitter 上，這次參與 spinrt 的大合照 2017/6/22 折騰了許久，我的 PR 終於被 merge 回 batavia 了 XD 這次的 PyCon 2017 大致就到這裡結束了 這幾篇文章大概先整理了，當時做的筆記 也許之後有時間，再好好看一次影片跟 Slide，重新整理一下所有的內容","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/06/PyCon-TW-2017-Sprint","loc":"https://wei-lee.me/posts/tech/2017/06/PyCon-TW-2017-Sprint"},{"title":"PyCon TW 2017 - Day 3","text":"這天就是 PyCon 的最後一天了 聽說這是 PyCon 第一次引入 Unconference 今年 Unconf 都還蠻有趣的，讓我一直猶豫到底要一般議程還是 Unconference 不過 Unconference 那邊聲音就有點糊聽不太清楚 不知道是不是 R4 場地的關係 議程 [Keynote] From Little Things, Big Things Grow 比美麗的湯更美麗：pyquery Write Elegant Concurrent Code in Python enjoy type hinting and its benefits (我很想聽這場，不過還是先跑去聽 Unconference 了 XD) slide 共筆 Coding test-driven Python package with CI and cloud Unconference Lightning Talk [Keynote] From Little Things, Big things grow. Russell 開場就講了一串中文，引來如雷的掌聲 xD 他在 PyCon 官網的介紹也很有趣 xD 他剩下兩洲就能完成 Python 會議基調演講全大洲制霸； 只要企鵝們願意舉辦 PyCon 南極洲，他很樂意提供演說。 同時，他也在這次 PyCon 的 Sprint 帶來專案跟大家分享 不過 Russell 的英文語速就真的有點快，超過我能好好做筆記的語速了 QQ 共筆 Technical issues are often social Backward Compatibility matters But it also has a price Hard to introduce new features Timing matters Messaging matters Reading the tea leaves (Trend?) The Kick Ass Curve Tool and ecosystem Community matters Accessibility Toxic shock Denial is not a river in Egypt Complaining matters Codes of Conduct in practice Outreach is important Patches welcome Develop a funding culture Make it easy to spend money and receive money do the right things Don't assume resources are free Q & A 這好像是我第一次在 R0 舉手提問 最後因為時間關係沒被叫到 QQ 不過我還是跑到前面去問 Russell，如何在 Backward Compatibility 和 New Fatures 中取捨 Russell 的回答是如果專案已經持續很長的一段時間，並且有一定的使用者 Backward Compatibility 就是一件很重要的事 因為我們並不會希望以前的使用者不能在使用 不過如果是新開始的專案，那就從新的開始就好 像他現在的 Bee Ware 就是全用 Python3 下午 Russell 會給一場跟 Bee Ware 有關的 Talk - Stranger in Strange Land 不過因為標了很高的難度，想說我應該也聽不懂，也先沒去聽了 xd 比美麗的湯更美麗：pyquery slide pyquery 用 jquery 的方式來做 parsing 可以做 crawling ( 一個 lib 就做了 requests + bs4 的事啊！ ) 可以拿 selenium 當 opener 裝不起來的問題，通常是因為 lxml 沒裝好 感覺是一個很值得期待的 library 下次要寫爬蟲，再拿它來試試看 Write Elegant Concurrent Code in Python slide 共筆 Sample Code Concurreny: 一段時間內同時跑 Parallel: 一個時間點同時跑 Why Concurrency? Get the machine into full play! 不要讓 CPU 空轉！ 通常不會用 Python 解 CPU Bound 的問題，而是 I/O Bound 的問題 聽完這場，感嘆自己真的對 Concurrent 還是不太懂＠＠ 雖然我沒記什麼筆記 不過 Slide 很清楚，共筆也記了很多 還附上 Sample Code 了 哪天比較懂 Concurrent 的時候再回來看應該會比較有感覺吧 Unconference 共筆 大會遊戲 line chatbot 黑白亂做 Source Code 懶得答題？寫個 bot 來幫你刷榜 slide Source Code 跟著上面那一個 Unconference 做的大會 chat bot 就有會眾分享如何寫一個 bot 自動去達大會的題目 xdd 覺得很有趣 What Steve Jobs Taught Me about Software Development and Life in General 這就是 Carosell 待過 Apple 的 VP 大致上覺得跟 少，但是更好 Saying, \"No!\" enables focus, flow, success. How to decide when to say \"yes\"? The one that changes your life would be a good one. Lightning Talk 共筆 Lightning Talk 大概是 PyCon 最歡樂的時候了 因為只有 5 分鐘，不然就要被拔線了 大家都得講得很快 今年的 PyCon 金句大概就是 Hisahiro Ohmura 推坑 PyCon JP 的 聽不懂日文？ 沒關係 我也聽不太懂中文 另外，就像 jserv 的 slide 上說的 每年的 pycon 好像都有其他語言的東西混進來，像是 15 年有人根本是在講 d3.js 只是用 python 幫忙準備資料 ; 今年是有人全部都在講 Rust，只是我們用 Rust 寫了個 python module XDDD Lightning Talk 馬上就出現一個 julia 了 xddd 記得兩年前的 PyCon 超多 Julia 的","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/06/PyCon-TW-2017-Day3","loc":"https://wei-lee.me/posts/tech/2017/06/PyCon-TW-2017-Day3"},{"title":"PyCon TW 2017 - Day 2","text":"第二天有一整個時段的 Job Fair，可以出去晃晃到各個攤販聊天 最有印象的大概就是 Carousel，跟他們聊得還蠻開心的 還多玩了幾次他們的大家來找碴 XD 在 conf 看到他們這麼多次，第一次知道他們來自新加坡 隔天還會有一位待過 Apple 的 VP 會來 Unconf 分享 今年還有音樂會呢，覺得還蠻有趣的 雖然聽完有點晚才去吃晚餐，剩的東西都不多了ＱＱ 議程 [Keynote] Building for Failure: Leraning Lessons from Aviation [自py系列2] 投資策略驗證系統 slide 共筆 對話機器人的腦子與靈魂 Bot's Brain and Soul 鄉民教我做的聊天機器人 Why do projects fail? Slide 利用 Python 與人工智慧快速打造人性化聊天機器人 (IBM) Chatbot @ E.Sun Bank – 玉山小i隨身金融顧問的兩三事 (玉山) [Keynote] Building for Failure: Learning Lessons from Aviation slide 共筆 Warnings Soft Failure Hard Failure Obscure errors and try to carry on Quit at the first error and log it Noisy Warnings Engineers ignore logs/notifications Precise Warnings Alert on actionable things, then fix them Raise clear, verbose exception try : requests . get ( 'http://api.com/user' ) except RequestError : raise APIFetchError ( 'Could not get user list' ) Testing 100% Coverage Fallacy Too many tests that are fragile so you ignore them Checklist The step between manual and automation Cheap and very effective Find the limits The Load Testing Chaos Monkey 測試 server 復原能力 Restore from backups The \"Red Team\" 攻擊系統的工程師們 Trade off between Redundancy & Acceptable Loss Redundancy Acceptable Loss What do you fall back to? Quantify the loss, and recovery Team No Single Cause → No Blame Culture Not someone's mistake Systematic Problem Clear command chains Who makes decisions? Who does the fixing? Leadership can blind Debate for what is right Crew Resource Management Increase your \"bus factor\" People get ill → 一個專案至少要 2 個以上的人懂 Good engineering is not just code Communication matters Slower can be faster Testing, Writing Documents make a project slower in short term, but faster in long term Speakers Advice Checklists Restore your backups Work out roughly what happens for every part of a system failing, and if you care Reward people whose code quietly works, not those who firefight and take the glory Checklists 對話機器人的腦子與靈魂 Bot's Brain and Soul 共筆 這場人太多了，連坐下來的位置都沒有ＱＱ 不過共筆寫得很清楚了 我這裡記錄的是會後跟講者討論的一些問題 Q: Language Generation 要怎麼做 Evaluation，怎樣才算是符合文法？怎樣算是合理的回答？ 判定很主觀 很多研究會導入 Human Evaluation 目前還是一個 Open Question Q: 目前關於情緒判斷，是否已經到了 Production 了？ 尚未到 Production 這樣的問題很難做，其中一個原因在於資料很難收集 另一個原因是，就算沒有辦法判斷情緒，通常也不會造成太大的問題。不像意圖如果判斷錯誤，就會提供錯誤的服務 香港科技大學目前有一個可以判斷人格的 Bot( 我找不太到＠＠ ) 鄉民教我做的聊天機器人 slide 共筆 Line Bot Chinese Conversation Data Movie subtitle 主題發散，不太容易收斂 先過去出資料用語 Seq2seq 只能回應簡單的問題 大部分回答都是「我不知道」 PTT 八卦版標題和推文有應對關係 → 問答 Backend & Platform ~48 萬篇文章 Information Retrieval 找出文章標題符合 Jaccard Similarity 不能處理介系詞 Modified BM25 針對重要的字給予較大的權重 TF 對短句比較不好用 → 用詞性作為權重 Tried Improvements Tokenizer Improvement Emoji icon pre-processing Improve tokenizer accuracy 把 jieba 換成用繁體中文字典，並加入 PTT 會用的常見詞彙 Keyword Extraction & Association Word2Vec → Query associative term if the original one doesn't exist Evaluate Represent for document with vector Doc2Vec (gensim) RNN-encoder (arXiv: 1506.08909v3) NDCG 量化標注 讓那篇文章的回應當作 ground truth 來評斷機器人產生的結果好不好 利用 Python 與人工智慧快速打造人性化聊天機器人 (IBM) Source Code 有溫度的聊天機器人 輔助性答案 ( 互動性 ) 引導性回饋 → 開放話題 不定時提醒 → 貼近使用者 隨機答案 → 提高趣味 學習與進化 Multi-channel ( 多渠道互動 ) Watson NP, ML 的語意理解 Zero Downtime 擴充 可訓練 搜尋引擎 Watson AI Flow Intent, Parameter, Entity Type Chatbot @ E.Sun Bank – 玉山小i隨身金融顧問的兩三事 (玉山) slide Q & A 還有沒有其他的 客訴 問題呢","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/06/PyCon-TW-2017-Day2","loc":"https://wei-lee.me/posts/tech/2017/06/PyCon-TW-2017-Day2"},{"title":"PyCon TW 2017 - Day 1","text":"今年 PyCon 終於比起上次聽得懂多了！ 看來這兩年來，還是有點進步的 XD 先放上今年的 共筆 這幾篇記錄我參加議程的筆記 有些投影片跟共筆就很清楚的，就直接放連結了 議程 [Keynote] Choices for Smarter AI Python 開源軟體考古 - 以Viper為例 整合 Slack 與 Docker 搭建 Jupyter 線上程式面試系統 [Keynote] The State of Python for Education Learning Building Microservices in Python 個案分享 Slide 共筆 Understanding Serverless Architecture 同場加映： Don't Reinvent Sandwich (本議程沒供餐 XD) Tensorflow & Python: Fault Detection System [Keynote] Choices for Smarter AI 共筆 Better AI Traditional: 更像人類 New: 更好用 Choice[0]: What Language for AI? 現場會眾一致通過是 Python (Bias Sampling XD) Useful libs xgboost libact : Active Learning Choice[1]: What Application Should AI Help? AI Starts From Problem Solving Motivation Publishable (academia), Profitable Feasibility Modeling, Timeline, Budge Big Problems from Big Data Velocity: Evolving data, Evolving problems Volume: Computational Bottleneck Veracity: Modeling with non-textbook data → Noise, Bias Choice[2]; What Route for AI Human-er Machine-er Subjective Objective Domain Knowledge Computing Power Fast Basic Solution Continuous Improvement Tip: As much human as possible before going to machine Choice[3]: How to Measure AI Goal? Tip: Start with reasonable, measurable and prioritized goals for AI Choice[4]: What Data to (or not to) Use? Choice factors for data Utility: Relationship with goal Necessity: Uniqueness to goal Quality: Noise, Freshness Cost Tip: Start with \"minimum viable data\" Choice[5]: What Model to Start? Linear (Simpler) Model First Choice[6]: What Improvement Steps to Take? Lose Reason Overfitting Misfitting Over-reusing Keep data fresh Choice[-1]: How to verify and Deploy? Code Deployment Workflow AI Deployment Workflow Development → Staging → Production Offline → Online → Production Human Trust matters Need a baseline to be compared Misc[0]: No Choice is a Choice Misc[1]: Learning from Mistake Misc[2]: ??? Python 開源軟體考古 - 以 Viper 為例 這場很實用，slide 也很清楚 蠻推薦影片出來可以看一下 slide 共筆 viper-research 從開源專案學習寫 code 讀 code 技巧 降低專案複雜度 從早期版本追 如何挑版本？ ( 搭配 tig 服用 ) 重大版本號 簡單、可運作之版本 (e.g. viper 的 commit hash: 46a2a ) 感覺太複雜？ 砍！ 鎖定特定功能，移除其他雜質 測試，能動就可以 專案程式邏輯架構 模組相依性 → 一直 trace 到沒有 import 專案自己寫的 code Tools modulegraph pydegraph (py2degraph) snackfood 數據分析 e.g. 被用最多的反而不是核心 → 這些程式碼好用、易用 走訪專案 建立專案整體架構邏輯 深度走訪 由下往上 仔細閱讀單一程式 廣度走訪 由上往下 解釋特定組合的程式的意義 Conclusion 系統化讀 code 從 Commit 學習 架構變化 Commit Message 規則 Branching Model Issue Handling 整合 Slack 與 Docker 搭建 Jupyter 線上程式面試系統 slide pnp-interview 共筆 這場最重要的大概就是 slide 第 12 頁 第 11 頁的架構圖 Tools Used Flask Python 中最簡單使用的 web framework 做小型 web 應用非常適合 Docker 容器化 一鍵部署 限制容器耗費的 CPU, GPU Slack Integration 很好 Bugs Pull Image First So it can be fast Try except for any case dockerpy 的雷 xD File Permission 要採 docker 坑，這很重要 [Keynote] The State of Python for Education Learning slide 共筆 這場 Talk 主要講學習、推廣和社群 Carol 有提到幾個學習 Python 很棒的資源 其中我覺得最有用的大概就是 pyvideo.org 了 之前回去聽工資管系系友演講，趨勢的學長就有提到看 Talk 是很快的學習方式 另外，Carol 強力推薦今年 PyCon US，Instagram 給的 Talk Lisa Guo, Hui Ding Keynote PyCon 2017 之後，應該也會找個時間來看一下 Understanding Serverless Architecture slide 共筆 Serverless Function as a service (FaaS) e.g. AWS lambda Advantage Don't need to maintain servers Disadvantages Functions are allowed to run for only a limited amount of time Heavy workloads cannot be run No control over containers Hard to monitor Hard to scale up It's awesome but not the best choice for everyone. Tensorflow & Python: Fault Detection System slide 共筆 Fault: An abnormal condition or defect at the component Logs Usage of CPU Memory Disk I/O Network Bandwidth System Log Application Log and etc. Log is also natural language. The sequence of words and expression is important sequential data. 這場我真的就有點聽不太懂了＠＠","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/06/PyCon-TW-2017-Day1","loc":"https://wei-lee.me/posts/tech/2017/06/PyCon-TW-2017-Day1"},{"title":"Common Neovim Problems","text":"Load ~/.vimrc from neovim mkdir -p ${ XDG_CONFIG_HOME := $HOME /.config } ln -s ~/.vim $XDG_CONFIG_HOME /nvim ln -s ~/.vimrc $XDG_CONFIG_HOME /nvim/init.vim No python interpreter found. pip install neovim Reference .nvimrc doesn't seem to be loaded up or working and it cannot create backups on editing existing files No python interpreter found.","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/05/common-neovim-problems","loc":"https://wei-lee.me/posts/tech/2017/05/common-neovim-problems"},{"title":"[Paper] Deep Learning-Based Document Modeling for Personality Detection from Text","text":"Paper Implementation: Personality-Detection Data Set James Pennebaker and Laura King's stream-of-consciousness essay dataset NRC Word-Emotion Association Lexicon Practical Application of Personality Detection Product and Service Recommandation (People with similar personalities might have similar favors) Mental Health Diagnosis Forensics: Reduce the circle of suspects Human Resource: One's suitablitlty for certain jobs Personality Theory Used in This Paper Big Five Personality Trait Basic Idea of the Method Feed sentences from essays to convolution filter → Sentence model in the form of n-gram feature vectors Aggregate the vectors of a document's sentences and combine them with Masiresse features to represent the document Classification: Feed the document vectors into a fully connected neural network Overview of the Method 1. Preprocessing Sentence Splitting Data Cleaning Unification (e.g. lowercase) 2. Document-level feature extraction Mairesse baseline feature set (e.g. word count, average sentence length) 3. Filtering Sentences without personliaty clues are dropped (Based on NRC Word-Emotion Association Lexicon ) 4. Word-level feature extraction word2vec Variable number of fixed-length word feature vectors → Variable number of sentences → Document 5. Classfication Deep CNN (Conolutional Nerual Network) Input Words: Fixed-length feature vector using word2vec Sentences: Variable number of word vectors Process Word Vector is reduced to a fixed length vector of each sentence Document: Variable number of such fixed-length sentence vector Document vector is then reduced to a fixed-length document vector This Document vector is then concatenated with document-level features Predict Yes / No (5 different personality traits are trained separately) Network Architecture in Detail Main Steps (7 Layers) Word Vectorization Layer 1: Input \\(R &#94;{D \\times S\\times W \\times E}\\) Use Google's pretrained word2vec In implementation, all the documents contain the same number of sentences. Shorter documents are padded shorter sentences with dummy words. Sentence Vectorization Layer 2: Convolution 3 convolutional filters: unigram, bigram, trigram Layer 3: Max Polling Document Vectorization Layer 4: 1-max pooling Classification: (Yes/No) Layer 5: Linear with Sigmoid activation Layer 6, 7 2 Neuron (yes/no) Softmax Output (ReLU and tanh perform worse) fully connected layer of size 200 Training Objective Function: Negative Log Likelihood","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/04/Deep-Learning-Based-Document-Modeling-for-Personality-Detection-from-Text","loc":"https://wei-lee.me/posts/tech/2017/04/Deep-Learning-Based-Document-Modeling-for-Personality-Detection-from-Text"},{"title":"[Paper] Understanding Personality through Social Media","text":"Paper Main Purpose: To see how linguistic features correlate with each personality trait. Use Twitter to predict MBIT personality. Problem of Past Researches Language on social media has richer content that makes the typical linguistic analysis tool perform poorly (e.g. iono → I don't know) Gain personality information is costly (e.g. Big Five Questionnaire) MBTI Instead of commonly used big five theory, MBTI is used in this paper. Myers-Briggs Type Indicator There are 4 types of personality trait i.e. Introversion(I) / Extroversion(E) Intuition(N) / Sensing(S) Feeling(F) / Thinking(T) Perception(P) / Judging(J) Personality can be expressed as a code with 4 letters. e.g. ENFJ, INTP Data A Twitter dataset Around 90,000 users 120,000 personality-related tweets from 2006~2015 (out of 1.7 M tweets) What is the so-called personliaty-related tweets? English Tweets that contain users' own MBIT code. e.g. \"I'm an ENFJ\" is qualified \"My friend is an ISFJ\" is not qualified Heuristic rules is used (e.g. \"I'm\" , \"I got\" , \"I have been a\" ) No classification method is used for ensuring the personality code is indeed the user's Distribution Personality distribution of this data is skewed. However, in the real word, the personality distribution might also be skewed. Features 1. n-grams Most frequent 1,000 unigram, bigram, trigram words and phrases 1,000 dimensions vectors for unigram, bigram trigram for each user 2. Twitter Part-of-speech tags Based on Part-of-Speech Tagging for Twitter: Annotation, Features, and Experiments 25 types with some Twitter-specific tag. e.g. hashtag at-mention URL emoticon 3.word vectors Word Vector Settings 2,334,564 words 500 dimension Extracted Features Average word vectors Weighted average word vectors (weighted according to TF-IDF) Prediction Logistic Regression is used (Random Forest and SVM produced similar results) Accuracy Measurement Since the data is skewed, AUC is used. Accuracy Indivisula Features Word Vector Only → (AUC=0.651) n-gram only → (AUC=0.607) POS only → (AUC=0.585) Combined Features All three features → (AUC=0.661) POS + n-gram → (AUC=0.616) Insight Among the results, word vector performs best which might illustrate that predictions based on social media and language would work. During the POS conversion process, information is compressed into 25 tags and might lost some important one. This might be the reason why it performs worse.","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/04/Understanding-Personality-through-Social-Media","loc":"https://wei-lee.me/posts/tech/2017/04/Understanding-Personality-through-Social-Media"},{"title":"[Paper] Toward Personality Insights from Language Exploration in Social Media","text":"Paper Demo My Slide The main purpose of this paper is to show how social media can be used to gain psychological insights. Different from other papers in the past which use a pre-compiled word category list (e.g. LIWC), it uses an open vocabulary approach that allowing discovery of unanticipated language. Data 75,000 Volunteers Facebook Status Update Age Gender Personality (Through Standard Personality Questionnaire) Architecture Linguistic Feature Extraction N-Gram Point-Wise Mutual Information Topic Probability a person mentioning a topic (Derived from LDA) Correlation analysis Least Squares Linear Regression Visualization Differential Word Clouds Word size represents correlation strength. Color represents relative frequency Standardized Frequency Plot Plot the word frequency against age Result Most results confirm what is already known or obvious. However, I think this method might still be useful to gain insight in other kinds of datasets.","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/04/Toward-Personality-Insights-from-Language-Exploration-in-Social-Media","loc":"https://wei-lee.me/posts/tech/2017/04/Toward-Personality-Insights-from-Language-Exploration-in-Social-Media"},{"title":"Create a Telegram EchoBot","text":"最近當助教要出一個 Telegram Bot 相關的 Project 先來寫一篇簡單的教學，減少之後的問題 XDD 如果對 Chat Bot 的基本運作概念不太熟 可以參考 [Bot] Introduction to Chatbot What is Telegram 在台灣，好像還沒有那麼多人用 Telegram 簡單來說就跟 Facebook Messenger 或 Line 這類的 IM 差不多 Why Telegram 至於這次為什麼要選用 Telegram 麻 是因為上次有聽其他開發者說 Telegram Bot 提供相當多的功能 就想說來試試看 Web Framework 上次寫 Line EchoBot 的教學是用 django 這次來試試 Flask Source Code 一樣放在 GitHub 上 這篇文章會用 minimal-flask branch 當範例 只有 31 行 Code，比較容易理解 master 上也是用 Flask 只是架構比較複雜，有試一下 Flask 的 blueprint，之後可能還會多加一些奇怪的功能 xd Apply a telegram bot 首先當然必須要有 Telegram 的帳號 再來要加 BotFather 為好友 跟他說 /newbot 接著他會問你，Bot 的 name 跟 username name 是 Bot 在聯絡人資訊顯示的名稱 username 則比較像 id 的概念，而且一定要用 Bot 結尾 之後就會得到剛申請 Bot 的 API Token 然後你就可以從 https://telegram.me/<bot_username> 找到剛申請的 bot Telegram Bot API Wrapper 開發上，我使用的是 python-telegram-bot pip install python-telegram-bot 它其中一點設計的很不錯的是 Telegram API 的命名是 CamelCase (e.g. sendMessage) 但 Python 的命名 convention 卻是 lowercase_separated_by_underscores (e.g. send_message) 而它是兩種都支援 Star Programming 先附上全部的 code，後面再慢慢解釋 import sys import telegram from flask import Flask , request app = Flask ( __name__ ) bot = telegram . Bot ( token = 'Your API Token' ) def _set_webhook (): status = bot . set_webhook ( 'https://Your URL/hook' ) if not status : print ( 'Webhook setup failed' ) sys . exit ( 1 ) @app . route ( '/hook' , methods = [ 'POST' ]) def webhook_handler (): if request . method == \"POST\" : update = telegram . Update . de_json ( request . get_json ( force = True ), bot ) text = update . message . text update . message . reply_text ( text ) return 'ok' if __name__ == \"__main__\" : _set_webhook () app . run () Setup 其中有兩個地方，必須要改成自己的設定 1. API Token bot = telegram . Bot ( token = 'Your API Token' ) Your API Token 要改成剛剛取得的 API Token 2. Webhook URL _set_webhook 中的 Your URL statue = bot . set_webhook ( 'https://Your URL/hook' ) 這裡的 URL 就是設定成你這個 Bot Server 的 URL 不過 Telegram 一樣要求必須要是 https 最簡單的方式就是使用 ngrok (ngrok 的使用在 [Bot] Line Echo Bot on Django 最後面有介紹 ) 平常測試使用 ngrok 就很足夠了 之後要 production 的時候，在 deploy 到適當的 server 就好了 _set_webhook Telegram 有兩種接收訊息的方式 隨時去監聽的 webhook，和主動去要求更新的 get_updates 這裡使用的是 webhook 這個 function 先設定 Bot 的 webhook URL，如果設定失敗就直接終止程式 也就是告訴 Telegram 要把 Bot 收到的訊息傳到哪 而 set_webhook 前面要有個 _的原因是我不希望它被其他的 code 使用 但 Python 本身並不支援 Private 的概念，而是慣例上在前面加一個底線 def _set_webhook (): status = bot . set_webhook ( 'https://Your URL/hook' ) if not status : print ( 'Webhook setup failed' ) sys . exit ( 1 ) 在最後 run Flask app 前，要先把 webhook URL 設定好 if __name__ == \"__main__\" : _set_webhook () app . run () wehook_handler 這裡就是 bot 收到訊息要怎麼處理 @app . route ( '/hook' , methods = [ 'POST' ]) def webhook_handler (): if request . method == \"POST\" : update = telegram . Update . de_json ( request . get_json ( force = True ), bot ) text = update . message . text update . message . reply_text ( text ) return 'ok' app.route 這個 decorator 是 Flask 的語法 表示 https:/Your URL/hook 會導到這個 function，而它只能接受 POST 這裡設定的 /hook 也就是為什麼在 _set_webhook 中的 URL 最後面必須有 /hook 另外還可以發現 webhook_handler 是不帶任何參數的 跟 django 不同的是 Flask 把 request 這種幾乎所有 view function 都會用到的參數直接變成全域可讀取的變數 也就是最一開始的 from flask import Flask , request 接下來 webhook_handler 內做的就只是把收到的訊息轉成 update 再從裡面讀到對方傳來的 text 最後用 reply_text 回傳同樣的 text 回去 這是最簡單的 Telegram Bot 不過我覺得開始學一個東西，還是會希望能在最短時間看到點東西，再慢慢專研 接下來可以從 python-telegram-bot 的 wiki ，試更多 Telegram Bot 的功能 Reference Simple-Echo-Telegram-Bot 開發 Telegram Bot 簡介","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/03/create-a-telegram-echobot","loc":"https://wei-lee.me/posts/tech/2017/03/create-a-telegram-echobot"},{"title":"[Book] 做工的人","text":"「做工的人」由一個個藍領階級的故事所組成 說的是那些壓迫、歧視和無奈 看這本書是會讓人感到很難過的 處於同溫層 常會覺得世界就只是我們看到的樣子 但世界並不是單一面貌的 每個人所看到的、所感受到的世界都是不同的 而「做工的人」帶我們用不同的角度來看他們所看到的世界究竟是如何的 不同於以往這書摘 這篇會多了一點我自己的想法 同樣的，這也不過是這世界上一個微不足道的人的想法罷了 摘錄 我想如果只看這些摘錄文字，應該會不知道在說什麼 XD 不過它們都代表著每一個故事的一小部分 也是在故事中，讓我有感觸的部分 記錄下它們，是為了提醒我不要忘了現在看完這本書的感受 推薦序 - 如果在工地，一個年輕作家的養成 他看見，年輕不羈的工人願意將寶特瓶壓扁資源回收，是為了讓附近的低收入戶可以拿去賣錢。 學有專精的電焊師傅，在得知外勞的悲慘待遇後，會願意將一身技藝傾囊相授，好讓弱者掙脫被壓榨的命運。 阿忠之死 晚上，阿忠的嫂嫂說阿忠的喪事已經辦好了，打來是為了要告訴我：「阿忠對於自己沒能還你那五千元，很對不起。」 生命是有層次的，一層一層剝開後，每一片回憶都會讓人流淚。 台灣媳婦 如果我們判斷人的標準，是用刻苦，是用勤奮，是用力爭上游的努力和對於生活的認真，去決定一個人的品格 那我們不可能看不出來她們值得擁有尊敬，我們又怎麼能夠允許這個社會將它們分別列上不同的標籤呢？ 我們既然知道以一個人的經濟條件去判定其社會階級以及地位是錯的，並深惡譴責，那又為什麼不改變對她們的看法呢？ 隔閡 那種講理財和產業動態的書從來就無法引起我的興趣。 曾幾何時，我發現自己在看任何文字或是哥與、電影時，總感覺到一股不舒服感。 這些文字似乎與我有著隔閡。 我想，是那種對於內容的不快感使我感到很大的不舒服。 而我很清楚，這來自於我親身的感受和所在的位置，與那些撰書者或是創作者不同。 愈是和這個世界接觸越深，我就愈明白其中的差異。 也因此，我始終不能接受論述式的教科書、自以為高深莫測的經文，也討厭那些成功者的傳記和論述。 我知道，我這樣是畫地自限，為自己設下了這樣的隔閡。 可是會不會哪天我也和那本商周一樣，只能在自己的世界裡，看著自己所要的內容？ 看板人 這社會要求他人有尊嚴活著的，幾乎都是不需為下一餐煩憂，並且收入穩定的人。 而我不是，我能理解他們只是想活著，卑微和努力的活著。 對於那些喊著尊嚴的人，因為那傷痕我無言以對。 摘錄以外 在翻開這本書之前 我有看到一篇關於它的文章 下面得回覆就有站在不同立場的師傅的評論 說它美化了很多不應該存在的錯誤 並不是每個師傅都會犯這樣的錯，而那些錯並不是這麼的美麗 但翻完「做工的人」後 我覺得其實作者並沒有說那些事是對的 只是敘述了這樣的事情確實存在著，而它們為什麼存在 「做工的人」不會是這世界的全貌 也不見得能代表整個藍領階級的故事 就像前面也提到有不同立場的師傅提出他們的看法 但我覺得它已經足夠讓我們重新去思考 那些認為是理所當然的事，並不是那麼理所當然 自以為是的正義，不見得就是正義 而我們又是多麼習慣於帶著有色的眼鏡，去看、去批評、去攻擊與我們不同的人們 我很喜歡張獻忠先生在 TEDx Tainan 2016 說的話 如果今天換作是我們遇到同樣的處境 我們真的能處理得更好嗎？ 也許在下次評斷一件事前，去想想這樣的問題，能看到更多 這樣的同理並不是、也不會讓對的事情變錯的，或錯的事情就變成對的 而是嘗試去思考，除了對錯以外的事 最後我想分享一段節錄自實驗室學長在上大學部的課時說過的話 回高中聊天的時候，會發現有些在比較後面學校的同學 他們的家境可能並不是那麼好，可能要打工存學費 生存都是件辛苦的事了，很難有餘力在做出太多的改變 而我們是一群夠幸運的人，能順利地唸到成大 所以可以想想，我們是不是能再多做些什麼改變 除了認知到這些幸運不是那麼的理所當然外 我想再補充的是 在想想還能做什麼改變的時候 是不是也能站在那些不那麼幸運的人們的角度，來思考這些改變 讓這些改變，也可以為他們發聲","tags":"Book","url":"https://wei-lee.me/posts/book/2017/03/worker","loc":"https://wei-lee.me/posts/book/2017/03/worker"},{"title":"SITCON 2017","text":"聽說這次 SITCON 一分鐘就賣完了＠＠ 還好我申請了開源貢獻票 xdddd 所以大家快來貢獻開源專案，脫離搶票吧（？？？？？ RO 共筆 R1 共筆 R2 共筆 R3 共筆 這次大概就這兩場比較印象深刻 前端工程的過去、現在與未來 slide 整體算是給完全不懂前端的我，關於前端的知識 overview Present Webpack 未來可能取代 Gulp 與 grunt Babel : 目前最主流的 Javascript Transpiler e.g. 轉換 ES6 → ES5 雖然 ES6 支援模組標準，但瀏覽器尚未有定論，目前前端依然無法支援模組 可以用 webpack 打包來模擬 非同步處理 : ES6 Promise, async/await 第一次做光劍就上手 slide 雖然隔壁兩場，一場在講 Chat Bot，一場在講 AI 我好像應該去聽 但身為星戰迷，實在無法抵抗光劍的誘惑 The force is strong in this session 一把最簡單的光劍大概台幣 1000 可以起來 感覺有時間蠻值得來玩玩的 xD","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/03/sitcon-2017","loc":"https://wei-lee.me/posts/tech/2017/03/sitcon-2017"},{"title":"Tool for Checking Python Coding Style","text":"Pylint Setup pip install pylint Usage Generate a code quality report pylint your_code.py Customize your pylint settings Some rules in default settings might be too trivial. (e.g. PEP8 E501: line too long error (no more than 79 characters) ) Generate pylintrc file pylint --generate-rcfile > ~/.pylintrc This generate a common used pylintrc . For further customization, you'll have to change this file. Generate a code quality report using you pylintrc pylint --rcfile ~/.pylintrc you_code.py Integrate with Vim 1. ale ale also supports other linters in other languages. It uses the new async feature in vim 8. Thus, it checks your code when you are typing. (You can disable it.) The following settings are for pylint in ~/.vimrc # The default value is pytlinh # If your pylint executable is not pylint, it should be set let g:ale_python_pylint_executable = 'pylint' # options of your pylint command let g:ale_python_pylint_options = '--rcfile ~/.pylintrc' All the available linters are enabled by default. For Python, flake8 , mypy are also used. Thus, you might find that even if you ignore some rules in pylintc , you are still notified. In this case, add the following setting in ~/.vimrc let g:ale_linters = { \\ 'python' : [ 'pylint' ] , \\} This enables pylint as the only linter for Python p.s. mypy , flake8 are also great linters. I'm just not familiar with it 2. python-mode It's a powerful package supports not only linters but also plenty of useful features a python programer would need. Unlike ale , python-mode check your code only when you save or open your python file (You can set this in your ~/.vimrc ) Add these lines in ~/.vimrc to enable pylint let g :pymode_lint_checkers = [ 'pyflakes' , 'pylint' , 'pep8' ] let g :pymode_lint_ignore = \"C0111,W0621,E501,F0002\" Note that space cannot appear in pymode_lint_ignore","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/03/tools-for-checking-python-coding-style","loc":"https://wei-lee.me/posts/tech/2017/03/tools-for-checking-python-coding-style"},{"title":"[Book] 此人進廠維修中","text":"這本書不談情緒管理，而是如何與情緒共處 我總覺得這些有關情緒的書，要做筆記實在是一件很困難的事 不過這裡就稍微紀錄比較能紀錄的部分吧 序： 接受不是認同，而是允許存在 身體或心理的痛苦，其實都帶著一些訊號 當你願意接受、承認這份痛苦的存在，並允許它有存在的空間 才可以客觀、中立的觀察它要傳達的訊息 負面情緒從來都不是問題，造成問題的常常是我們面對的方法 允許這些情緒的存在，把用在對抗負面情緒的能量拿回來，放在理解情緒所帶來的訊息上，從中學習而成長 Ch4 - 談後悔 我們總在問別人：「該怎麼辦？」 美其名是參考別人的意見，實際上只是想要別人幫我們做決定 一旦後果不如預期，我們可以將責任歸咎於別人 但事實上，最後決定是否聽取意見，也還是我們自己決定的 後悔，是在告訴我們原有的決定行不通了，該轉向了！就只是如此而已 轉向很麻煩，但比堅持走那條不會抵達的老路還來得有效 Ch5 - 談孤單 孤單提醒我們建立有意義的人際連結 判定你與某人之間存在著「有意義的人際連結」的一個指標，是你們之間的對話內容 是不是有大部分會是聚焦在個人化的議題上，也就是個人的思想、觀點、情感、願景、期待、決定 ... 等 Ch8 - 談憂鬱 試圖安慰處於極度傷心難過中的人盡量往好處想，是沒有用的 反而只是會讓當事人感受到不被理解 因為這麼做無疑是否定了他們此時此刻的真實感受 如果真的得做點什麼，讓自己不再憂鬱，就試著做這兩件事吧 保持正常作息 出門運動並曬點陽光 Ch9 - 談失落 沒能好好說再見，常是關係失落中最令人遺憾的事情，也是人無法走出失落的原因之一 失落的情緒很可能會一在反覆出現，而這是再正常不過的 一旦來了，就允許它存在 只要知道，那都是在提醒我們曾經有著一段令我們在意的關係就好了","tags":"Book","url":"https://wei-lee.me/posts/book/2017/03/take-a-rest","loc":"https://wei-lee.me/posts/book/2017/03/take-a-rest"},{"title":"[Book] 如何閱讀一本書","text":"Ch2 - 閱讀的層次 法蘭西斯 · 培根：「有些書可以淺嚐即止，有些書是要生吞活剝，只有少數的書是要咀嚼與消化的」 Ch4 - 閱讀的第二層次：檢視閱讀 假設一個常見的狀況「你想要發掘所有的東西，但時間卻很有限」 這時候得先做的就是略讀 先看書名頁，有序就先看序 目錄 檢視索引 出版者介紹 挑幾個跟主題相關的章節看 隨意在書中挑幾個小段落看 頭一次面對一本難讀的書的時候，從頭到尾先讀完一遍，碰到不懂的地方不要停下來查詢或思索 Ch5 - 如何做一個自我要求的讀者 主動的閱讀基礎 : 一個閱讀者要提出的四個基本問題 整體來說，這本書在談什麼？ 作者細部說了什麼，怎麼說的？ 這本書說得有道理嗎？全部都有道理呢？還是部份有道理？ 這本書跟你有什麼關係？ Ch7 - 透視一本書 對於「整體內容」這件事，模糊的認知是不夠的 只有一個方法能知道你是否確切清楚的了解 你必須要能用幾句話，告訴你自己或別人，這整本書在說的是什麼 分析閱讀的第一個階段，找出一本書在談些什麼的四個規則： 依照書本的種類與主題做分類 用最簡短的句子說出整本書在談些什麼 按照順序與關係，列出全書的重要部分。將全書的綱要擬出來之後，再將各個部分的綱要也一一列出 找出作者在問的問題，或作者想要解決的問題 Ch9 - 判斷作者的主旨 分析閱讀的第二個階段，找出一本書到底在說什麼的規則： 詮釋作者使用的關鍵字，與作者達到共識 從最重要的句子中抓出作者的重要主旨 找出作者的論述，重新架構這些論述的前因後果，以明白作者的主張 確定作者已經解決了那些問題，還有哪些未解決的。在未解決的問題中，確定哪些是作者認為自己無法解決的 Ch13 - 如何閱讀實用型的書 任何實用型的書都不能解決該書所關心的實際問題。一本理論性的作品可以解決自己提出的問題。但實際的問題卻只能靠行動解決","tags":"Book","url":"https://wei-lee.me/posts/book/2017/03/how-to-read-a-book","loc":"https://wei-lee.me/posts/book/2017/03/how-to-read-a-book"},{"title":"git ignore-io 與 開源貢獻經驗","text":"雖然已經隔了一年多 當初 git ignore-io 這個小功能，也是花了一兩個月 好不容易才 git extras merge 回去的 當初看到這封信的時候，很是感動啊 xd git ignore-io 這個工具主要是從 gitignoore.io 上下載 .gitignore 的範本 e.g., git ignore-io -a vim osx python 像這就是 vim 常見的暫存檔們 一般來說應該被忽略掉，不用被 commit # Created by https://www.gitignore.io/api/vim ### Vim ### # swap [._]*.s[a-v][a-z] [._]*.sw[a-p] [._]s[a-v][a-z] [._]sw[a-p] # session Session.vim # temporary .netrwhist *~ # auto-generated tag files tags # End of https://www.gitignore.io/api/vim 當初可是連文件都要寫好，才會被作者接受 所以我這裡就直接沿用我當初寫的文件了 xD Without option, git ignore-io <type> shows the sample gitignore of specified types on screen. $ git ignore-io vim # Created by https://www.gitignore.io/api/vim ### Vim ### [ ._ ] *.s [ a-w ][ a-z ] [ ._ ] s [ a-w ][ a-z ] *.un~ Session.vim .netrwhist *~ To export it to .gitignore file you can use the following options: -a or --append to append the result to .gitignore -r or --replace to export .gitignore with the result git ignore-io vim python For efficiency, git ignore-io store all available types at ~/.gi_list . To list all the available types: -l or -L : These two options will show the list in different format. Just try it. You can also search type from the list by: -s <word> or --search <word> $ git ignore-io -s ja django jabref java ninja 為什麼要貢獻開源專案？ 貢獻開源專案最主要的原因 還是就是 我需要這個功能啊！！！ 但是就沒有人寫，bug 沒有人修 所以就只好先承認自己就是「沒有人」了 xd 其實 gitignore.io 本身就有提供一個簡單的 script gi 不過實在有點不夠我用 xD 於是我就寫了 gi_extension 後來又覺得，如果整併的 git extras 我就能透過 homebrew 安裝了 (????? 整個從 pull request 到 merge 的過程其實蠻有趣的 我找到當初我開的 pr #439 和 pr #448 從 shell script 的風格（有人建議我用 shellcheck ）到 command 的 option 為什麼要這樣命名 都有人跟我討論，給我建議 從中也學到了很多 貢獻這些專案還能去申請 SITCON 跟 COSCUP 的開源貢獻票，這樣就不用跟大家搶票了","tags":"Tech","url":"https://wei-lee.me/posts/tech/2017/02/git-ignoreio-and-open-source-experience","loc":"https://wei-lee.me/posts/tech/2017/02/git-ignoreio-and-open-source-experience"},{"title":"[Book] 看！情緒幹得好事","text":"本書鼓勵你接受一切無法改變的事情 (e.g. 你的個性、行為、感情、工作 and etc.) 並提供方法更有效的管理人生難題，而 不是妄想去改變他們 上面這段話節錄自這本書的前言 比起一般心靈勵志的書 這本書更要告訴你的是「面對現實」 我們得接受很多事情不是我們所能改變的 尤其是那些我們以為只要努力就一定可以做到的 但這本書也試圖提供一些實際的作法，給我們一點面對人生難題的方向 如果努力過還是失敗了，就試著接受無法改變的現實吧 接受，從來就是不是件容易的事 也許就算這麼做了，還是是會不開心 但自我責備和衝動行事，只會一切更糟 試著與這些情緒或無法改變的事共存，並讓自己的人生更好 這本書的原文書名是 \"F*ck Feelings\" 每一個章節的原文甚至全都用 Fuck 當作開頭 不過目錄的中文翻譯倒是沒這麼直接 每一個章節都有很多個小問題 每個小問題都會有下面這些內容 問題概述 那些你想做到，而做不到的事（e.g. 突然哪天醒來，憂鬱症就好了） 遇到這個問題，人們許下的願望（真正想達到的事） 案例分析 簡易自我診斷表 無法企及的心願 切合實際且可達成的目標 你能做的事 真心話練習腳本 （一個範本，讓你可以帶入各種角色、事件，對你或其他人說） 不一定會有的額外補充 前言 - 你訂下什麼目標 接受吧！有些失去就是一輩子的痛，所以別再鑽牛角尖 請習慣帶著一顆沈重的心活著，努力開創比現在更好的人生 該死的做更好的自己 上癮的自我治療 自我批評或祈求誘惑那天突然消失，都對戒除上癮沒有幫助，而是要接受癮頭存在的事實 你得用盡全力對付它，才不會把力氣浪費在自我怪罪、虛假希望、絕望與自憐上 該死的做更好的自己 克服身障缺陷 隱藏疾病或迴避治療往往讓情況更糟 你能做的就是接受它，即便會尷尬或對自己失望 人們唯有真正了解你的疾病，才會尊重你管理疾病的方式，進而幫助你對付它 說出你真正的問題，並非告解，而是聲明 該死的公平正義 洗刷污名 當你被不實指控時最大的錯誤就是用事實與理智反擊 你的目的不是要證明敵人錯了，而是要避免你的人生被敵人和他的指控糾纏 討公道 失去了你覺得不該失去的東西後，也許會發現自己無法走出悲傷 直到找到能平衡不平的東西或賦予「失去」意義 其實你真正需要的是打擊某個根深蒂固的假說，也就是「不會發生不公平的事」 如果你法停止遺憾，請思考這麼做的代價 體驗美好卻不願放手是要付出代價的 請建立一套對抗懊悔與渴望公平的哲學，人間本來就不存在公平 該死的熱心助人 助人的感覺驅使我們努力改變他們，不管做不做得到，也不顧會不會產生意想不到的後果 犧牲奉獻做公益 這是你想擁有但很可能缺乏的力量之一： 神奇的後見之明 保證你的援助不會損及對方文化，也不會引發嫉妒 不會因為破壞而造成反彈，更保證人們對你的援助只有感激與敬佩 該死的心平氣和 緊張、恐懼還或是憤怒，人生所有的都不愉快是無法避免的 另一個角度來看，這些情緒都是有益的，它們讓我們對外在世界多一份警戒 如果你真的想致力過完全平靜的人生，你只能這麼做 大腦額葉切除成功，成功過著完全平靜的人生 因為做不到而自認失敗者 我愛你，我不要恨你 你可以試著化解造成仇恨的負面情緒 但努力後還是無法不恨的話，也不要對此感到絕望 對自己無法不憎恨而責怪自己，只會讓一切更糟 一旦接受了憤怒不會消失，接下來就想想該如何管理這份憤怒 無法企及的願望 不被仇恨玷汙的心 切合實際可達成的目標 與仇恨共處，不會恨自己 你能做的事 盡一切阻止惡行，降低與這些行為接觸的機會 永遠不要因為可恨的人而感到氣餒 管理好恨意是值得尊敬的事 治療心痛 有些失落是無法復原的，即使有很多支持，工作很努力，也不斷向前走 很多時候，失落的心痛能否復原由不得自己 帶著一顆破碎的心生活也許很難 但這並不會阻止你活出更好的人生 該死的真愛無敵 找一個伴 眼光請超越吸引力，想清楚你需要怎樣的人格特質和個性 如果這些特質不存在，要有心理準備不要理會強大的吸引力 該死的溝通 如果無法與他人達成共識，請花時間弄清楚為什麼溝通無效 也許就是不能溝通呢？ 或者更重要的是根本不該溝通 重要的是知道溝通的能力其實有限 說出創傷 不要再逼受創傷的人講述自己的故事 人們對復原傷痛都有一套自己的方法，也許把話說開對你最好，卻可能成了別人的痛處 很多時候，創傷可能無法被解決，不論是透過分享或哄騙他人分享 但你可以學著傾聽自己的需要和在乎的事 儘管你現在必須經驗的焦慮或目睹痛苦 宣洩憤怒 如果你決定保持沈默好過抒發自我 這不是因為你是懦夫，而是你有比起讓內部火山噴發更具價值的目標 例如維繫家庭、替感情找到最好出路，以及保留談判的力量 該死的天下無不是的父母 停止親子衝突 如果你對孩子即將變成什麼樣的人感到悲傷 請客觀看待他的長處，不要混肴真正的他與你期望的他，兩者差距有如鴻溝 尤其你的期待可能帶著成見和錯誤 [Bouns] 該死的治療 尋求治療 透過治療，你想找到問題根源，找得到當然很好，但那只會出現在電影裡 現實人生中，大多數問題成因太多，很多甚至是無法改變的 即便有耀眼的洞察力或痛哭一場也改變不了 如果你還期望這樣的治療能解決問題，一定會覺得自己很失敗 人們以為心理治療有某種神奇的力量，可以剷除不開心的事 但現實是，這些不切實際的期望把你鎖在無法實現的目標 而它們只會讓你更痛苦而已 拒絕就醫者的治療 如果有什麼不好的事發生，不要把焦點放在該怪誰 尊重嚴重精神疾病很難忍受的事實，並看重你和他人都盡力幫助這件事 有人說自殺是懦弱的結束，是被愛者失敗的表現 但套句臨床術語來形容那些說這種話的人是「他馬的白痴！」 對病入膏肓且失去大多數原始個性的人 當你持續愛他並關心他，就沒有失敗這回事 當有人每天從床上爬起來與疾病奮戰，就沒有懦弱這件事 即使他們最後連這樣的事都做不了了 後記 - 好吧，該死的我 請記得天下沒有「公平」這回事 情緒不過是蠢事 而人生艱難 ... 如此你的日子大概就會過得比較ＯＫ 即使不快樂，因為你的目標很實際 而為了達成目標付出的努力也會讓你很驕傲","tags":"Book","url":"https://wei-lee.me/posts/book/2017/02/fuck-feelings","loc":"https://wei-lee.me/posts/book/2017/02/fuck-feelings"},{"title":"我如何更有效率的使用時間","text":"過年整理了好多以前的書摘 好像該來發一點自己的東西了 前一段時間被找回母系演講 被問了，我是怎麼管理時間的 當下沒有回答的很好 於是乎就有了這篇文章 XD 如何達到一個目標 我們常常會給自己定一個很大的目標 像是我要看完 \"Learning Python\" ( 一本 1400 頁的 Python 教學書） 嗯，聽起來好像也不太大 不過至少這不太容易在一天內完成 剛定下目標的時候，會很有衝勁的去做 過了一段時間就會發現，怎麼離完成目標還是好遠 再來我們就會去做一些比較容易達成的事，像是滑個 FB、整理一下 e-mail 然後這個目標就會擺在這，等到很久以後再想起它 恩，就像新年新希望一樣 怎麼樣才能達到目標呢？ 每天做一點點 我非常喜歡 Act Small 這支影片 他把目標比喻成走完一千階的階梯 光是看著這長長的階梯就會讓人感到挫折和疲憊 這時候我們會先去吃個早餐、遛個狗，做些輕鬆可以達到的事 想辦法拖延要爬上這個階梯這件苦差事 但是，如果我們試著不要只專注在很遙遠的目標 而是眼前的每一個小階梯 走一個小階梯，並不會讓人感到壓力 但是每天都走這簡單的一小步，最後就會達到甚至超過這一千階的階梯 訂下目標後，要把目標拆解成一個個很小很明確的行動 最好是可以小到不會讓人感受到壓力 再來就是每天不斷地完成這些小小的行動 這部影片是 Daily Checklist 的社群分享的 這個 App 可以幫我們追蹤今天是不是完成了要達成的行動，到了凌晨 12 點就會重設 Checklist 接下來會提到這個 App，如何幫我達成目標 如何養成習慣 那麼把目標拆解成很小的行動後 要怎麼堅持每天都要走這一小步，而不會半途而廢呢？ 這裡非常推薦大家看「 為什麼我們這樣生活，那樣工作? 」（連結是我的書摘） 裡面提到要養成一個習慣的條件有以下四個 提示 慣性行為 （習慣） 獎籌 創造渴望 以我最前面說我要看完 \"Learning Python\" 為例 我會定只要某個時間一到，我就得要看這本書 只要我花了一個小時看它，我就會在 Daily Checklist，按下 check，表示我看完今天的進度了 如果我突然怠惰不想看，就會中斷我連續達成這個行動的累績次數 也會讓我今天的習慣達成率沒辦法達到 100% 這都會驅使我今天就算只做一點點，也要努力再前進一小步 把這些敘述換成剛剛所提到的四個條件 提示 → 時間到了 慣性行為 （習慣） → 看 Learning Python 獎酬 → 在 Checklist 上打個勾 創造渴望 → 我要讓 Checklist 上的達成率達到 100% 而且隨著達到的目標越來越多 就會感到更有成就感 越來越相信自己可以做到這些事情 透過追蹤自己習慣和時間使用 可以讓自己知道接下來要從哪裡修正起 如果自己漸漸有進步，就會有成就感繼續堅持下去 除了 Daily Checklist，另外也推薦追蹤工作時間用的 Toggl 一天不做，不會怎樣啦 花了好久時間建立的習慣，還是會有想怠惰的時候 我很喜歡「 你如何衡量你的人生 」的一句話 百分之百的堅持比百分之九十八容易 一旦你放下了這個堅持，之後就會更容易放下 反之，如果一直堅持，就會有力量讓自己一直堅持下去 時間有限，做出選擇 再來可能會再遇到下一個問題 想完成的事情太多，能分配的時間太少 這就是必須做出選擇的時候了 那麼要怎麼決定那些事情是真的很重要，要留下來的呢？ 這裡我要推薦的書是「 少，但是更好 」 不過如果要給一個最簡單的原則，那就是 No more yes. It's Either HELL YEAH! Or No 如果這件事不是「太棒了！我一定要去做！！！」，那麼就不要做了 另外一個更明確的做法是 Rule of Three 在一天結束前，為明天定下三件重要而且一定要完成的事 只要三件， 可以少，但不可以多 ，就算只有一件也很好 只要這三件事情還沒有達成就不能做其他的事 這樣做的好處是可以明確的知道接下來要做什麼，大腦的負擔會比較小 也不會讓自己因為有太多未完成的代辦事項而分心 意志力有限 人的意志力是非常有限的 所以留給一點彈性給自己吧 不要把整天都排滿工作，適時的排給自己一點休閒 人畢竟不是機器，沒辦法不停的工作 尤其到了越晚，意志力會越來越薄弱 所以我會盡量把重要的習慣，擺在早上做完 如果真的累了，就休息吧 不論是體力上的疲憊，或只是意志力的消磨殆盡 死撐著也只是無意義的消磨時間，而且還有可能導致工作出錯 不過休息就真的休息，聽點音樂或什麼的都好 去滑臉書、收信件、看新聞，這些往往會讓意志力恢復得更慢 後記 其實我一直想花時間，紀錄一下服役時間各種嘗試讓自己更有效率的方法 今天終於下定決心好好的寫這篇文章 大三、大四的那兩年，好像常常把自己搞得很忙 雖然不算沒有做到事 但總覺得自己好像有點是在瞎忙 明明花這些時間應該可以做更多的事 服役期間，剛好坐我隔壁的學長很喜歡看書 就漸漸地養成一週至少會看一本書的習慣 上面提到的這些書也都是這段時期看的 後來就漸漸把這些應用在其他我想學想做的事情上 第一次好好上完一個為期三個月的線上課程，其實蠻有成就感的 再來遇到的問題就是，在這之後我排了太多的線上課程和想看的書 有時候白天工作量比較多，回到宿舍還要持續好幾個小時的 work 實在太讓人吃不消 所以我重新檢視了我的計劃和每天要達成的習慣 哪些是真的重要的 這些事又要怎麼拆解才能不會讓我太費力，或只要多花一點力，不會很容易半途而廢的 這些只是我嘗試覺得有用的方法 不見得適用於每個人 不過也許都能去嘗試看看，相信總會有一些有幫助的部分","tags":"Gossiping","url":"https://wei-lee.me/posts/gossiping/2017/02/how-do-i-manage-my-time","loc":"https://wei-lee.me/posts/gossiping/2017/02/how-do-i-manage-my-time"},{"title":"More than Just Echo Bot","text":"知道怎麼實作一個會 Echo 的 Bot 後 再來就要思考，開發一個 Bot 我們要提供什麼功能 (e.g., 天氣查詢, 訂票, 推薦旅遊景點) 不過這裡要討論的不是 Bot 的功能 Bot 的功能實作，跟一般網站或 App 的實作並沒有太大的差別 接下來來談如何從使用者說的話來判斷，使用者要使用的功能 如果使用者問：「今天天氣如何？」「天氣今天好嗎？」 要如何知道，他都是要詢問今天的天氣狀況 也就是使用者的「意圖」 Based on Keyword 上一篇文章，輸入關鍵字就能回傳 template message 的 bot 也是用這樣的方式實作的 if 'button' in text : # Send ButtonTemplate ...... elif 'confirm' in text : # Send ConfirmTemplate ...... elif 'carousel' in text : # Send CarouselTemplate ...... else : # Echo TextMessage ...... 回歸到天氣的問題 可以試著找出「天氣」是否有出現在使用者的問句中 再來判斷「今天」, 「明天」這樣敘述時間的詞 e.g. if '天氣' in text : if '今天' in text : return today_s_weather elif '明天' in text : return tomorrow_s_weather Pros 不需要其他的背景知識，容易實作 運算量小 Cons 建立規則很麻煩 規則很容易就會出現例外，很難定義得完整 只要使用者無法觸發到關鍵字，就無法使用功能 一堆 if else 造成程式冗長，不易擴充和維護 AIML Artificial Intelligence Modelling Language 它是一款基於 XML 的 markup language 這是最基本的 AIML <aiml version= \"1.0.1\" encoding= \"UTF-8\" ? > <category> <pattern> HELLO ALICE </pattern> <template> Hello User! </template> </category> </aiml> 只要符合特定的 pattern，就回傳指定的 template 也能透過 <random> 這樣的 tag，從多種回覆隨機丟一種回傳 <random> <li> response1 </li> <li> response2 </li> ... </random> Pros 比起只用 if else 更結構化，較易維護和擴充 Cons 依然很難包含所有的狀況 Other NLP Service Wit.ai (Facebook) COSCUP 2016 的聊天機器人小啄，就是透過 Wit.ai 實作的 LUIS (Microsoft) API.ai (Google) 這些服務能透過標記和訓練 解析出這句話的每一個片段，所具有的意義 e.g. 「今天西雅圖天氣如何」 時間：今天 地點：西雅圖 意圖：天氣如何 Wit.ai Wit.ai 跟 LUIS, API.ai 比較不同的地方是 從 Wit.ai 得到的是，我們設定的回覆 而不是一句話解析後的結果 LUIS 從 這裡 可以測試兩個訓練過的範例機器人，看看從 LUIS 可以得到什麼 e.g. Question how is the weather in the Taipei Response { \"query\" : \"how is the weather in the Taipei\" , \"topScoringIntent\" : { \"intent\" : \"GetCurrentWeather\" , \"score\" : 0.50119406 , \"actions\" : [ { \"triggered\" : false , \"name\" : \"GetCurrentWeather\" , \"parameters\" : [ { \"name\" : \"location\" , \"required\" : true , \"value\" : null } ] } ] }, \"entities\" : [], \"dialog\" : { \"contextId\" : \"80cd646a-d85d-4b40-873d-1b47fa49adc8\" , \"status\" : \"Question\" , \"prompt\" : \"Where would you like to get the current weather for?\" , \"parameterName\" : \"location\" } } API.ai Question Hey Calendar, schedule lunch with Mary Johnson at 12 pm tomorrow. Response { \"action\" : \"meeting.create\" , \"name\" : \"Lunch with Mary Johnson\" , \"invitees\" :[ \"Mary Johnson\" ], \"time\" : \"2014-08-06T12:00:00-07:00\" } Implement Through Powerful Libraries 不過這些服務，通常會有它的限制 這時候就能用上 Python 強大的函式庫們，來實作自己的版本 NLTK Python 經典的 NLP 函式庫 word2vec 透過詞向量，找出相似詞 jieba 中文斷詞 判斷句子中的關鍵詞 我在 NLP Libs Sample 寫了這些函式庫的基本使用範例 另外，也可以看 自己动手做聊天机器人教程 它是一系列聊天機器人教學，談這些做法背後的理論和實作 Beyond NLP 不過就算做了這些分詞、判斷意圖 也不能保證使用者就會買單 有人稱 Chat Bot 為下一代的 UX Design The Next Phase Of UX: Designing Chatbot Personalities Issue 如何讓使用者，在機器人的 Scope 內不會碰壁 如何讓機器人的判斷足夠 robust，不會每次回答都是不明白 如何讓使用者在最少的操作下，得到想得到的服務 更進一步是 如何設計一個有個性、有溫度的機器人 這裡就可以再去研究 NLP 的情感分析 Read More WHEN BOTS GO BAD: COMMON UX MISTAKES IN CHATBOT DESIGN Does Conversation Hurt Or Help The Chatbot UX? Reference Head First ChatBot AIML Tutorial AI Chat Bot in Python with AIML Wit.ai Quickstart 自己动手做聊天机器人教程 An overview of the bot landscape","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/11/more-than-just-echo-bot","loc":"https://wei-lee.me/posts/tech/2016/11/more-than-just-echo-bot"},{"title":"More About Line Messaging API - Template Messages","text":"除了傳送文字外，Line Bot 還可以傳 圖片, 影像, 聲音, 地圖 貼圖 (Line Bot 所能使用的 貼圖清單 ) Imagemap Template Button Confirm Carousel 大部分使用上很直覺，可以直接參考 API Reference - Messaging API 和 line-bot-sdk-python 這篇文章主要談 Template Messages 的使用 Template Template 分為 Button, Confirm 跟 Carousel 三種 這些功能也是我認為從 Line Bot Trail 升級到 Line Messaging API 最好用的功能 Example 以下的測試是 bot 收到關鍵字，回傳相對應的訊息 Button Confirm Carousel (如果超出版面，則可以左右滑動) 另外必須要注意的是，這些功能目前都只支援手機版 在電腦版上的 Line 看到的訊息會是這樣 這個文字內容可以透過 template 的 alt_text 參數設定 上面的例子是 line-bot-sdk-python 的使用範例 ( 可以回傳 template message 的 echo bot ) 大部分都能透過 Code 和 Example 比對，找到需要調整的參數 接下來談的是那些按鍵的設定 上面所看到的按鍵都是一個 Action 三種 Template 最大的不同，主要是這些 action 擺設的方式不同 限制的數量也不同 Button 一次可以支援四個 action Confirm 支援三個 action Carousel 則可以用 5 個 CarouselColumn，每一個 Column 支援 3 個 Action 另外需要注意的是 Carousel 中每一個 Column 的 action 數量必須是一樣的 Action 這些 action 的 label 參數，就是顯示在按鍵上的文字，必須在 20 字以內 text 參數則是按下這個按鍵，會由使用者回傳設定的文字 e.g. 這是我按下上面 Button 的 postback 的效果 而 text 就是設定為 postback ( 注意並非 label 的 'postback') Postback 當使用者按了這個按鍵 Line Server 會傳一個 postback event 給我們，裡面包含著 data 參數中設定的字串 在收到 event 的時候，透過 event.postback.postback.data 取出 data Postback 可以不給 text 參數 Message text 參數在 Message Action 是必須的，也不能給空字串 如果希望這個按鍵，只有顯示但不會由使用者傳文字過來，可以給一串空白 (e.g. ' ') URI 使用者按下這個按鍵就會用 Line 的瀏覽器跳到外部網頁 Reference API Reference - Messaging API line-bot-sdk-python","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/11/more-about-line-messaging-api-template-messages","loc":"https://wei-lee.me/posts/tech/2016/11/more-about-line-messaging-api-template-messages"},{"title":"Deploy LineBot on Heroku","text":"上一篇提到如何用 ngrok 讓我們可以不用架 Https Server，直接在本地端測試 Bot 再來要談的是如何把 Bot 部署到 Heroku 上 Why not ngrok 使用 ngrok 必須要讓你的本地端一直開著才能收到訊息 而且免費版的 ngrok 每次都會更改 url 所以我們需要一個可以讓其他人較長時間測試的 Server 以我自己的開發習慣 我會使用 ngrok，來做 Bot 的基本除錯 Heroku 則是用來讓其他人測試功能 真的要上線的時候才會自己架一個 Https Server Line 的帳號也是 ngrok, heroku 跟上線需要的各申請一個 不過 ngrok 可以好幾個 Line Bot 專案共用一個即可 Heroku Create App 先上 Heroku 辦個帳號 到個人的 dashboard New → Create New App 選一個名字，就創好 App 了 Deploy Add Remote 在部署之前要先安裝 Heroku CLI 再來我們要到原本 line-echobot，將 heroku 加入這個專案的 remote heroku login heroku git:remote -a leewbot 接著用 git remote -v 就能看到 heroku 已經被加入 remote 了 以後只要 git push heroku master ，就能部署到 Heroku 不過我們還必須要多做一些設定才能讓 Bot 順利的部署 Environment Variables 首先是我們原先設定的環境變數 Heroku 是透過這個指令來做設定 heroku config:set \"env key\" : \"env value\" 或者也能到 dashboard 的 Settings → Config Variables → Reveal Config Vars 做設定 Python Environments 因為 Heroku 支援多種不同的語言 所以要讓 Heroku 知道我們使用的是 Python Heroku 可過專案中是否有 requirements.txt 來判斷這個專案是否為 Python 專案 並且安裝 requirements.txt 內的函式庫 名稱如果打錯，可能會讓 Heroku 不知道這是 Python 專案，導致部署失敗 另外可以透過 runtime.txt 來指定 Python 的版本 目前支援這兩種版本 * python-2.7.12 * python-3.5.2 Deploy Settings - Procfile 再來必須要讓 Heroku 知道我們執行專案的指令是什麼 這個指令就是寫在 Profile 中 這裡使用的部署套件是 gunicorn 先在 requirements.txt 加入 gunicorn==19.0.0 再來創一個 Profile ，內容是 web: gunicorn line_echobot.wsgi --log-file - 如果用其他的部署套件，則需要修改 web 後面的指令 到了這裡就做好所有的設定了 最後只要 git push heroku master 就會部署到 Heroku 上 透過 heroku open 能看到剛剛部署上去的專案 接著把專案的網址加上我們先前設定的 callback url echobot/callback 設定到 Line Bot 的 Webhook URL，就完成了 Reference Getting Started on Heroku with Python Deploying Python and Django Apps on Heroku","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/11/deploy-linebot-on-heroku","loc":"https://wei-lee.me/posts/tech/2016/11/deploy-linebot-on-heroku"},{"title":"Line Echo Bot on Django","text":"單純要寫一個只會 Echo 的 Line Chat Bot 用 flask 只要 85 行的 code 就能解決 官方已經有提供相當清楚的範例 flask-echo 了 這篇文章則是提供了 django 的做法 想直接看 code 也可以參考 line_echobot Line Messaging API (line-bot-sdk-python) 詳細的 Line Bot 提供哪些功能，該如何使用 可以在 API Reference - Messaging API 找到 之後的文章，會談如何使用文字以外的功能 這裡直接使用官方提供的 line-bot-sdk-python pip3 install line-bot-sdk 另外官方也提供 java , go , php , ruby , perl 的版本 Start Project Create Project # Create a line_echobot project django-admin startproject line_echobot # Create an echobot app python3 manage.py startapp echobot Setup Line Secrets 接著設定 Line Bot 的 Channel Secret , Channel Access Token ( 可以在 Line Bot 的 Line Deverloper 頁面取得 ) 不過這些值不該被 git 記錄，所以不該被寫死在 settings.py 中 建議將這些值寫入環境變數 export SECRET_KEY = 'Your django secret key' export LINE_CHANNEL_ACCESS_TOKEN = 'Your line channel access token' export LINE_CHANNEL_SECRET = 'Your line channel secret' 執行時，讓設定檔先去讀取這些環境變數 下面的 get_env_variable 函式是用來取得環境變數 只要有少設定，就會丟出 ImproperlyConfigured 的例外事件中斷執行 # line_echobot/settings.py ...... def get_env_variable ( var_name ): try : return os . environ [ var_name ] except KeyError : error_msg = 'Set the {} environment variable' . format ( var_name ) raise ImproperlyConfigured ( error_msg ) SECRET_KEY = get_env_variable ( 'SECRET_KEY' ) LINE_CHANNEL_ACCESS_TOKEN = get_env_variable ( 'LINE_CHANNEL_ACCESS_TOKEN' ) LINE_CHANNEL_SECRET = get_env_variable ( 'LINE_CHANNEL_SECRET' ) ...... INSTALLED_APPS = [ ...... , 'echobot' ] 不過如果只是單純測試用，這些值也可以直接寫死在 settings.py 中 另外也不要忘了在 INSTLLED_APPS 加入 echobot 一般來說，django 產生 project 時 settings.py 裡面就會有 secret key 這裡的做法是把預設的 secret key 刪掉 設定到環境變數中，避免被 git 記錄下來 如果還需要另外還要重新產生可以透過 django-secret-keygen.py Setup Line Webhook URL 再來要設定一個 Webhook URL 讓 Line 可以把 Bot 收到的訊息傳給我們 先在 project 的 urls.py 設定 讓 project 可以找到 echobot 這個 app 的 urls.py # line_echobot/urls.py ...... import echobot urlpatterns = [ ...... , url ( r '&#94;echobot/' , include ( 'echobot.urls' )), ] ...... 接著在 echobot 內，創一個 urls.py 並將 url 再導到 callback ，呼叫 views.py 裡面的 callback 函式 ( 接下來才會實作 ) # echobot/urls.py from django.conf.urls import url from . import views urlpatterns = [ url ( '&#94;callback/' , views . callback ), ] 這些都設定完後，要在 Line 那邊設定的 Webhook Url 就是 https://\"your domain name\"/echobot/callback/ ( your domain name 要設定什麼，會在這篇文章的 最後 說明) Implement Callback Function 接下來就是要在 echobot/views.py 實作 callback 了 Initial 先 import 相關的函式庫 from django.conf import settings from django.http import HttpResponse , HttpResponseBadRequest , HttpResponseForbidden from django.views.decorators.csrf import csrf_exempt from linebot import LineBotApi , WebhookParser , WebhookHandler from linebot.exceptions import InvalidSignatureError , LineBotApiError from linebot.models import MessageEvent , TextMessage , TextSendMessage 透過 line_bot_api 傳訊息給 Line，讓 Line 轉傳給使用者 line_bot_api = LineBotApi ( settings . LINE_CHANNEL_ACCESS_TOKEN ) Callback Function 有兩種方法可以處理 Line Server 送過來的訊息 這裡先用 Todo 記著，待會再來補上 # TODO: Define Receiver @csrf_exempt def callback ( request ): if request . method == 'POST' : signature = request . META [ 'HTTP_X_LINE_SIGNATURE' ] body = request . body . decode ( 'utf-8' ) # TODO: Handler when receiver Line Message return HttpResponse () else : return HttpResponseBadRequest () Validate Signature 處理訊息之前 先確認這個 request 是不是真的是從 Line Server 傳來的 要確認這件事，需要 request 的 body request header 中的 X-Line-Signature 也就是上面的 signature = request . META [ 'HTTP_X_LINE_SIGNATURE' ] body = request . body . decode ( 'utf-8' ) Handle Received Message 取得 body 跟 signature 後 Line Bot API 會在處理訊息的同時，確認這個訊息是否來自 Line 而處理 Line 傳過來給我們的訊息，有兩種不同的做法 WebhookParser WebhookParser 會 Parse 這個訊息的所有欄位 讓我們針對各種不同型別的訊息做個別的處理 e.g. UserID Event Type Message Content and etc. 在 這裡 可以找到有哪些欄位 這段 code 要取代上面的 # TODO: Define Receiver parser = WebhookParser ( settings . LINE_CHANNEL_SECRET ) 下面三段 code 則要取代 # TODO: Handler when receiver Line Message parser 會 parse 所有的 event 跟各個 event 中的所有欄位 如果 request 不是從 Line Server 來的，就會丟出 InvalidSignatureError 其他使用錯誤，或 Line Server 的問題都會是丟出 LineBotApiError try : events = parser . parse ( body , signature ) except InvalidSignatureError : return HttpResponseForbidden () except LineBotApiError : return HttpResponseBadRequest () 再來要判斷收到的事件是什麼事件 這個 Bot 只需要 echo 純文字訊息 所以先判斷這個事件是不是訊息事件，而這個訊息是不是文字訊息 for event in events : if isinstance ( event , MessageEvent ): if isinstance ( event . message , TextMessage ): line_bot_api . reply_message ( event . reply_token , TextSendMessage ( text = event . message . text ) ) 最後的 reply_message 函式，讓我們傳訊息給 Line Server 第一個參數是要回傳要用的 reply_token，可以從事件中取得 （ event.reply_token ） 使用這個 reply_token 做回覆，是不用收費的 不過同一個 reply_token 只能使用一次，而且在一定的時間內就會失效 第二個參數是這次要回傳的訊息 這裡 有所有能回傳的訊息 也可以傳一個都是訊息的 list 或 tuple 不過一次最多只能傳 5 個 只要超過就會有 LineBotApiError WebhookHandler WebhookHandler 是針對每一種不同的訊息型態註冊一個處理器 只要收到這樣的訊息，就會丟給對應的處理器 如果確定每一類訊息，在任何情況下都會有相似的處理方式，就很適合這樣的設計 接下來的三段 code 要取代 # TODO: Define Receiver handler = WebhookHandler ( settings . LINE_CHANNEL_SECRET ) 先為 handler 加入，TextMessage 的處理器 參數是接收到的 event 這裡做的也是讀取到原本 event 中的文字，並回傳回去 @handler . add ( MessageEvent , message = TextMessage ) def handle_text_message ( event ): line_bot_api . reply_message ( event . reply_token , TextSendMessage ( text = event . message . text ) ) 因為沒有要處理其他訊息 如果收到其他訊息 (e.g. 貼圖 , 照片 ) 或訊息以外的事件 使用 default 來回傳 \"Currently Not Support None Text Message\" 的文字訊息 @handler . default () def default ( event ): print ( event ) line_bot_api . reply_message ( event . reply_token , TextSendMessage ( text = 'Currently Not Support None Text Message' ) ) 下面的這段 code 是要取代 # TODO: Handler when receiver Line Message handler 判斷完這個訊息，應該被哪個處理器處理，就會傳給那個函式處理 try : handler . handle ( body , signature ) except InvalidSignatureError : return HttpResponseForbidden () except LineBotApiError : return HttpResponseBadRequest () Full Code 由於上面的 code 說明比較分散 這裡附上兩個版本各自的完整版 WebhookParser # line_echobot/echobot/views.py # WebhookParser version from django.conf import settings from django.http import HttpResponse , HttpResponseBadRequest , HttpResponseForbidden from django.views.decorators.csrf import csrf_exempt from linebot import LineBotApi , WebhookParser from linebot.exceptions import InvalidSignatureError , LineBotApiError from linebot.models import MessageEvent , TextMessage , TextSendMessage line_bot_api = LineBotApi ( settings . LINE_CHANNEL_ACCESS_TOKEN ) parser = WebhookParser ( settings . LINE_CHANNEL_SECRET ) @csrf_exempt def callback ( request ): if request . method == 'POST' : signature = request . META [ 'HTTP_X_LINE_SIGNATURE' ] body = request . body . decode ( 'utf-8' ) try : events = parser . parse ( body , signature ) except InvalidSignatureError : return HttpResponseForbidden () except LineBotApiError : return HttpResponseBadRequest () for event in events : if isinstance ( event , MessageEvent ): if isinstance ( event . message , TextMessage ): line_bot_api . reply_message ( event . reply_token , TextSendMessage ( text = event . message . text ) ) return HttpResponse () else : return HttpResponseBadRequest () WebhookHandler # line_echobot/echobot/views.py # WebhookHandler version from django.conf import settings from django.http import HttpResponse , HttpResponseBadRequest , HttpResponseForbidden from django.views.decorators.csrf import csrf_exempt from linebot import LineBotApi , WebhookHandler from linebot.exceptions import InvalidSignatureError , LineBotApiError from linebot.models import MessageEvent , TextSendMessage , TextMessage line_bot_api = LineBotApi ( settings . LINE_CHANNEL_ACCESS_TOKEN ) handler = WebhookHandler ( settings . LINE_CHANNEL_SECRET ) @handler . add ( MessageEvent , message = TextMessage ) def handle_text_message ( event ): line_bot_api . reply_message ( event . reply_token , TextSendMessage ( text = event . message . text ) ) @handler . default () def default ( event ): print ( event ) line_bot_api . reply_message ( event . reply_token , TextSendMessage ( text = 'Currently Not Support None Text Message' ) ) @csrf_exempt def callback ( request ): if request . method == 'POST' : signature = request . META [ 'HTTP_X_LINE_SIGNATURE' ] body = request . body . decode ( 'utf-8' ) try : handler . handle ( body , signature ) except InvalidSignatureError : return HttpResponseForbidden () except LineBotApiError : return HttpResponseBadRequest () return HttpResponse () else : return HttpResponseBadRequest () 到了這裡，echo bot 實作的部分就完成了 Https Server (Setup 'your domain name') 使用這些 Bot 的服務時，大多會要求我們一定要先有一個 Https Server 除了自己架 Http Server 外，還透過其他服務，更方便我們做測試 接下來我會分享兩種做法 架在 Heroku ( 由於篇幅的關係，Heroku 會在接下來的文章談 ) 使用 ngrok ngrok ngrok 提供的服務是 讓外部的訊息先經過 ngrok 的 server，ngrok 再將這個訊息傳給你的 server 回傳時也是從你的 server 傳給 ngrok 的 server，再把訊息傳出去 所以外部都只會看到 ngrok 的 server # Install ngrok on mac brew cask install ngrok 先把 django 的 server run 起來 python3 manage.py runserver 預設 django 的 port 是 8000 這裡並不需要使用 0.0.0.0:8000，讓外部可以連到這個 django server ngrok 會把 request 傳到 local 端相對應的 port 接著就要用 ngrok 將 request 導到本地端的 port 8000 ngrok http 8000 再來到 Line Bot 的 Line Developer 頁面設定 Webhook URL 這時候填上 ngrok 後的 https 那串 url，再加上 echobot/callback/ ( 我們設定的 callback url) (e.g. https://2.....f.ngrok.io/echobot/callback/ ) 值得注意的是我的 Webhook URL 下面有一個 Read timeout. 如果按了後面的 Verify，Line Server 會傳一些測試訊息過來 但是那個 reply_token 是無法被回覆的 這時候在 Server 就會丟出 LineBotApiError 不過沒關係，這只是給我們檢查用的 並沒有一定要通過才能使用 Line Bot 這時候加 Bot 為好友，就可以開始跟它聊天了 如果你發現除了 echo 訊息外，還有其他的訊息 可能就是沒有把 Atuo Reply Message 關掉 這時候就可以去 Line Bot 的 LINE@ Manger Settings → Bot Settings 把它關掉 或者到 Messages → Auto Reply Message 做修改訊息內容 Reference 新版 Line@ Messaging API 使用心得 (Line Bot v2) LineBot - Sinatra ngrok","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/11/line-echo-bot-on-django","loc":"https://wei-lee.me/posts/tech/2016/11/line-echo-bot-on-django"},{"title":"Apply Line Messaging API","text":"先到 Messaging API 申請帳號 開始使用 Messaging API 和 開始使用 Developer Trial 申請到的帳號是不同的 之後不能互換，所以一開始就要根據需求來決定申請哪種帳號 開始使用 Messaging API 會申請免費版的帳號 之後可以選擇付費升級為入門版等更多功能的版本 主要拿來做正式發佈用的帳號 開始使用 Developer Trial 則是 Developer 的帳號 雖然一開始就能使用 Push API，但好友人數只有 50 人 如果還在開發階段，就適合辦這個帳號來測試 不過需要注意的是 developer 帳號，並不能接升級成一般帳號 再來會詢問業務類別，跟要求設定 Bot 名稱和照片 回到 Line Business Center 的帳號清單 就能看到帳號已經創好了 進入剛剛創好的帳號的 LINE@ Manager 頁面左上方，Bot 名稱下方 @ 開頭的就是這個 Bot 的 id 可以從 Line 輸入這個 id 加 Bot 為好友 （需加上 @） 接著到設定頁面左下方，找到 Settings → Bot Settings 進入以下的畫面開啟 Messaging API 開啟 Bot API 後，就會不能用以下三個功能 1-on-1 Chat LINE@ app Store Chat 之後會進到以下畫面 記得要把 Use webhooks 調成 Allow 才能把這個 Line Bot 串到自己的 server 上 往下拉可以看到更多的選項 如果不想要 Line 每次收到訊息都自動幫你回覆 就要把 Auto Reply Message 調成 Don't Allow Greeting Message 則是，剛加 Bot 為好友時的歡迎詞 如果有需要對這些訊息做設定 都可以在左手邊選單的 Messages 找到 再回到帳號清單就會看到，帳號已經開通 Messaging API 了 進到 LINE Developers 就能取得你的 Channel Secret 和 Channel Access Token 了 （這些都是運用 Line Messaging API 會用到的） 除了前面提到可以用 ID 加好友，也能透過這裡的 QR code 另外要注意的是 Webhook URL 這裡之後要填的就是你的 Server 的 Webhook url Reference Enable the Messaging API for your LINE@ account","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/11/apply-line-messaging-api","loc":"https://wei-lee.me/posts/tech/2016/11/apply-line-messaging-api"},{"title":"Introduction to Chatbot","text":"有人說聊天機器人 Chat Bot 將要取代 APP Why chatbots are replacing apps This is how Chatbots will Kill 99% of Apps 各大軟體公司也爭相提供 Bot 的服務 Facebook Messenger Platform Line Messaging API Slack API Telegram Bot Platform What can Bot Do? 那 Chat Bot 究竟能幹嘛呢 ? 先來看段影片吧 【公式】BOT & THE NEW WORLD by LINE 影片中出現了什麼？ 預約餐廳 訂車 偵測 Beacon 提供 coupon 遠端控制家中的 IoT 設備澆水 原本在 App 上處理的這些服務 未來都有可能逐漸被 Chat Bot 所取代 背後發生了什麼事 e.g. 預約餐廳 User 傳一個訊息給 Bot 的帳號 Bot 把訊息傳給服務提供者的 Server 服務提供者的 Server 把訊息，傳給指定的 Server 指定的 Server 做了適當的運算和判斷，把結果回傳給服務提供者 Server 服務提供者 Server 收到後，再傳給 User 的帳號 e.g. Line Chat Bot 架構 Why Chat Bot? 市面上 App 太多了，要開發使用者黏著度高的 App 很困難 每一個 App 都有自己的介面，對使用者都是一次學習成本 不如把服務嵌入現在使用者常用的 App (e.g. Facebook Messenger, Line) 文字是人類相對直覺的溝通方式 Why not Chat Bot? 設計彈性不如 App 雖然 Chat Bot 大多提供按鍵等功能，但使用上的彈性不像 App 那麼大 文字處理依然不夠好 簡單的 Bot，如果使用者一直無法對應到相對的關鍵字，就無法觸發功能 How to Design a Bot? 那麼開發一個 Bot 需要什麼呢？ 選擇使用的 Bot 平台 (e.g., Facebook Messenger Platform, Line Messaging API and etc.) 寫一些服務 (e.g., 訂票、新聞推播) 把服務架在一台 https server 用 Bot 平台提供的 sdk，把 Server 跟平台串起來 用 NLP 判斷使用者的意思，串接到服務上 Chatbot Platform - Line Messaging API 既然看了 Line Bot 的新功能 接下來的幾篇文章會談要如何在 Line 平台上 做一個最簡單只會 Echo 的 Chat Bot Reference 這篇文章整理了相當多的相關資源 The Rise of Chat Bots: Useful Links, Articles, Libraries and Platforms 相當推薦對 ChatBot 有興趣的人參考 Slide 如果有點不喜歡看文章的，也可以看看 slide 的版本","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/11/introduction-to-chatbot","loc":"https://wei-lee.me/posts/tech/2016/11/introduction-to-chatbot"},{"title":"TEDx Tainan 2016 - 0 到 1","text":"趁著昨天才剛結束 把一些感受記錄下來 第一次來現場聽 TED 感受真的跟看影片很不同 劉致昕 這場的主題是敘利亞戰事 談 ISIS 和敘利亞難民到歐洲避難過的生活 而這些都是在台灣不會接受到的訊息 雖然平常有在看 CNN，多少有接觸到這樣的訊息 但不同的情境不同的講者，同樣的故事還是有很不同的溫度 最後講者阿富汗朋友的一句話，讓我印象很深刻 雖然現在是黑夜 但在黑夜中期待光 很美 貓不 當一個溫柔的人，也要當一個有原則的人 赫然發現 google 一下找得到講者在其他地方講的 大概就是 原文 的第 5, 6 點吧 XD 張獻忠 這場主要談的是街友議題 講者分享遇到的各個街友的故事 顛覆一些人認為街友總是好吃懶做的印象 最後結尾時的這句話，才讓我去反思，這場說了這麼多街友的故事，背後想帶出的意義 如果今天換作是我們遇到同樣的處境 我們真的能處理得更好嗎？","tags":"Gossiping","url":"https://wei-lee.me/posts/gossiping/2016/11/tedx-tainan-2016","loc":"https://wei-lee.me/posts/gossiping/2016/11/tedx-tainan-2016"},{"title":"[Paper] Mining Online Social Data for Detecting Social Network Mental Disorders","text":"Paper My Slide This paper proposes a model named SNMDD to detect Social Network Mental Disorder (SNMD) through users' behaviors on online social networks (OSN) instead of asking their mental condition. In addition, multi-source learning (FB and IG) is used to improve performance through STM. SNMDD is a classification model based on TSVM The use of domain knowledge from psychology to extract features is the core of this model. The most interesting part is choosing features as the proxy features to replace ones that are hard to detect. For example, distinguishing whether a social capital is a strong tie or a weak tie is crucial to the detection of SNMD. However, it's hard to detect through OSNs data. Thus, it guesses that friends you interacts (e.g. posts, likes, comments) with might be the strong tie ones. STM is a tensor model based on Tucker Decomposition Through Tucker Decomposition, it's possible to combine data from different sources and extract new features vectors.","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/11/mining-online-social-data-for-detecting-social-network-mental-disorders","loc":"https://wei-lee.me/posts/tech/2016/11/mining-online-social-data-for-detecting-social-network-mental-disorders"},{"title":"[Book] 所有問題都是一場賽局","text":"序章 : 用賽局來思考，培養解決問題的「三種能力」 賽局理論 : 分析兩人以上的玩家，其決策和行動的理論 學賽局理論的目的 掌握賽局的整體樣貌 （對問題的分析能力） 預測即將發生的未來 找到適當的解決方法 贏不了的賽局，就改變規則吧 e.g. 減少排放二氧化碳有損國家經濟，所有國家都不願意，然而破壞環境卻對大家都是不好的 → 獎勵二氧化碳排放少的國家，讓二氧化碳變成對經濟有利 Ch1: 合理的下一步是 ......? 「囚犯賽局」與「合理的豬」 囚犯賽局 相信接觸過賽局理論的人，一定會聽過囚犯賽局 假設今天有兩個囚犯 A 和 B，他們被分開訊問，並且知道 如果都不認罪的話，兩個人都會被關一年 都認罪的話，兩個人都會被關兩年 但是要是一方認罪，另一方不認罪的話，則認罪方無罪釋放，不認罪方要關三年 將上述狀況畫成表格就會像下面這樣 ( 每一格左邊的數字代表左邊參與者的獲益，右邊的數字代表上面參與者的獲益 ) B 認罪 B 沈默 A 認罪 -2, -2 0, -3 A 沈默 0, -3 -1, -1 在考量了對方所會做的最佳選擇後，所做的最佳選擇就會導向 A 和 B 都認罪 然而對他們來說共同的最大利益，卻是都保持沈默 最後導向的這個點就是所謂的奈許均衡 (Nash Equilibrium) Ch2: 協調賽局 - 為何你拿蘋果、用微軟 參加賽局的玩家，透過協調讓雙方得到利益 協調賽局 以朋友出去玩作為案例 假設 A, B 有音樂劇和電影兩個方案 兩人一起去看音樂劇，滿足度是 10 一起去看電影是 9 分開去的兩種結果，雙方滿意度都是 0 B 音樂劇 B 電影 A 音樂劇 10, 10 0, 0 A 電影 0, 0 9, 9 此時的奈許均衡有兩個，就是雙方選擇同樣行動的兩個點 這時候只要有一方先做了選擇，則另一方就會趨向於 一樣的選擇 協調賽局的根本就是「和大家一樣」 協調的失敗 協調賽局中，有多個奈許均衡點 但最後仍有可能落在對大家都不利的均衡點上 (e.g. 以上面的例子來說就是看電影 ) 而且協調賽局具有「穩定了就很難改變」的性質 所以陷入這個不好的平衡點是相當危險的 實際案例 病態的過度加班 （有人加班，其他人不敢走） Ch3: 知彼知己，百戰不殆 - 三種賽局，搞懂你的對手 膽小鬼賽局 假設兩人各開一台車，朝向牆壁全速前進 看誰能不採煞車前，到離牆最近的地方 → 先踩剎車的人就輸了 B 踩剎車 B 不踩煞車 A 踩煞車 0, 0 -5, 5 A 不踩剎車 5, -5 -20, -20 奈許均衡有兩個 對方先踩剎車，則自己不踩 對方不踩剎車，則自己先踩 實際案例 古巴危機 美國要蘇聯撤除軍備，蘇聯要美國認同蘇聯裝設核子飛彈 如果都不讓步，就會爆發核子戰爭 不存在都讓步的情況 誰都不願意做的事，為什麼有人做 膽小鬼賽局雖然是決定誰是膽小鬼的賽局，但不要只是讚賞勝利者 犧牲自己成為膽小鬼的那一方也應該獲得注目 猜銅板賽局 某個城市中，有警察和小偷 警察的選擇是「巡邏」和「偷懶」 小偷則是「進入偷竊」和「不進入」 小偷進入偷竊 小偷不進入 警察巡邏 1, -1 -1, 0 警察不巡邏 1, 1 0, 0 這樣的賽局並不存在奈許均衡 如果改變規則，則賽局構造也會改變 e.g. 增加警察抓到小偷的利益，或沒抓到的懲罰 霍特琳賽局 某片沙灘上，A, B 兩家冰淇淋店都想開店 沙灘約 100m，遊客也均勻分散 那兩家店的老闆會在哪開店呢 左右兩邊是海，一個 - 代表離沙灘 10m 1. A B |- - - - - - - - - - -| 左邊的 50m 都是 A 的範圍，反之亦然 但所有顧客都要走 50m 2. A B |- - - - - - - - - - -| 對顧客最方便，因為對顧客來說最遠也不過就走 30m 最後的奈許平衡會是 1，即使 2 才是最好的結果 然而當 A 想要設店在離海 30m 的地方的時候 B 就會像把店往左移，如此就能吸引到更大範圍的顧客 實際案例 日本拉麵店都集中在車站 Ch4: 動態賽局 - 時間，可以解決問題 動態賽局並不是一個特定賽局，而是一種統稱 隨著時間經過，賽局發展也會產生變化的結構 擴散型賽局 假設目前城市中已經有一家 A 工廠，B 工廠在考慮是否進入 A 工廠的選項是「戰鬥」和「合作」 B 工廠是「進入」和「不進入」 原本 A 工廠的利益是 3 如果 B 工廠不加入的話，自身利益是 0 如果 B 工廠加入，而 A 工廠選擇合作，則雙方利益為 1 如果 B 工廠加入，A 工廠選擇戰鬥則雙方都是 -1 如果用原本的 2x2 表格來做計算 可以發現奈許均衡在「A 戰鬥 Ｘ B 不進入」「A 合作 X B 進入」 B 進入 B 不進入 A 戰鬥 -1, -1 3, 0 A 合作 1, 1 3, 0 不過「A 戰鬥 X B 不進入」是不會發生的 這時候就可以透過「賽局樹」來觀察時間流 - 戰鬥 → (-1, -1) A 工廠 - 進入 → - 合作 → (1, 1) B 工廠 - 不進入 → (3, 0) 這種賽局要使用反向歸納（backward induction），排除「奇怪的奈許均衡」 如果 B 工廠進入，A 工廠就會合作 則「A 戰鬥 X B 進入」可以被排除 再來 B 工廠去比較「A 合作 X B 不進入」和「B 不進入」 就能消除不進入的選項 時間矛盾的問題 - 空包彈式的威脅 就前面的 A, B 工廠例子來說 A 工廠進入市場前的最佳行動是戰鬥，所以一定會表現出強硬的姿態 然而 B 工廠一旦進入，A 工廠就會為了利益選擇合作 像這樣 A 工廠的強勢姿態就只是「空包彈」 實際案例 不 ... 的話，就會 ...。 然而這樣的情況卻沒發生，久而久之就無效了 解決方案之一 - 創造出必須遵守約定的狀況 製藥特許權制度 製藥需要很大的成本，如果沒給予製藥公司製藥成功有販售的特許權 製藥公司就會不願意投入，最後人民會受害 所以這個特許權必須被法定 高級品決不降價 一旦降價，就會產生「等一段時間，價格會下降」的想法 以後的物品更不可能用原價把商品賣出 「重複賽局」和「扣板機策略」 回到最一開始的囚犯賽局 如果這個賽局會執行不止一次 最終兩人就會選擇都不認罪的最佳利益 這兩人本來就已經知道最好的選擇是都不認罪 但因為無法抹去「如果對方背叛了 ...」的想法，才會不做出最佳選擇 但是如果「對方背叛我，我就讓他好看」的策略成為可能 就會產生某種信賴關係，讓兩人都導向選擇不認罪 將無限重複的賽局視為大型賽局，而會成為奈許均衡的選項，即是採取合作關係 這稱為「無名氏定理」(folk theorem) 就算是在短期關係中極可能背叛對方的狀況 只要關係變成長期的，就有可能表現出能好好維持合作的關係 Ch5: 人為什麼無法理性？ - 情感和賽局理論 所有的賽局都是在一個共通條件上成立的 - 玩家只考慮自己的利益，各自做出符合理性的行動 而這個前提卻是常常不會成立的 人能預測未來嗎？ - 蜈蚣賽局 爸爸手上有 100 枚硬幣，要分配給 A, B 兩個兒子 但必須遵循以下兩個規定 首先，爸爸會在 A 面前放 1 枚 A 可以選擇「停止」或「繼續」 如果選擇「停止」就結束 選擇「繼續」，則爸爸會從 A 那邊拿起 1 枚 ( 即使後期 A 有不止 1 枚，還是只會拿 1 枚 ) 並且再加上手上的 1 枚，2 枚一起給 B 這個狀況用反向歸納預測的結果是「A 在第一回合就應該選擇停止」 如此 A 便能獲得比 B 還多的硬幣 但是在實際實驗中，卻沒有人做出了這樣的決定 人並沒有辦法預測未來 拍賣賽局 - 證明人會從理性到瘋狂 與一般拍賣不同 競標成功後，未得標的前一位出價者，需要付他喊出的價錢 而這個東西依然會給得標者 也就是，前一位出價者付了錢卻什麼都拿不到 這種賽局一直執行下去，玩家就必須一直往高價喊 實際案例 選舉的燒錢比賽 泡沫經濟 「你沒想清楚後果」確實是個問題，但是你還要考慮的是「其他人沒想清楚後果的可能性」 只用金錢，無法驅動人心 利益並非唯一能影響人心的，往往情感也是 最後通牒賽局 A, B 兩位玩家憑空得到 1000 元 由 B 決定分配方式，A 有同意或否決權 A 同意的話則造這個分配方式 A 否決的話就都拿不到錢 只執行一次賽局 如果人是理性的，A 即使只拿到 1 元都應該接受 然而實際上這樣的狀況卻幾乎不會發生 獨裁者賽局 (Dicatator game) 跟上面同樣的情境 只是這次 A 沒有任何決定權，只能接受 B 的分配 此時 B 的最佳選擇就是 1000 元全部拿走 然而實驗結果，相當多的人依然會給對方一定程度的金額","tags":"Book","url":"https://wei-lee.me/posts/book/2016/10/how-to-think-like-a-game-theorist","loc":"https://wei-lee.me/posts/book/2016/10/how-to-think-like-a-game-theorist"},{"title":"[Book] 穀倉效應","text":"什麼是穀倉？ 組織內各部門自成一格 後續可能造成，組織內資訊不流通，組織各部門內鬥 然而在現在專業分工的時代，聚集專業人士的穀倉也是必須存在的 這本書用案例說明穀倉會帶來的問題和如何減少那些問題 Outline 第 1 章介紹如何透過人類學的概念來思考 2~4 章是穀倉效應造成問題的案例 第 2 章是 sony 的案例，即使他們已經發現穀倉的問題，卻也還是無法解決 5~7 章則是打破穀倉的實際案例 第 6 章是 Facebook 的案例 第 7 章是克理夫蘭臨床醫學中心 第 8 章則是在穀倉造成問題及打破穀倉各提一些 如果要快速看過，建議順序是 前言 → ( 第 1 章，可看可不看 ) → 2~4 選一章 → 5~7 選一章 → 結語 前言：彭博市府的機密任務 廢油處理問題 （跨部門的合作） 餐廳多半趁深夜偷偷倒油，數年來讓當局一直束手無策。 弗勞爾斯小組從環保部取得廢油污染的資料，跟餐廳執照、退稅紀錄與廚房火警等不同資料互相比對。 他們標定並未申請廢油處理的餐廳，列出可能偷倒廢油的餐廳名單。 然後到市府另一個負責廣生柴油的部門，詢問部門人員時否願意跟食安稽查員與消防單位合作， 說服餐廳不再偷倒廢油，而是把廢油賣給回收單位。 福勞爾斯說：「現在稽查員發現餐廳偷倒廢油時，不會只是走上前說：『喂，搞什麼鬼啊！罰緩二萬五千美元！』 他們改成說：『別傻了，拿這些來換錢吧！賣給生質柴油公司吧！外頭一大堆公司巴不得要購買這些廢油呢！』」 Ch1 - 局外人：從人類學照見穀倉 環境裡的習性不僅反映我們頭腦裡的心理地圖與分類系統，還會加以強化 由於菁英階級樂於維持現狀，他們會設法強化既有的文化、規則與分類方式 沈默具有意義，特定議題遭到忽略，是因為大家早已經把這些議題視為無趣、禁忌、平淡或無禮 Ch2 - 章魚甕：穀倉如何拖累革新 儘管專業化穀倉讓公司顯得更有效率，至少短期如此，但有利也有弊 管理階層發現要自負盈虧，他們開始試著「保護」自己的部分 不只對抗公司外的競爭對手，也對抗公司裡的其他部門 不願彼此分享點子 優秀人員不在跨部門輪調，合作程度降低 連創新實驗與長期投資也逐漸減少，大家短視近利，不願承受風險。 Satya Nadella 說：「一但你太過依賴過往的成功，就容易不願互相合作 ... 但外頭競爭對手才不管你們內部有什麼問題」 Ch4 - 俄羅斯娃娃：穀倉如何造成狹隘視野 決策者看不見危機的最大原因在於整個系統過度分工 e.g. 總體經濟研究者關注經濟數字，卻忽略金融系統的細微變化 銀行監管機關監督個別銀行，卻忽略其他金融機構 有些民營銀行相當了解影子銀行，但沒有跟中央銀行人員交流 Ch6 - 改寫社會規則：打開穀倉大門 每一個進入臉書的員工都必須參加新兵訓練營，在不同部門論調，藉此了解整間公司，透過這個想達到是的是兩件事 人員分為不同的專案團隊，各自專門負責特定任務 編寫程式需要針對特定專案進行密切的團隊合作 穀倉是臉書這類的公司的必要之惡 如果沒有專業部門和團隊，根本無法完成工作，也難以集中火力與區分權責 讓不同專案團隊的成員之間斯底亞有第二套人際關係，不受正式的部分區分所限 藉此避免專案團隊變得僵化與封閉，讓人員不只對所屬團隊有感情，也對整個公司有向心力 Ch7 - 取下鏡片：醫生如何避免經濟專家的錯誤 透過建築空間來鼓勵人員打破穀倉 Facebook 的 Hacker 廣場 克理夫蘭臨床醫學中心的空橋 李透說：「長年傳統與慣例只在不得不時才會改變。哈佛不必改變，哈佛就是哈佛，具有悠久歷史，還是世上募款能力最強的名校。但我們（克理夫蘭臨床醫學中心）試衣間不太賺錢的醫院，位於人口逐漸減少的夕陽工業成，不得不做得更好，並發揮創意。」 結語 像人類學家一樣看世界，換你主宰穀倉 世界上穀倉造成的問題 官僚部門之間缺乏溝通 公司內部團隊明爭暗鬥，把資訊扣在自己手上 破除穀倉的啟示 大型組織不仿讓團隊界線保持彈性 讓不同部門一起激盪與合作 透過空間設計讓人員不期而遇 組織必須反思薪資與獎勵，當人員報酬完全取決於團隊表現，不同團隊容易彼此內鬥 資訊流通的重要 跳脫一般想像的分類方式 多數人幾乎始終把既有的分類、制度視為理所當然","tags":"Book","url":"https://wei-lee.me/posts/book/2016/10/the-silo-effect","loc":"https://wei-lee.me/posts/book/2016/10/the-silo-effect"},{"title":"COSCUP 2016 小啄如何實作的","text":"今年 COSCUP 的聊天機器人「小啄」 終於在今天宣告退休了 退休前他讓我們詢問了「你是如何實作的」 這邊是我測試的所有結果 跟大家分享一下 XD 總結 技術相關 主要用 Python 開發 使用 Flask + Gunicorn + Nginx，達到系統輕量化與多執行緒 用 redis 作為文本儲存，SQL Injection 無效 後台文本管理使用 google sheet 使用 Python 的 gspred 文案編輯完後，對 bot 下同步指令，將 google sheet 資料更新到後端資料庫 跟吃飯喝水一樣簡單，連麻瓜劇本管理員都會用（？？？？？？） 使用 wit.ai （這是我直接問開發者的，不是小啄回答的） 小啄回覆的原文 小啄的後台文本管理使用 google sheet，透過 Python 的 gspread 套件進行溝通；當文案編輯完畢後，對 bot 下同步指令，後端就會透過 gspread 將 google sheet 的資料同步到後端資料庫唷 小啄的後台文本管理使用 google sheet，python 有個套件叫 gspread，讓你存取 google sheet 跟吃飯喝水一樣簡單！ 小啄的後台文本管理使用 google sheet，python 有個套件叫 gspread，讓你存取 google sheet 跟吃飯喝水一樣簡單！ 真的超簡單的，連麻瓜劇本管理員都會用！（麻瓜忍不住一定要再說一次） 小啄使用的佈署環境是 Flask + Gunicorn + Nginx 的組合，藉此達成系統輕量化與多執行緒的接收訊息。 小啄使用 redis 作為文本儲存系統，因此不要再試著 SQL Injection 喇，這是沒用的!!! 小啄是採用 Python 做為主要的程式語言開發喔，因應短暫兩個禮拜的開發時間，可以快速建置的 Python 成為最佳選項！ 小啄開發團隊核心人物有 4+1 個：三個寫扣手，一個文案小編，一個文案小編的助理．我們白天都有正職！文案小編和文案小編的助理是程式麻瓜 你知道後台文本管理的劇本是怎麼產生出來的嗎？是劇本管理員在夜深人靜、抱著電腦想著所有使用者可能在使用中遇到哪些問題，套用哪些回應可以又好笑又不無聊、絞盡腦汁想出來的；也因此好幾天發現窗外鳥兒演唱會都在清晨五點左右開唱。 你有選英文模式小啄嗎？真抱歉人力不足，沒有能力提供好笑有趣的回饋讓大家使用。 (舉起誠實樹) 因為缺乏英文小編寫幽默風趣的回饋，所以團隊人員最後放棄英文幽默版小啄。 小啄 @LINE 開發時程只有兩週，要申請正式帳號前須到 LINE 本部進行 DEMO，當時大會還有些 API 沒開好、攤位集點巔峰賽還沒有畫好圖。嚴格說起來是大會團隊在忙其他緊急事件延遲了 BOT 開發時程，請大家多包容唷 小啄 @LINE 上線前需要經過 LINE 內部審核，然後才會投單到日本總部申請上限；內部審核當天其實有些功能還沒做完啊啊啊啊啊 很可惜今年閃電秀沒有 COSCUP LINE BOT 的分享；而實際上我們是有報名的，只是沒有被抽到 QQ，想在明年看到團隊在議程上分享秘辛，請用力回饋：明年想看 小啄 @LINE 分享 開發團隊有報名閃電秀，可惜沒有被抽到，想進一步鼓勵團隊明年投稿，歡迎用力回饋：明年想看 小啄 @LINE 分享","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/10/coscup-2016-how-to-implement-small-pecks","loc":"https://wei-lee.me/posts/tech/2016/10/coscup-2016-how-to-implement-small-pecks"},{"title":"Basic Git Tutorial","text":"最近終於下定決定把很久以前的這份 Git and GitHub 改版了 聽說這份在我進實驗室前，就已經被不想教大家 Git 的學長拿去流傳 ... 新版： Git Tutorial 新版主要加了 如何寫好 commit tag stash rebase submodule 還有各種我這些年開發上有用到的 Git 功能 順便來練習一直想學的 reveal.js 因為用了 external.js，一開始 load 的時間會稍微久一點","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/09/basic-git-tutorial","loc":"https://wei-lee.me/posts/tech/2016/09/basic-git-tutorial"},{"title":"Using GitHub to Develop Software Collaboratively","text":"這是兩年前 GitHub 來成大教育課程的筆記 最近在整理 git 的筆記才翻出來 因為當時是以英文進行，課程筆記就也用英文做了 這篇的內容可能比較雜亂，之後還會再整理進另一篇 git 的筆記 Introduction to Git Hub (Company) There are around 2600 staffs in GitHub and 40% of them live in San Fransisco. Among them, there is one Taiwanese. Git Wrote by Linus Torvalds. Why version control? Historical propose Collaboration Tutorial git init \"path\" .git is just a folder with normal file There is no daemon or background progress Everything is operated in file Never rm -rf .git XD git stauts touch README.mdd There are three main stages working staging repo Stage Action Stage working add → staging staging commit → repo working ← checkout repo git add README.md When we're ready git commit -m \"add a blank commit\" After README.md is modified git add README.md git status Now this file is in staging area So, how to go back to history? git reset README.md Take a look at our history git log Go back to history git checkout \"SHA1\" git checkout master Everything comes back master is the default branch name of git. It is a default word but not reserved. git checkout -b \"branch_name\" create a branch and checkout to it diff git diff : View the difference between working and staging git diff --staged : Difference between staging and repo git diff \"SHA1\" : Difference between current version and SHA1 git diff master~1 : difference between current and the one before master git diff master&#94; → master~1 git diff master&#94;&#94; → master~2 git diff a b : Show the change from a to b branch In git, branch is not copy. It's like bookmark Actually git branch -d \"name\" just delete the pointer but not the entry. HEAD: the pointer points to current entry detach error If you go back to a entry not in certain branch, a detach error might occur. For example, checkout to a commit that is parent of more than one branch and then append a new commit to it. In such case, this new appended commit might not be able to be referenced. The solution to this problem is to create a new branch for it. log git log --decorate : Show also branch info git log --all : Show all branch git log --graph : Show graph The difference between log and show git log : Only the first line git show : All the message, not only the first line GitHub push origin is a short hand name of that remote url. In other word, your repo. git push -u origin master upload master to origin 8 -u tell git the default url to push for that branch(master) is origin, it would also make git pull remember Do -u and after that you can just use git push pull git push --all : push all branch git pull --prune difference between fetch and pull git fetch : go to remote and copy it git pull → fetch + merge on-site pull request on GitHub @person-name → notification Have a conversation with the whole team Write \"fix #2 ....\" in git commit → special meaning → specify the bug in issue on GitHub Wiki → documentation How to write a good git commit Principle Separate each commit Let the commit tell a story More specific One line 80 character Use present tense instead of past tense Don't repeat what can be found in git diff If more detail is to be written, left the second line to be blank. Write more detail about why this change happened after the third line. Other issue git config --global -e : Edit your .gitconfig file. Not include binary files and executable Don't version control these kinds of files. Also, large files are not recommended to add to git. If it's needed, try git-annex (web-site). git revert \"SHA1\" → save another entry of undo If you commit the password → git rebase can change commit, but it is not that recommended. git submodule create a sub-module","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/09/using-github-to-develop-software-collaboratively","loc":"https://wei-lee.me/posts/tech/2016/09/using-github-to-develop-software-collaboratively"},{"title":"[Book] 賈伯斯傳","text":"記得我去上海交通大學交換的時候 一門有關創新的課，老師跟我們說一定要看喬布斯傳 終於把他看完了，算一算竟然花了 11 個小時 亞特金森也用高階程式語言 Pascal，為蘋果二號寫程式。 賈伯斯本來認為蘋果二號只要用 Basic 就夠了， 但他還是告訴亞特金森：「 既然你這麼喜歡 Pascal，我給你六天的時間證明我是錯的。 」 亞特金森果然做到了，賈伯斯自此對他更加尊敬 。 在蘋果公開上市三十年後，賈伯斯曾回想一夕之間億萬在手的心情 我向來不曾為了錢傷腦筋。我生長在中產階級的家庭，從不擔心自己會餓死。 我在雅達利工作過，知道我還能以工程師混口飯吃，生活一定過得去。 上大學和去印度那段時間會那麼窮，是為了體驗清貧的感覺。 我的生活一向簡單，上班之後也一樣。我經歷過窮苦的日子。 我覺得很棒，反正沒錢，就用不著為了錢掛心。 後來變得非常富有，錢多到數不完，也不必擔心錢的事。 我看到蘋果工作的一些人賺了大錢，便覺得自己飛過另一種生活不可。 有人買了勞斯萊斯和好幾棟豪宅，每一棟都得請管家來管理，之後又得找個經理來管這些管家。 他們的老婆紛紛去整形，最後變得怪裡怪氣。 實在很瘋狂。這不是我要的生活。我對自己承諾： 我決不讓金錢破壞我的人生 。 賈伯斯很喜歡跟人說一件事：他每次做對一件事情的時候，都是因為先前有機會讓自己暫停、按一下倒帶鈕。 每一次，他發現事情不夠完美，一定重新再做一次。 「如果你發現有些事情不對勁，你不能當作沒看見，之後再回頭來處理」賈伯斯說：「那是別家公司的作法，不是蘋果的做法」 從一開始，我就知道蘋果必須仰賴智慧財產的保護，才能蓬勃發展。 如果大家都盜用我們的軟體，我們根本就沒戲唱了。 如果智慧財產不能受到保護，我們就沒有任何動力，去創造新的軟體或打造新的設計。 一旦沒有了智慧財產權的保護，靠創意存活的企業也將消失，或根本不會出現， 但最根本的原因還是：偷竊就是不對。不止傷害別人，也有損自己的人格。 賈伯斯的企業經營原則是，決不害怕吃掉自既有的市場。 他說：「你不自己吃，別人也會吃下去！」 因此，即使 iPhone 有可能侵蝕 iPod 的市場，iPad 也可能吃掉蘋果筆電的是長，賈伯斯也從不卻步。","tags":"Book","url":"https://wei-lee.me/posts/book/2016/09/jobs","loc":"https://wei-lee.me/posts/book/2016/09/jobs"},{"title":"[Book] 一個人的會議時間","text":"這本書其實是我幾年前買的 最近開始覺得好想應該檢視一下自己每天的生活到底過得如何 突然才想起還有這樣的一本書 學會跟自己開會，才懂得怎麼經營「自己」這家公司 Ch2-3 問題對策會議 人們大多愛瞎操心 問題本身不見得是大問題 反而是「有問題還沒處理」所引發的這種煩躁造成了問題 試著全都寫下來 即使被事情壓得喘不過氣 把它們寫下來就能讓自己心安許多 接著將他們分類成以下四種 「何時要做」（列入 TO-Do） 「拜託、請教別人」（列入 To-Do） 成功、達成目標的人，大多是「擅長拜託別人」的人 訣竅在於弄清楚要「拜託誰」、「拜託什麼」 「接受」（煩惱也沒用的事） 「捨棄」（丟掉那些對人生並不是那麼重要的事） Ch2-8 行程會議的訣竅：醞釀期待感 列出「如果有 5 分鐘，要做的事」 試著總是把明天排成令人期待的日子 Ch3-2 自己的行動方式 如何將 To-Do 迅速地付諸行動 不得不做，只好做了 長久以來內心會累 要不要試著做一點點 即使沒有太多成果也無所謂 訣竅在於不努力 將做這些事變成習慣，而是不是努力要去做的 這樣就能輕鬆地做到這些事 Ch3-3 回覆的方式 E-mail 從新的開始回覆，就可以令對方感到「回應的速度真快」 若從舊的開始依序回覆，新的就會變成舊的 如果舊的真的很重要，對方就會打電話或再寫 E-mail 來催促 忙碌的時候要從新的工作開始處理 Ch4-2 一個月跟自己開一次進階版會議 推薦的問題 小時候，你喜歡什麼呢？ 如果沒有限制，你期望怎樣的將來？ 自己在什麼時候最耀眼？ 人生中最痛苦的時候是怎麼重新站起來的？ 有 30 個你不認識的人，和他們打成一片的過程中，你會想替他們做什麼？ 自己擅長和不擅長的事是什麼呢？ 該請誰幫忙呢？ 臨終時，你會後悔什麼呢？ 你現在想見的人是誰呢？ 你在人生中的什麼時候實現了夢想？ 人生在最耀眼那一瞬間的情緒？ 目標是什麼？什麼進展得順利？什麼又不順利呢？該做什麼？透過這些問題，獲得了什麼？ 該怎麼做才能改變現在的狀況？ Bonus 跟自己開會的步驟 將「跟自己開會」排進 To-Do 找到能夠一個人思考的地方 宣告「現在開始跟自己開會」 向自己報告近況 五種跟自己開會的形式 主題會議 提出主題 變成怎樣才好呢 該怎麼做才會變成那樣 記下 To-Do 問題對策會議 寫下面對的問題 變成怎樣才好呢 該怎麼做才會變成那樣 記下 To-Do 自由會議 不斷寫下心中浮現的想法 行程會議 當自己的秘書，將 To-Do 記下 蒐集資訊會議 隨意瀏覽，只記下心中有感的內容 一個月跟自己開一次進階版的會議","tags":"Book","url":"https://wei-lee.me/posts/book/2016/08/meeting-with-youself","loc":"https://wei-lee.me/posts/book/2016/08/meeting-with-youself"},{"title":"[Book] 你如何衡量你的人生","text":"最近發現竟然沒有把這本還蠻喜歡的書 po 上來 就好好的把之前整理的書摘，再重新整理過一遍 這本書的每一個章節都是先講商業上的案例和處置，之後再將這些套用到生涯中 Part 1 發現生涯之樂 希望你也能有這種感覺 — 每天一睜開眼睛，為了可以做自己喜歡的事而欣喜 有很多人看什麼是最緊急就花時間在上面，或是把心血注入到最快得到回饋的事 。 這都是建構策略時必須小心的陷阱 Ch2 如何讓你的熱情燃燒 ( 誘因理論 ) 為什麼經理人在營運的時候不考慮股東的最佳利益？ 因為你付多少錢給經理人，他們就做多少事 只有經理人的利益跟股東的利益相連才能解決這個問題 e.g., 公司股價上升，經理人也獲得較高的酬勞 一個理論是否可靠，最好的驗證方式就是找出反常的例子，也就是該理論無法解釋的現象 e.g., 最先研究飛行的先驅認為羽毛是必要 卻發現蝙蝠沒羽毛會飛，鴕鳥有羽毛卻不會飛 保健因素 vs 動機因素 保健因素 : 工作的某些因素如果出問題，讓我們覺得不滿意，這些就是保健因素 有趣的是，薪水對於工作來說只是保健因素 即使不斷改善工作的保健因素，也不能讓一個人熱愛工作，頂多就是不討厭而已 需要的是動機因素 追逐薪水頂多緩和工作的挫折感 為了發掘真正的快樂，你必須不斷找尋有意義的機會，讓你得以學到新的東西，肩負更多責任 如果你找到你愛的工作，你將沒有一天覺得自己在工作，而是在做一件有意義的事 Ch3 計劃與變化 在工作生涯當中，你會發現你最喜歡的領域是甚麼，最後必然可找到能滿足保健因素，也能使動機因素發揮最大效用的工作 最重要的是， 你一定要走出去嘗試 ，才能知道甚麼樣的工作最符合你的才能和興趣 如果要工作愉快，哪些假設必須證明為真 ? 接受這份工作的動機是出自內在，還是外在因素 ? 為什麼你認為自己可以愉快勝任 ? 每次考慮換工作時，請你想想最重要的假設是甚麼，如何去證明他 ? Ch4 策略的試金石 個人的誘因跟公司長遠目標衝突，是常見的現象 e.g. 立委任期為四年 一個好的國家計劃要五年十年 然而要讓自己繼續連任，只有提出短期能有成效的計劃才能達到讓自己連任的目標 要同時顧及個人及團體，是非常不容易的 Part 2 圓滿的人際關係 在做資源分配時，你必須注意是否與心中的優先順序相符 對你來說，什麼是成功 ? 什麼是不重要的 ? 沒有結果並非代表你失敗了，只能證明你用的方法還不對 Ch5 時鐘滴答響 在所有成功的公司當中，有 93% 都必須改變最初的策略 所以 不一定要訂定一個固定的生涯目標，而是隨著自己不斷的成長而一直改變 稍微想想，就會發現在忙碌時我們疏忽了哪些人 你或許覺得家人很愛你，你和朋友友誼深厚，他們不會在乎被疏忽 其實不然 長久不花時間、精力去培養人際關係，身邊的人最後還是會離你而去 Ch6 一杯奶昔的任務 每一個成功的產品或服務之所以能大受歡迎，是因為這種東西 幫我們完成了不得不做的工作 如果一個人開發出一種有趣的產品，但沒能幫上消費者的忙，這種東西就難以成功 我們可以為伴侶做任何事情，但是如果做得並不是她最需要的，就會面對挫折與困惑 即使我們用心良善，也有深切的愛，還是常常誤解彼此需要的 請問自己「另一半需要我做甚麼 ?」 Ch7 席瑟司之船 別把未來外包 你得了解未來要成功必須具備的能力，無論如何都別把這樣的能力外包了，否則就是把未來交給別人 e.g., DELL 逐步將個人電腦的技術包給華碩，最後華碩自創品牌，DELL 就不再具有優勢了 「我父母給我最好的禮物並非他們為我做了甚麼，而是他們沒為我做的」 Ch8 經驗學校 很有趣的統計，企業主管認為自己所用非人約有 25% 換言之，主管時常用錯人 他們在產品製造或服務上追求零瑕疵 但在挑選人才時，出錯機率卻高達 25% 然而他們卻認為這樣的錯誤率是可接受的 Ch9 一隻看不見的手 在孩子還小，尚未面臨困難的選擇時，就必須培養他們心中設定優先順序的能力 長大以後，他們才知道如何評估各種選擇，做出最好的決定 企業文化 文化不是管理階級花時間和員工溝通、講述就可以形成的，當然也不是寫寫標語就好了 文化會建立在員工做的一連串決定上 每次碰到問題或挑戰時，如何去解決他的決定 例如 :「新產品是不是品質尚可就達到出貨標準了 ?」 如果面對這樣的問題，負責的人討論後決定只要品質尚可就能出貨 下一次員工面臨類似問題的時候就會做出同樣的決定 碰到問題時，不只是解決就好了，還必須從解決的過程了解什麼是最重要的 同樣的道理，如果你希望家人都能在家庭文化的影響下 依循依定的優先順序做事，這樣的優先順序則必須跟文化相符合 例如你希望家裡有和善的文化，那麼在孩子第一次碰到跟和善相關的選擇，你就得幫他做決定 若孩子沒這麼做，你就得針對這件事指導孩子，並解釋為什麼他們該採取和善的做法 Ch10 就這麼一次 ... 百分之百的堅持比百分之九十八來得容易 有很多人都相信自己真的只是一次妥協，下不為例 如果是小小的選擇，我們都有很好的理由 這些選擇往往不是攸關一生的重大決定。乍看之下邊計成本都很低 然而一個又一個決定累積下來，你就會慢慢走上不歸路，變成不一樣的人 百分之百堅守原則，比百分之九十八來得容易 如果你不越界，個人道德界限的力量就會很強大 要是你用好理由說服自己，那就成了一個沒有原則的人，甚麼事都做得出來 為了變成自己理想中的，每一個人的過程都不同。不管如何，你應該要能回答這樣的問題 :「我真的想要變成那樣的人嗎 ?」 「如果我將每日禱告、反思的時間拿來研究迴歸分析，我將後悔莫及。 每年，我用到計量經濟學工具不過只有幾次，而我對人生目的的認知卻天天都可派上用場」","tags":"Book","url":"https://wei-lee.me/posts/book/2016/08/how-will-you-measure-your-life","loc":"https://wei-lee.me/posts/book/2016/08/how-will-you-measure-your-life"},{"title":"[Paper] A Learning-based Framework to Handle Multi-round Multi-party Influence Maximization on Social Networks","text":"Paper 1. Introduction Problem Description A company intends to select a small set of customers to distribute praises of their trial products to a larger group Influence maximization Goal: Identify a small subset of seed nodes that have the best chance to influence the most number of nodes Competitive Influence Maximization (CIM) Assumption Influence is exclusive (Once a node is influenced by one party, it will not be influenced again) Each round all parties choose one node and then the influence propagates before the next round starts STORM (STrategy-Oriented Reinforcement-Learning based influence Maximization) performs Data Generation the data, which is the experience generated through simulation by applying the current model, will become the feedbacks to refine the model for better performance Model Learning Difference with Others Known strategy → Both know and unknown Known or Unknown but available to compete → Train a model to learn strategy Unknown → Game-theoretical solution to seek the Nash equilibrium Single-roung → Multi-round Model driven → learning-based, data-drivern Not considering different network topology → General to adapt both opponent's strategy and environment setting (e.g. underlying network topology) 2. Problem Statement Def 1: Competitive Linear Threshold (CLT) CLT model is a multi-party diffusion model The party who has the highest influence occupied the node Def 2: Multi-Round Competitive Influence Maximization (MRCIM) Max its overall relative influence 4. Methodology NP-hardness of MRCIM → looks for approxmiate solution Max the inflence for each round does not guarantee overall max Due to the fact that each round are not independent 4.1 Preliminary: Reinforcement Learning Learn a policy \\(\\pi(s)\\) to determine which action to take state s (environment) How to estimated \\(\\pi\\) ? Expected Accmulated Reward of a state (V function) \\( V&#94;\\pi(s) = E_\\pi\\{R_t|S_t=s\\}=...\\) Expected Accmulated Reward of a state-action pair (Q function) \\( Q&#94;\\pi(s, a) = E_\\pi\\{R_t|S_t=s, a_t=a\\}=...\\) The optimal \\(\\pi\\) can be obtained through Q functinon \\( \\pi = \\arg \\min_{a\\in A}Q(s,a)\\) (i.e. For all \"a\" in A, find the \"a\" such that min Q(s, a)) 4.2 Strategy-Oriented Reinforcement-Learning Setup Env Influence propagation process Reward Delay Reward: The difference of activated nodes between parties at the last round After the last round, rewards are propagated to the previous states through Q-function updating Slow but more accurate Action Choosing certain node to activate too many overfit Single Party IM strategies Namely, which strategy to choose given the current state The size can be reduced to strategies chosen Chosen Strategies sub-greedy degree-first block max-weight State Represents network environment status record the occupation status of all nodes \\(3&#94;{|V|}\\) , too many overfit Features Designed Number of free nodes Sum of degrees of all nodes Sum of weight of the edges for which bot h vertices are free Max degree among all free nodes Max sum of free out-edge weight of a node among nodes which are the first player's neighbors Second player's Max activated nodes of a node for the first player alter two rounds of influence propagation Second player's The feautres are quantize into low medium high Totally, \\(3&#94;9\\) states Data For Training Propagation model is known (e.g. LT in the experiments) Strategies served as actions are predefined In training phase, train the agent against a certain strategy and see how it performs on the given network These data can be used to learn the value functions Training Against Opponents Opponent Strategy Known: Simulate the strategy during training Unknown but available during training: Same as above Unknown: More General Model in 4.4 Phase Phase 1: Training The agent update its Q function from the simulation experiences throughout the training rounds Update \\(\\pi\\) in the meantime Phase 2: Competition The agent would not update Q-table Generates \\(\\pi\\) according to Q-table 4.3 STORM with Strategy Known Training the model compete against the strategy to learn \\(\\pi\\) STORM-Q Update Q-function following the concept of Q-learning Q-Learning: \\(Q(S_t, a_t) = Q(S_t, a_t) + \\alpha * (r_{t+1} + \\gamma * max_{a}Q(S_{t+1}, a) -Q(S_t, a_t))\\) \\(\\epsilon\\) -greedy Determine strategies on the current policy derived from Q-table. Explore the new directions to avoid local optimum Pure Strategy The most likely strategy is chosen $ Algorithm $ 4.4 STORM with Strategy Unknown Unknown but available to train The differece between the known case is that experience cannot be obtained through simulation Train against unknown opponent's strategy during competition It's feasible because STORM-Q only needs to know the seed-selection outcoms of the opponent to update the Q-table, not exact strategy it takes Unknown Goal: Create a general model to compete a variety of rational strategies Assumption: The oppoent is rational (Wants to max influence and knows its oppoent wants so) STORM-QQ Two STROM-Q compete and update Q-tabale at the same time Using current Q-table during training phase Pure Strategy Does Not guarantee that equilibrium exists in MRCIM STORM-MM Mix Strategy (Samples an action from the distribution of actions in each state) In two-player zero-sum game Nash equilibrium is graranteed to exist with miexed strategies Use MINMAX theorem to find the equilibrium \\(Q(s, a, o)\\) : The reward of first party when using strategy \\(a\\) against oppoent's strategy \\(o\\) in state \\(s\\) \\(Q_{t+1}(s_t, a_t, o_t) = (1-\\alpha)Q_t(s_t, a_t, o_t)+\\alpha[r_{t+1}+\\gamma V(s_{t+1})]\\) Operations Research The differece between STROM-QQ and STORM-MM STROM-QQ STROM-MM Max the reward in their own Q-table Finds equilibrium with one Q-table and determines both side's \\(a\\) at the same time Pure Strategies Mixed Strategies Choose strategy by greedy Samples from the mixed strategy \\(\\pi_a\\) or \\(\\pi_o\\) Ideally, they should have similar result in two-party MRCIM. In practice, the result might not due to STORM-QQ does not guarantee equilibrium Although equilibrium exists in STORM-MM. It does not guarantee to be found due to lack of training data or bad init or such problems.","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/08/a-learning-based-framework-to-handle-multi-round-multi-party-inflence-maximization-on-social-networks","loc":"https://wei-lee.me/posts/tech/2016/08/a-learning-based-framework-to-handle-multi-round-multi-party-inflence-maximization-on-social-networks"},{"title":"COSCUP 2016","text":"hackholder 共筆 Day1 R 語言翻轉教室簡介 Why R ？ 統計人多用 R，所以最新的統計演算法，最可能最早被實作在 R 上 R 套件的易開發性 易讓非工程背景者上手 先進的視覺化 教 or 學 R 的挑戰 函數名稱不一致 同樣的方法可以用太多方式達成 PTT R 版 聽說對新手很友善 R 語言翻轉教室 開源軟硬體實做全套電子鼓 (python + RPi) 第一場在中研院的演場會 (?) 我到的時候就差不多在 live demo 了 算是剛好沒錯過精彩的部份 XD 商業公司如何建立開發者生態系統 B2D(Business to Developere) Open Source 跟 Open API，對於商業公司來說有什麼價值 Open Source OpenAPI 開放程式碼 開放呼叫功能 Read/Write model Read-Only model 貢獻者社群 使用者社群 產業聯盟 → 產業標準 相互競爭 → 寡佔市場 另外比較有趣的是 華為有個部門就是專門在預測未來哪種 Open Source 會火 作為下一個貢獻的 Open Source 專案 早期投入那項技術 自己的樂器自己做：第一把開放硬體設計的電烏克麗麗 閃電麗麗 之所以閃電麗麗這麼不像一般的烏克麗麗 是因為一般 3D 印表機，印不了那麼長 講者有提到他如何去構思該做出怎樣的改變，才有辦法符合 3D 印表機的限制 好像是弦要到那樣的長度才能剛好發出烏克麗麗的聲音 其他的部分就能改用不同的方式取代，不用受限於制式的樣式 於是閃電麗麗就誕生了 Day2 Opensource 將如何對第五代行動通訊 (5G) 造成革命性的改變 4G 到 5G 的改變 使網路能以軟體的速度成長，而非硬體的速度 將以往綁在硬體商的部分虛擬化 SDN NFV 讓各種不同的服務可以有各自不同需求的網路特性 講者的 slideshare Debater 辯論家：網路筆戰大亂鬥 講者直接在 hackpad 寫她不會脫稿演出，可以直接看 投影片 + Note 所以我就也放她的連結就好 XD 講者有提到 HackMD 主要是用來 Markdown 協作 之前一直覺得 Hackpad 的 Markdown support 沒有很好 終於有人做出這個東西了 XD 開放公司文化之下的軟體開發 / 如何用開源軟體賺錢？ 找到使用者的痛，解決他 如果其中部份剛好有開源軟體可用，算你撿到的 我們如何用開源軟體 觀察客戶要甚麼 加上重要功能，甚至比原來的軟體還大 願意自己重寫 甚至徹底改變商業模式 建置世界級的大系統 注重使用者體驗 Lightning 今年 Lightning 也有很多有趣的主題 MRT & GIT 用 git branch 來畫台北捷運的路線圖 不要亂玩 git branch 啊 XD othree/taipei-mrt 徵音梅林新歌發表 講者完全沒說到話，真的就是新歌發表到三分鐘結束 XD video 今年的 COSCUP2016 梗全集 ，還蠻有趣的 XD","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/08/coscup-2016","loc":"https://wei-lee.me/posts/tech/2016/08/coscup-2016"},{"title":"Scrollable RISE","text":"RISE 是一套結合 jupyter-notebook 和 reveal.js 的專案 讓我們能在 jupyter notebook 直接開啟如同 reveal.js 的 slide 不過如過 notebook cell 中的內容太長 在播放的時候就會導致內容被裁剪 而 RISE 預設是無法用滑鼠滾動的 所以這裡記錄該如何讓 RISE 可以滾動 進入 jupyter notebook 的任一個 notebook 後 在上方工具列點選 Edit → Edit Notebook Metadata 接著在裡面加入 livereveal 的設定 如下 （只需加入 livereveal 的部分） { \"kernelspec\" : { ... }, \"livereveal\" : { \"scroll\" : true } } 不過開發者其實有說，開啟滾動會造成不少問題 所以預設上才會設定為不能滾動 damianavila commented on Jul 12 After several and long discussions with a lot of people, we have arrived to the conclusion that scrolling on reveal.js based slideshows brings more problems than benefits, so I will not add the scrolling as a default option BUT we should clearly document how to get scrolling slides with the config option available. I will mark this as a docs issue and prioritize properly. Reference scrolling vertically #185","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/08/scrollable-rise","loc":"https://wei-lee.me/posts/tech/2016/08/scrollable-rise"},{"title":"[Book] 引誘科學","text":"Ch1 - 注意力有三種 : 即時、短期、長期，怎樣抓住 顏色應用的一般性原則 藍色多代表平靜 最令人喜歡的顏色或組合：藍色、藍綠色、綠色、綠紫色、紅紫色、紫色 最不討喜：綠黃色、黃色 令人感到興奮、激勵或警覺，應該選用暖色系 Ch3 - 框架誘因 認定某樣東西很受歡迎不會改變其價值，但如果認定某樣東西本來就是限量的，則會提高其身價 Ch5 - 獎勵誘因：不只給錢、祭優惠、送獎品，怎樣獎勵最有效 幾年前的某個晚上，我和一群科技界的朋友，在舊金山一家高級餐廳聚餐，主客是遠道來的米娜拉。 可是我們竟然集體冷落她，每個人都在低頭防著滑手機、寫簡訊、看推特、回電郵，簡直像在比賽誰能一直盯著手機似的。 看不下去的米娜拉提議大家來玩手機疊疊樂遊戲，每個人都要交出手機，並疊在另一支手機上，第一個伸手去拿手機的人要負責買單。 後來再也沒有人去碰手機了，我們終於有機會開懷大聊。 內源性獎勵 外源性獎勵和內源性獎勵的差異，在於想要得到獎勵的東擊是不同的 我們會為外源性獎勵而去注意或做某件事 內源性獎勵的動機則是來自事情本身，我們會去注意或從事我們認為值得的事，不在乎是否能得到任何外源性獎勵 通用內源性獎勵 權力 獨立 好奇 接納 秩序 收藏 榮譽 理想 社會接觸 家庭 地位 報復 飲食 體能活動 平靜（安全） Ch7 - 懸念誘因：弔胃口、待解之謎 讓完成強迫症發作 懸念誘因必須具備懸而未決、情感投入、逆轉劇情以及結局未卜四個要件，才能持續吸引注意力 如果個人或公司遇上了危機，而且社會大眾和媒體都睜大眼睛等著下一步作為時，正確的收尾行動乃是第一要務 因為這樣事件才能做個了斷。如果你的收尾行動無法讓人滿意，就會留下一個結局未卜的小缺口，讓人們有機會不斷議論及報導 Ch8 - 肯定誘因：想被認得、想被賞識、想被同理心對待 「球場蓋好，人就會來」在現代世界裡事行不通的","tags":"Book","url":"https://wei-lee.me/posts/book/2016/08/captivology-the-science-of-capturing-people-s-attention","loc":"https://wei-lee.me/posts/book/2016/08/captivology-the-science-of-capturing-people-s-attention"},{"title":"[Book] 增強你的意志力","text":"前言 - 意志力：人類最強大的力量 意志力就肌肉一樣，會因為過度使用而疲乏，但也能透過長期鍛鍊來強化 Ch1 - 意志力不只是一種比喻 控制情緒反應會折損意志力。即使是假裝的也會累 從自我耗損研究歸納出來的法則： 一次專注一項工作 Ch2 - 意志力的能量從哪裡來 沒有葡萄糖，就沒有意志力 當你的身體要對面對疾病，就會消耗大量葡萄糖，所以這個時候就要避免去做需要自我控制的事 血糖過低者受刺激時，會比一般人更難專心和控制自己的負面情緒 餵飽怪獸 如果你有考試、重要會議、或攸關重大的計畫 不要在缺乏葡萄糖的情況下匆匆上場 e.g. 別在午餐四個小時後和老闆吵架 別在晚餐前和另一半討論嚴重的問題 到歐洲浪漫之旅時，別在晚上七點才開進城牆包圍的中古小鎮，企圖餓著肚子找到你的旅館 就算你的車能在錯綜複雜的石板路穿梭無礙，你和伴侶的關係也可能經不起這個考驗 飲食應該挑選熱量燃燒慢的食物 升糖指數高的食物（e.g. 白麵包、馬鈴薯、白飯、零食）會產生大起大落的循環 想維持穩定的自制力，應該吃蔬菜、堅果、水果、起司、魚類、肉類、橄欖油這類的升糖指數低的食物 累了就睡覺 休息可以降低身體對葡萄糖的需要，還能提高對血液裡的葡萄糖的利用能力 Ch3 - 待辦事項的大學問 Zeigarnik Effect: 未完成的工作和未達成的目標會盤旋在心中。等到工作完成、目標達成，不斷提醒的狀況變嘎然而止。 e.g. 聽一首歌，聽到一半突然關掉。稍微過一段時間，這首歌的某個片段可能不斷著在心中唱著 Ch4 - 決策疲勞 做決定需要意志力，而在意志力耗損的情況下，人們會竭盡一切延遲或躲避決定。 「關掉其中一個選項感覺上等於是損失，為了避免這種損失的感覺，人們寧願付出代價」 這麼做有時候很有道理，但我們多半太想保留選擇的自由，而沒看到我們長期付出的代價，或別人付出的代價。 Ch5 - 錢都花到哪去了？ 遠視：太過擔心未來，而損及眼前的生活。 這樣的吝嗇心態會讓人花更多時間、與朋友疏離、讓家人抓狂也讓自己痛苦 Ch6 - 意志力可以鍛鍊嗎 「讓你的大腦習慣訂定小目標，並加以達成，能幫助你做到原本做不到的大事情」 不光為了練習特定的技能，還要把困難度加高，決不寬貸，如此一來，你才會行有餘力，超過原本設定的目標。對我來說，這就是紀律。全靠不斷重複和練習而來」 練習控制情緒並不能強化意志力。意志力也無法用來控制情緒 控制情緒一般得靠其他技巧，像是改變對眼前問題的看法，或者讓自己分心 試著改變一些習慣性的動作（e.g. 坐姿坐正、右撇子用左手寫字），都是自我控制的練習 Ch8 - 戒癮的真相 對許多人來說，停下來喝一杯也許無傷大雅，之後好幾個月也不會酗酒 可是如果是無法控制喝酒的人，就不能把偶爾一次喝酒當成獨立事件 最好的方法，就是離酒吧遠一點 明確界線 如果你只承諾自己「適量」，這並不是明確界線。模糊的界線會漸漸讓你沒發現自己已經失控 零容忍才是明確界線 Ch10 - 節食風暴 What-the-hell Effect e.g., 節食者已經定下每日最高卡路里攝取量，當他們因為某種原因而吃進超標的熱量時，例如實驗喝下兩大杯奶昔，他們便認為當日的節食努力告吹。這時候就會放縱自己去享受，甚至讓自己吃比原本超標的量還多得多的食物 延遲享樂 vs 不 告訴自己「我待會再吃」對大腦的作用等同於「現在就吃」 拒絕甜點需要意志力 對於大腦來說，等一下顯然比永遠不來得輕鬆一點 時間拉長，你的慾望降低，吃進的食物也變少 結語 - 你可以更有意志力，只要你不拖延 減輕生活壓力的最佳方式就是停止搞砸生活 你得好好規劃人生 自制力強的人花在拒絕慾望的時間少於其他人 他們不會把意志力當成經常性策略 他們妥善安排生活，所以能避免麻煩，避免生活出現需要意志力的事件 他們用意志力來避免危機，而不是度過危機 早在汽車故障錢就送車去保養，並遠離吃到飽的自助餐 意志力的運用過程比結果重要 如果你企圖抗拒誘惑、最後屈服，因為你曾經掙扎過，還是會耗損意志力，屈服並不會補充意志力 你必須隨時維持至少五年的籠統願景，然後訂出較具體的立即目標 要知道你在當月要完成什麼，以及如何做到 預留一些彈性，也要做好失敗的心理準備 月底檢討時，要記得你 不需要每一次都達成目標 更重要的是，你的人生逐月進步 「在管理上，我們要求公司主管和其他員工訂出每週的優先目標，目標不能超過三個，小於三個也沒關係。我們每週逐一檢討上週的成果。如果三個目標中，你只完成一個或兩個，無妨，但在前三個目標未完成前，你不能進行其他目標，就這樣，這就是我們的管理方式。它很簡單，但能強迫你先處理最優先的事情，而且嚴格執行」 正向拖延的力量 等一下再享受 把惡習拖延，最後可能就不會去做 保存意志力的持久技巧：習慣","tags":"Book","url":"https://wei-lee.me/posts/book/2016/06/willpower","loc":"https://wei-lee.me/posts/book/2016/06/willpower"},{"title":"解決更新 gcc 找不到 libgfortran.3.dylib (Octave,R)","text":"最近在 mac 上更新了 gcc 6 後，不管是開 Octave 還是 R 都會出現以下的錯誤訊息 dyld: Library not loaded: /usr/local/lib/gcc/5/libgfortran.3.dylib Referenced from: /usr/local/Cellar/r/3.3.0/R.framework/Versions/3.2/Resources/lib/libR.dylib Reason: image not found Trace/BPT trap: 5 這是因為原本的 lib 會去找 /usr/local/lib/gcc/5/ 下的 lib 但是更新過後已經被變成 /usr/local/lib/gcc/6/ 了 所以只要從 /usr/local/lib/gcc/5/ 建立 soft link 到 /usr/local/lib/gcc/6/ 即可 ( 版本號則要根據自身 gcc 的版本來做修改 ) ln -s /usr/local/lib/gcc/5/ /usr/local/lib/gcc/6/ Reference R and julia won't start after upgrade (perhaps gcc 5.1, Xcode 6.3.2, or Command Line Tools 6.3)","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/06/solve-libgfortran3dylib-not-found","loc":"https://wei-lee.me/posts/tech/2016/06/solve-libgfortran3dylib-not-found"},{"title":"[Book] 最後的演講","text":"不論在工作上還是感情關係裡，就算自己居於主導地位，也絕對不能為所欲為 「就算你做在駕駛座上，也不表示你一定要輾過別人」 如果你發現自己某件事做得不好，可是卻沒有人告訴你，那可就糟了 你也許不喜歡聽到別人批評，可是你的批評者其實是在說他們仍然愛你，仍然關心你，希望你自己能夠變得更好 假動作 讓孩子去參予組織化的運動，通常不是希望他們真的精通那項運動 而是希望他們學到團隊合作、堅忍不拔、運動家精神、努力的價值，以及克服逆境的能力 阻礙我們前進的磚牆，不會無緣無故擋在我們前面。這種磚牆的存在目的不是為了把我們排除在外，而是要讓我們有機會證明自己多想要一件東西 計劃可以隨時改變，可是前提是必須先有計劃 讓團隊不必花時間再猜測對方在想什麼 「你永遠不用擔心我在想些什麼。不論好壞，我都一定會讓你知道我的想法」 「我如果沒說話，你就不必擔心」 讓別人把話說完 不要打斷別人的話。說話比較大聲或者比較快，不表示你的意見就比較好 不情不願或不真誠的道歉，通常比不道歉更糟糕，因為接受道歉的對方會覺得這種道歉是一種汙辱。草率的道歉就像是在傷口上灑鹽 典型惡例 「很抱歉我的行為讓你受傷。」( 這麼說表示你有意安輔對方的情緒，可是明顯可以看出你根本不打算彌合傷口 ) 「我為我的行為道歉，但你必須為你的行為向我道歉」( 這不叫道歉，這叫作要求對方道歉 ) 適當的道歉要有的要素 我做的事情是錯的 我對自己傷害到你感到很難過 我該怎麼做才能彌補過錯 開口問吧，不用怕。獲得肯定答案的機會，一定比你想像的還要頻繁。","tags":"Book","url":"https://wei-lee.me/posts/book/2016/06/the-last-lecture","loc":"https://wei-lee.me/posts/book/2016/06/the-last-lecture"},{"title":"[Book] 演算法統治世界","text":"演算法可以被視為由一連串二元決策構成的大型決策樹 我們所做的幾乎每件事，從開車到買賣股票乃至擇偶，都可以根據二元的輸入訊息被細分成一串二元決策 撰寫合乎常態分配的演算法比較容易，儘管歷史一再告訴世人，人類行為不能以正常視之，但一些駭客寧可只考慮常態分配 常態分配的假設可以在 100 天中賺 100 天，但是 1987 年的黑色星期五、1998 年的俄羅斯倒債危機以及 2010 年的閃電崩盤等都屬於第 101 天，可能毀了那些使用謹守高斯分配原則的演算法來做交易的人 就連高斯本人早在 200 多年前都曾警告世人，常態分配也可能發生各種強度不一的錯誤 創意工作者以為，緩緩蔓延的機器人革命碰不到他們，認為演算法無法創新，機器人不懂得創造 但我們現在漸漸知道，這些假設很危險 為何要讓優秀的人背負例行公事、詢問他這個領域的專家每天面對的案例？ 把疑難雜症留給優秀的人，把其他問題交給演算法 例如你上禮拜的感冒或者去年的鼻腔感染。演算法既便宜又精準，而且一天比一天聰明","tags":"Book","url":"https://wei-lee.me/posts/book/2016/05/automate-this-how-algorithms-came-to-rule-our-world","loc":"https://wei-lee.me/posts/book/2016/05/automate-this-how-algorithms-came-to-rule-our-world"},{"title":"[Book] 內向者的優勢","text":"與恐懼周旋 有意識地去感知恐懼 讓自己看清楚，為什麼你想做的事情是重要的，而且重要的即便心中恐懼也願意冒險 內向者經營單身生活的策略，下列是幾個值得參考的建議 每年嘗試一種新嗜好 每年兩次認識一個新地方 每兩週可以參觀一下展覽，或看看電影、舞台劇或舞蹈表演 每個月參與一場慶祝會或社交活動 藉由親自會面建立起來的人脈，動輒需要一兩年的時間，才能成為固定成員，並與他人建立穩定的互動，而且前提還是你的確很積極，掛名成員是產生不了什麼實質的互動 請在時間管理中預留固定的時段給數位人際互動。你該定期活動，盡可能每週一次以上。你可以發表文章、確認你認為合適的互動請求、讀一讀網頁上的留言，若有必要則回應一下。 這也表示：當你在進行其他活動時，不要因為一直顧著看推特的時間軸或臉書的留言而分心 當你身為會議主持人，請特別留意會場裡的內向者，他們可能需要較長的時間才願意表達意見，而且他們說起話來往往比外向的與會者小聲。設法讓這些內向者也能暢所欲言","tags":"Book","url":"https://wei-lee.me/posts/book/2016/04/leise-menschen-starke-wirkung","loc":"https://wei-lee.me/posts/book/2016/04/leise-menschen-starke-wirkung"},{"title":"[Book] 隨機騙局","text":"序：不必把知識看得那麼重 「有錢人想的跟你不一樣」點出百萬富翁跟一般人不同的一些特質 韌性和勤勞 就算所有的百萬富翁都是這樣的人，並不會使韌性跟勤勞的人變成百萬富翁 百萬富翁共同的特質可能還有冒險犯難 這是大獲成功的必要條件，也是失敗的必要條件 要是對破產公民做出相同的研究，他們肯定也是喜愛冒險犯難 前言：雲中的清真寺 所謂的「勇氣」可能是來自低估隨機性在某些事物佔有的份量 經濟「冒險者」比較像是某種錯覺的受害者，他們低估可能的不利結果，結果過度樂觀和自信 怪異的會計衡量方法 現實遠比俄羅斯輪盤惡毒 首先，它射出致命子彈的次數相當少。如果把現實比喻為左輪手槍，那麼它的彈夾能裝上千發，而不是六發。 試射了實際次都沒問題後，我們便會 產生虛假的安全感 ，忘了裡面還有一顆子彈 副現象 (epiphenomenalism): 看著你的風險，你能有效的降低風險 ? 還是你因此給自己一種感覺，覺得你已經盡了本份 ? 從組織的觀點來看，風險經理的存在，和為了實際降低風險比較沒有關係，和將低風險的印象比較有關係 用數學沈思歷史 在短暫的時間增量內，我們觀察到的是投資組合的變異性，不是報酬率。換言之，我們看到的是變異。一個人觀察到的，頂多就是變異和報酬的組合，不只是報酬 隨機性、胡說八道和科學知識份子 我們可能不需要什麼事都那麼理性和科學，只有在會傷害我們和威脅我們生存的狀況下，才需要 有趣的是，現代生活卻要我們做相反的事 談到宗教和個人行為等事物，我們變得極其實務和知性 談到由隨機性主宰的事物（e.g. 投資組合或不動產投資），卻盡可能的不用理性 最不適者生存 - 進化有可能被隨機性愚弄嗎 所謂的最適者，可能是適應了現在的這一個樣本路徑 而這種生物生存的越久不曾遇到稀有事件，他們就越脆弱 如果時間無限延長，那麼稀有事件就會發生，於是物種會滅絕 進化的意思說只是應一個時間序列，而不是適應所有可能環境的平均值 歸納的問題 下面的一段話是單純解讀過去的資料所發生的問題 我剛對布希總統的一生進行完整的統計檢視。從五十八年來，接近二萬一千次的觀察值，發現他不曾一次死掉。所以我可以宣稱他將萬壽無疆，而且統計顯著性很高 當一個人使用的策略可能包含偏態，也就是大賠的機率低，小賺的機率高，則將贏的機率極大化，不會使競賽的期望值極大化 如果你用的是俄羅斯輪盤式的策略，大賠的機率低，也就是每隔幾年才會使你破產，那麼幾乎所有樣本中，你都是贏家，除了你死掉的那年 維根斯坦的尺 除非你對尺的可靠度有信心，否則當你用尺去量桌子，你可能也同時用桌子在量尺 再談隨機性的好處 一點小小的不確定性，可以讓我們當個足夠滿意者，而不是極大滿意者 你的行為展現輕微的不可預測性，可以在發生衝突的情況保護自己 如果你一定要被罵了十七次，才在第十八次生氣，這樣的行為就很容易被操縱","tags":"Book","url":"https://wei-lee.me/posts/book/2016/04/fooled-by-randomness","loc":"https://wei-lee.me/posts/book/2016/04/fooled-by-randomness"},{"title":"External.js - Load HTML in Reveal.js","text":"reavel.js 提供了 data-markdown=\"example.md\" 這個 tag 可以載入外部的 markdown 卻沒提供可以載入 html 的 tag 於是就有人寫了這個 External.js 有了 External.js，就可以不用把所有的內容都寫在 index.html 裡面 Install Method1: Download 到 external 下載 把 extneral 裡面的 external 資料夾放到 plugin 裡面 在 index.html 中的 Reveal.initalize 這個 block 加入下面的內容 { src : 'plugin/external/external.js' , condition : function () { return !! document . querySelector ( '[data-external]' ); } }, Method2: Submodule 不過為了讓他的更新也能被追蹤，我使用了 git submodule git submodule git submodule add https://github.com/calevans/external plugin/external 在 index.html 中的 Reveal.initalize 這個 block 加入下面的內容 { src : 'plugin/external/external/external.js' , condition : function () { return !! document . querySelector ( '[data-external]' ); } }, ( 注意兩種方式加入的內容有些微的不同 ) Usage 之後就能使用 data-external 這個 tag 來載入外部的 html 原本的 index.html < section data-external = \"module_01/index.html\" > </ section > 外部 html <!-- module_01/index.html --> < h1 > This is external < h1 > 載入後的 html < section data-external = \"module_01/index.html\" > <!-- module_01/index.html --> < h1 > This is external < h1 > </ section >","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/03/external-js-load-html-in-reveal-js","loc":"https://wei-lee.me/posts/tech/2016/03/external-js-load-html-in-reveal-js"},{"title":"男子漢理論","text":"這篇文實在太有趣了，還是該留下來做個紀錄 XD 男子漢理論 真正的男子漢 programmer 是不會用那些亂七八糟，花枝招展的，所謂整合開發環境。 真正的男子漢 programmer 就是直接用 emacs, 或是 vi 這些男子漢編輯器直接寫程式。 如果你不知道這是甚麼東東，簡單來說，就是男子漢用的\"記事本\"。 當然在花枝招展，看來很娘的 Wxxxxws下要找到這些男子漢編輯器有一定難度， 但這絕對難不倒一個真正的男子漢 programmer。 另外真正的男子漢也不會用那些亂七八糟，花枝招展的所謂應用程式寫網頁。 真正的男子漢就是直接用 emacs, 或是 vi 這些男子漢編輯器直接寫 HTML， 因為那些亂七八糟，花枝招展的所謂應用程式寫出來的網頁 加了一大堆亂七八糟的 tag 根本沒有人看得懂。 真正的男子漢也不會用那些亂七八糟，花枝招展的所謂應用程式寫論文。 真正的男子漢就是直接用 emacs, 或是 vi 這些男子漢編輯器直接寫 latex。 因為那些亂七八糟，花枝招展的所謂應用程式寫出來的論文，字型醜的要命， 圖還會亂跑，換一台電腦就換一個樣子，一點也不像男子漢做出來的東西。 最後你可以看出真正的男子漢 programmer 不管做什麼事， 都只用男子漢編輯器就能搞定，這就是成為男子漢 programmer 的重點。 當然最好還是用 ed 這種神物，只是現存看過 ed 的 programmer 可能比看過\"真理\"的煉金術士還少，在此就不苛求了。 --Re: 男子漢理論,pangfeng (P老師)@pangfeng, ptt2.cc From MARK CHANG'S BLOG - About Me","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/03/article-man-theory","loc":"https://wei-lee.me/posts/tech/2016/03/article-man-theory"},{"title":"[Book] 少，但是更好","text":"Weniger aber besser 德語的 Less is more 如何成為「精‧簡‧準」的人 專準主義 (Essentialism) 者之道摒棄「我們甚麼都可以做」 而這需要費心去做出真正的取捨和艱難的決定 如果你不替自己的生活排定優先次序，別人就會為你代勞 彼得杜拉克 :「幾百年後，當以長遠的角度書寫我們這個時代的歷史時，歷史學者看見的最重要事件，很可能不是科技，不是網路，不是電子商務，而是人類形勢前所未有的改變。這是第一次─真的是史上頭一遭─有為數可觀且級數增加的人們 擁有選擇 的餘地。這是第一次，他們將不得不管理自己。而社會對此毫無準備。」 懂得取捨 「我要如何兩者兼顧 ?」 不，那是非專準主義者的想法 專準主義者會想「我想要哪一個問題」 更審慎的做出取捨 經濟學家 Thomas Sowell:「沒有解決方案。唯有取捨」 專準主義者者視取捨位生活中固有的一部份 不會問「我必須放棄什麼」 而是「我該在哪方面全力以赴」 玩樂 玩不只幫助我們，探索必要的事物。它本身就是不可或缺的事。 睡眠 如果對自己投資得不夠，這裡指的是我們的身心靈，我們便會損害用來做出最高貢獻的必備工具 非專準主義者 專準主義者 少睡一小時等於多了一個小時的生產力 多睡一個小時等於多了更有生產力的幾小時 睡眠是奢侈品 睡眠是優先事項 睡眠滋生懶惰 睡眠孕育創造力 睡眠讓你無法「全部都做」 睡眠能使新制做出最高程度的貢獻 嚴選 No more yes. It's Either HELL YEAH! Or No 如果答案不是明確的好，那它就應該是不 釐清 普通 具體 鼓舞人心 願景 / 使命 必要意圖 ( 只做出一個決定 ) 平凡無奇 價值 季目標 問「我們怎麼知道自己做到了 ?」 e.g. 「消除世間的飢餓」 ⇔ 「位住在低久區的家庭打造一百五十間經濟實惠、環保，又能抵抗暴風的住家」(Make It Right) 後者回答了「我們怎麼之道自己成功了」，而他也成功鼓舞人心 取消承諾 沉沒成本偏誤 對已知虧本的生亦持續投入時間、金錢或精力的傾向 避免沉沒成本偏誤 假設你還沒擁有它 「如果我不是已經在這個專案投入這麼多，我現在會投入多少 ?」 「如果我現在種指這個專案，這些時間金錢還能用來做甚麼 ?」 「如果我沒有這樣東西，我願意付多少錢買它 ?」 「如果我沒有這個機會，我願意為了得到它，做出多少犧牲 ?」 不介意停損 界限 不推辭的成本往往更高，它會使我們在選擇生命中最重要的事情上變得無能為力 找出那些你不該接受的絆腳石 只要你覺得被某人的要求侵犯或欺騙 它不見得會以某種極端的方式被你注意到。即使那只有一點惱怒，都是發現自己隱含界線的線索 進展 當我們從小地方著手並獎勵進展時，最後所達到的成就，將比訂下偉大、崇高卻往往遙不可及的目標時更大 更棒的是，積極強化自身成孤的舉懂，能使從這個過程獲得更多的樂趣和滿足 心流 習慣的力量 ( 可以參考 「為什麼我們這樣生活，那樣工作」 )","tags":"Book","url":"https://wei-lee.me/posts/book/2016/03/essentialism","loc":"https://wei-lee.me/posts/book/2016/03/essentialism"},{"title":"Reveal.js 安裝錯誤","text":"當我安裝步驟執行到 npm install 會跳出很多錯誤訊息 這才發現 Reveal.js 要用 python >= 2.5 and < 3.0.0 而我預設的 python 是 python3.5 所以只要像下面的指令把 python 指到 python2 就可以了 npm install --python = python2.7 --python= 後面是 python2 的執行擋，需要根據自己的設定做調整 Reference Reveal.js","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/02/reveal-s-installation-error","loc":"https://wei-lee.me/posts/tech/2016/02/reveal-s-installation-error"},{"title":"解決安裝 IRKernel 缺少 zmq.h","text":"安裝 IRKernel 進入 R 的命令列，輸入下面的指令 就能安裝 IRKernel，以後就能在 jupyter 中使用 R install.packages(c('rzmq','repr','IRkernel','IRdisplay'), repos = c('http://irkernel.github.io/', getOption('repos'))) IRkernel::installspec() 錯誤訊息 interface.cpp:22:10: fatal error: 'zmq.h' file not found #include <zmq.h> &#94; 1 error generated. make: *** [interface.o] Error 1 ERROR: compilation failed for package 'rzmq' 解決 這時候就要將缺少的套件補齊 brew install czmq zmq 再執行一次最上面的安裝指令 接著在指令列執行輸入下面的指令 jupyter qtconsole --kernel = ir jupyter console --kernel = ir 安裝成功後就可以看到 Reference Failed to install rzmq #50 IRkernel","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/02/resolve-irkernel-missing-zmqh","loc":"https://wei-lee.me/posts/tech/2016/02/resolve-irkernel-missing-zmqh"},{"title":"[Book] 蘋果橘子經濟學","text":"誘因 誘因 促使人多做好事、少做壞事的手段 多數誘因並非自然發生，而是由某些人（e.g. 經濟學者、政治人物或父母）所發明設計 這樣的誘因主要分為經濟、社會與道德，不過單一誘因通常三者兼備 托兒所常有家長遲到接小孩的問題。如果我們提出遲到十分鐘以上的人要罰三美元，結果會如何呢？ 遲到的人竟然大幅增加了！ 因為這是用經濟誘因（三美元）取代道德誘因（愧疚感），而低額的罰款似乎也在告訴家長這不是一件很嚴重的事 然而很有趣的是，之後取消了罰款制度，遲到的人數並未因此減少 因為他們遲到不用罰款，也不再覺得於心不安 如果捐血可以得到一些錢，是否會增加捐血的人數呢？ 肯定會的 那是要增加到 50 元、500 元或甚至 5000 元呢？ 然而也會讓有些事情變得不同，每項誘因都有黑暗的一面 如果 500cc 的血值 5000 元，可能會有人偷採別人的血，或用豬血混充 不論誘因如何，總會有不誠實的人想盡各種辦法來謀取利益 這樣的欺騙是一種本能的經濟行為：以更少的代價來獲得更多 資訊 在很多狀況下，與專家面對面接觸可能使資訊不對稱更為嚴重 —— 專家更可以利用資運優勢讓你覺得自己愚蠢無知 就算資訊不真正的存在，只要別人認定你擁有資訊，這樣的假定就能有很大的影響力 資訊犯罪的特點之一就是犯行曝光者很少。資訊犯罪會浮上檯面，必然是因為發生重大事件 專家透過資訊讓人們害怕就能產生很巨大的操控力 因果關係 美國殺人案比率偏高，部分要歸咎於槍枝取得太容易。研究結果的確也支持這樣的說法 不過槍枝並非唯一的原因 以瑞士為例，政府發給每名成年男子一把步槍作為民兵服役用，而且可以存放家中 瑞士擁有了相當高的武器持有率，卻被認為幾乎是最安全的地方 我們習慣把因果關係連結到周遭可以實際接觸戶感受的事物上，而不是遙遠或不易理解的狀況 我們尤其相信短期的因果關係，你的朋友被蛇咬了一口，之後死了 我們會推論蛇咬是他的死因 這種推論大多數時候是正確的 然而談到因果關係，這種簡單直接的思考往往存有陷阱 就算兩件事相關，也不一定有因果關係。只代表他們之間存在某種關係 假設這兩件事是 X, Y，可能Ｘ導致Ｙ，也可能Ｙ導致Ｘ，甚至是另一個因素Ｚ同時影響Ｘ、Ｙ - 回歸分析所能顯示的是相關性，但無法證明因果性","tags":"Book","url":"https://wei-lee.me/posts/book/2016/02/freakonomics","loc":"https://wei-lee.me/posts/book/2016/02/freakonomics"},{"title":"[Book] 每天最重要的兩小時","text":"在日常事務中辨識每個決定點 遇到決定點（一個事件結束或被打斷的時候）的時候，花五分鐘的思考再進行下一件事 看似浪費了這五分鐘，實際上卻是有意識的決定該做的事，讓接下來時間運用得更有效率 如果總以「效率」為理由，略過這些決定點，隨便找一件事做，最後會落入事情做不完的迴圈，而做的那些事很可能都不是最重要或最適合的，這樣想想反而損失了更多的時間 我們常常面對了很多「緊急」的事，然後那些「重要，但不急迫」的事往後放，漸漸的我們就會忘記處理這些真正重要的事，最後這些事情就變得「重要且急迫」 利用決定點的秘訣 珍惜決定點 事先計劃在決定點要做的事 在沒意識決定接下來該做的事前，別急著做下件事 計劃「不要做 ...」通常會不成功，應該要計畫「如果 ... 就 ...」 前者是抑制衝動，後者是實際選擇採取的行動 管理你的心智能量，善用好情緒跟壞情緒 做決定會導致心智疲倦，即使不是很大的決定 負面情緒 生氣： 當你知道某件事是對的，卻因為害怕風險而不做，這時候激將法就是很有用的 悲傷： 悲傷讓我們比較公平不自私，傾向慎重，也會努力讓自己傳遞的訊息有說服力 焦慮： 焦慮讓我們高度警覺、隨時能做出反應 當然這些不是在鼓勵負面情緒，而是提出在特定情況下，負面情緒也可能有用 正面情緒 好心情有助於創意、迅速做出決定 主動讓自己進入正面情緒 放鬆看幾分鐘的書 做點運動 回想開心的事 減輕心智疲勞 學會辨識那些最可能顯著消耗心智能量的事物 從事重要的工作前，避免去做那些消耗心智能量的事 那麼該如何判斷的？ 如果這件事做完後會感到疲倦，那在某種程度上都已經使用到自制力 實際上我們不可能完全避開消耗心智的事，也不實際 我們不是機器，不用隨時都表現得很好 與其讓自己時時刻刻表現傑出，應該策略性的選擇待辦事項的執行順序 在大腦不疲憊的時候，創造出最高效率的時段，最優異的完成重要的事物 下列四點是減輕心智疲勞的策略 早上優先完成最重要的工作，避免腦力被小決定消耗 這裡指的優先，指的是第一件事，而且是在檢查任何訊息或查看任何媒體前 區分待辦事項，「重要」、「創意」、「雜項」 將雜項安排在心智力最弱的時候 偶爾試著只在下午花一個小時看郵件和回郵件 在非常重要或忙碌的工作日前一晚，先做出一些決定 如果心智已經十分疲勞了，下列三點可以讓你恢復精神 緩慢地深呼吸 設法讓自己大笑 小睡十分鐘，研究指出十分鐘可以回復人體的認知功能，大約可維持兩小時半 好好選擇在何時有巔峰表現，並且大方做出其他犧牲 為了好好善用心智能量，應該把少數的事做到優異，而不是企圖做完所有的事 調整對抗分心的方法，學會放自己一馬 靜坐，有助於鍛鍊專注力 沒關係就讓大腦分心吧 人類的注意力系統天生就會刷新，以對抗臨時產生的事件 但別讓思緒回不來 下列不會造成認知能力的沈重負擔，都是分心時可以試試的 欣賞景色 簡單收拾桌面 聽聽音樂 而避免做以下的事，因為他們會讓你心智疲勞 歸檔文件 閱讀新聞、動態 回覆電子郵件 做有難度的解謎，如填字遊戲或數學遊戲 如果想長時間持續做一件事，不要盲目地對抗分心，但也別盲目的屈服 當你的心思漫遊時，它只是需要一分鐘做一些其他事，想要提神或更新資訊，讓它去吧 但不要轉換去做別的事務 掌握運動和飲料的訣竅，你就能表現得出色 曼德拉：「我發現，在身體狀況良好的情況下，我可以把工作做得更好、思考更清楚。因此，鍛鍊身體變成我生活中必不可少的紀律之一」 做完溫和的運動後，能有效提升正面情緒 然而如果是較劇烈或長時間的運動，這方面的效果反而沒有那麼大 那麼何謂「適量」? 20~30 分鐘的高強度運動（呼吸有點喘、流了很多汗） 30~40 分鐘的中等強度運動（稍微出汗，但離極限還有一段距離） 運動就像是重設鈕，是改善心智表現有效且快速的策略 當感到精神不濟、無法專注，出去辦公室走一走 在令人感到焦慮的會議前，適量運動 當天有特別消耗心力的事務時，當天早上做點運動 當你在必須處於最佳狀態，而又一、兩小時沒喝水，趕快去喝點水吧，不要低估一杯水在保持心智活力的效用 咖啡因 攝取咖啡因的同時，最好再加上一點其他食物 如果只是黑咖啡，只會在半小時後提振精神，之後可能會令你感到更疲倦，甚至提高敵意 如果混著其他東西，能使咖啡因的正面作用持續更久（只加糖也不夠） 多少咖啡因含量才有提振生產力的效益呢？ 自己嘗試吧，因人而異 「所有的東西都是毒物，沒有東西是無毒的。唯有適當的劑量能使一項東西變成不是毒物」 咖啡因要三十分鐘後才會產生效果，在此之前請不要再喝，否則再感受到它的助益前，會先感受到它導致的焦慮 即使在你很累的時候，也只應該攝取正常的量 如果咖啡因沒辦法提升你的注意力，喝再多可能也沒用，請考慮小睡一下 噪音、光線、雜物？自己動手打造最有益的工作環境 安靜是最有助益的工作環境 聽音樂雖然能產生正面情緒，但在也會降低專注力上 桌邊的雜亂會影響專注力 因為桌上的那些東西都會使你分心 總結 看完這本書後，不要再想盡辦法擠出更多時間工作，而是試著去調整作法，讓自己每天都能有穩定高工作成效的時段，留一點時間來品味生活","tags":"Book","url":"https://wei-lee.me/posts/book/2016/01/two-awesome-hours","loc":"https://wei-lee.me/posts/book/2016/01/two-awesome-hours"},{"title":"在 mac 上安裝 gcc","text":"最近用 brew 來安裝 gcc 5.3，一直卡在 make --bootstrap 放了幾個小時還是停在這 之後才查到，要用 xcode 的命令來安裝 xcode-select --install 主要是因為 homebrew 下載的是還沒 compile 過的版本 而 compile gcc 需要非常長的時間 根據 Reference 中的文章，至少要超過 45 分鐘 ( 雖然我放了一天還是沒好 ) Reference brew install gcc too time consuming brew install gcc /Mac OS 10.9 Mavericks","tags":"Tech","url":"https://wei-lee.me/posts/tech/2016/01/install-gcc-on-mac","loc":"https://wei-lee.me/posts/tech/2016/01/install-gcc-on-mac"},{"title":"[Book] IDEA 物語","text":"創新始於雙眼 跳脫慣有的節奏，到國外旅行、新運動、體驗新活動，創新就是從這些地方開始的 不管藝術、科學或商業，靈感通常來自 親身體驗 即使是網路時代，地理位置依然重要 這就是為什麼高科技發源地是矽谷不是康乃狄克州 「當個左撇子」哲學： 我們應該關懷消費者的需要，即使是習慣不同於一般人的消費者 完美的動腦會議 動腦會議 60~90 分鐘就綽綽有餘，不要耗掉一整個早上或下午 不用簡報 不用覺得像是工作 扼殺動腦會議的六大計畫 老闆率先發言 輪流發言 專家至上 異地開會 不准有蠢點子 勤做筆記 活力團隊創造優質企業 Francis Jehl: 「愛迪生實際上是眾人之力的集合詞」 孤獨天才的傳說是阻礙公司創新與創造力的絆腳石 Boston Phiharmonic 的指揮 Benjamin Zander 在上課的第一天告訴學生，每個人的成績都會是Ａ，唯一的條件只有，他們必須在學期中告訴他自己憑什麼得Ａ 建立學生信心 學生為了得到Ａ努力 比傳統由老師評分給Ａ，學生為了得到自己心中的Ａ付出更多的努力 每個人都應該有表演的機會，每個人的立足點是平等的，然後接受各種挫折的機會 IDEO 通常會讓新人在新專案中擔任吃重的角色，甚至負責整個專案 原型製造是創新的捷徑 使用自動提款機時，如果有人在旁邊常會令我們感到不自在甚至害怕 所以當 IDEO 接到這個銀行專案時，先觀察消費者使用自動提款機的行為，然後腦力激盪各種可能的方案，包括昂貴的攝影機 結果發現，只要在自動提款機上頭裝上一個 1.8 美元的魚眼睛，就有良好的效果 當然，也可以找出更高科技、更貴的解決方法 但製作原型後能提醒你，有時候最簡單、便宜的方式往往也是最有效的方案 跨越障礙 海洋和文化差異都是難以改變的巨大障礙，手機這類高科技消費性產品，之所以能大舉入侵各種不同文化並不令人意外，因為大家對手機沒有歷史的情節或傳統的包袱 然而，像家具或廚具這類有悠久傳統的產品，便問題重重。 除了用起來好用以外，還要看起來好用 真正優良的設計來自和人們的接觸 人們對改變的容忍程度沒有一個準。但如果你執意要改變一種大家鍾愛的儀式，那將會吃力不討好 易碎的軟酒瓶塞就是個好例子，因為每個人都認為高級酒要用好的軟木塞，即時這絕對不是保持好酒品質最好的方法 不能忽略傳統到創新之間的橋樑，否則消費者會不知道這是什麼產品 即使是一項史無前例的重大創新，還是得具備傳教士的銷售精神 產品的價值固然重要，但真正對潛在客戶和消費者銷售的，還有設計過的使用經驗","tags":"Book","url":"https://wei-lee.me/posts/book/2016/01/the-art-of-innovation","loc":"https://wei-lee.me/posts/book/2016/01/the-art-of-innovation"},{"title":"[Book] 行銷前必修的購物心理學","text":"定錨 (anchoring) Steve Jobs 在推出 iPad 的時候說「我們應該給他設定何種價格？如果你聽信自以為聰明的人，我們會把它的價格訂在 1000 美元以下」 螢幕出現了 999，然後「我很高興地向大家宣佈，iPad 的起價不是 999 美元，而是只要 499 美元」 這麼做降低了知覺成本，因為已經被一開始的 999 給定錨了。第二次的價格就會被拿來跟第一次的錨比較 另外，他沒有拿來跟筆電比較，維護了產品的獨特性，也不減少筆電的行銷 「價值 - 成本」是相對的 下面三種，哪種會最多人訂閱？ 電子版 59.00 美元 紙本 125.00 美元 紙本 + 電子版 125.00 美元 答案是「紙本 + 電子報」，紙本則不被考慮 那下面兩種呢？ 電子版 59.00 美元 紙本 + 電子版 125.00 美元 只訂電子版的大大的增加了 看似沒用的「紙本」選項，實際上很有用，影響了「價值 - 成本」關係的計算 我們必須凸顯出人們正在尋找的那個價值，而且這個價值必須要能讓系統一偵測和知覺到 購買決策： 「淨值 ＝ 報償 - 痛苦」，淨值越高帶來越大的購買 如何提升淨值？ 價值 ( 報償 ) 外顯價值 內隱價值 成本 ( 痛苦 ) 外顯成本 ( 財務 ) 內隱成本 ( 行為 ) 知覺流暢性 如果健身房要你每年付 600 英鎊年費或每月付 50 英鎊，哪個容易讓你頻繁地去健身房？ 答案是 50 英鎊的月費 為每次付費後都會特別有感覺。費用就會變得具體 「有巧克力的健康天然食品」和「內含天然成分的巧克力」，哪個比較受歡迎呢？ 「內含天然成分的巧克力」 消費者買巧克力可不是想獲取健康養分，要先滿足消費者的基本目標 - 大快朵頤 Just Noticeable Difference （恰辨差） 750 萬畫素的照相功能才能給消費者帶來有差別的感受","tags":"Book","url":"https://wei-lee.me/posts/book/2016/01/decoded","loc":"https://wei-lee.me/posts/book/2016/01/decoded"},{"title":"[Book] 為什麼我們這樣生活，那樣工作 ?","text":"Wiliam James: 「我們這輩子所做所為均已定型，一切不過是習慣的總和」 我們看似的深思熟慮，其實常常都只是因為習慣 2006 年杜克大學的論文提出，人們每天的活動中，40% 是習慣使然，而非決定 習慣：刻意或深思後而做了選擇，過了一段時間後，不經思考卻依然繼續、往往每天在做的行為。 e.g., 早餐吃什麼？ 什麼時候去跑步？ 大腦的渴求 如何養成新的習慣 找出簡單又醒目的提示訊號 清楚界定獎籌內容 examples 白速得牙膏 牙齒上的黏斑 一口白牙 慢跑習慣 下班 無罪惡感地放鬆休息 養成新的習慣 習慣養成的四個步驟 提示 慣性行為 （習慣） 獎籌 創造渴望 電腦或手機的提示音響起 (1)， 習慣打開訊息 (2)， 以便自己可以有短暫的分心 (3) 如果這份期待跟渴望沒被滿足，就會讓人充滿焦躁不安 (4) 其實這些訊息可能根本無關緊要 所以可以關掉手機或 Do Not Disturb 關閉提示訊號，來專心工作了 如果想養成每天晨跑的習慣 簡單的提示 (e.g., 早餐前綁好鞋帶、把慢跑鞋擺在床邊) 清楚的獎籌 (e.g., 中午大吃一頓、記錄慢跑里程的成就感、腦內啡的分泌) 必須要讓大腦對獎籌有期待才有辦法養成習慣 (e.g., 渴望這份成就感或腦內啡) 渴望的養成 渴望是建立全新慣性模式很重要的一環 想建立新的飲食習慣嗎？ 成功節食的人通常有吃早餐的習慣 成功減重的人另外會預設獎籌，告訴自己只要嚴守節食計畫就能得到獎籌 獎籌必須經過仔細挑選，所以誘惑或讓人分心的事出現時，才能不為所動，專注於對獎籌的渴望 扭轉習慣的黃金律 沿用相同的提示訊號和獎籌，加入新的慣性行為 改變舊習，和培養新習慣不同 → 必須同時顧及根深柢固的舊渴望 只要察覺習慣的運作方式，以及清楚知道提示訊息和獎籌是什麼，就成功一半了 (反轉訓練) example 假設你想戒掉上班吃點心的習慣 你是為了什麼吃點心？ 為了消除飢餓？ 為了擺脫無聊？ 或只是短暫放鬆 ? 如果只是短暫放鬆，上網三分鐘、散個步都是可以達到的目的，但不會變胖 相信 你必須相信改變是會成真的 戒酒無名會就是仰賴團體的力量，讓個體學習相信 而在團體中，人比較容易去相信 總結 想改變習慣，要 找到替代舊習慣的行為模式 如果能的話，加入某個互助團體，跟著大家一起努力改掉舊習，成功的機率會大增 必須相信人可以改變 ： 而相信得靠他人幫忙，即使只是兩人的團體也沒關係 星巴克讓人成功的習慣 意志力不是一種技能，比較像是一種肌肉，用得越多就會越累，所以還要用在其他事情上面的時候就會剩下比較少 意志力是可以訓練的 這就是為什麼讓孩子上鋼琴課或參加運動是重要的，不是一定要培養這些技能，而是強迫練習和運動的過程，增加自我規範的力量 星巴克的員工手冊詳細地寫出員工遇到困難時應該採取什麼樣的措施 提供員工意志力的 習慣迴路 ，讓他們知道如何處理不愉快的情況 危機就是轉機 危機是非常珍貴的契機，有智慧的領導者通常會故意延長危機感，讓大家正視問題 連鎖零售商搶先知道你要什麼 以推銷新歌的例子 (兩首舊歌中間夾一首新歌) 如果你能 用舊習慣包裝新東西 ，就能讓大眾比較接受新東西。 蒙哥馬利公車抵制事件 格蘭若維特發現如果 要找到工作，弱連結的點頭之交時常比強連結的朋友更為重要 ，因為弱連結可以讓我們進入我們不屬於的社交網路 我們隨時都在跟親密的朋友相處，他們聽到新的機會時，我們大概也已經知道 另一方面，弱連結則可以告訴我們，我們原本不知道的 自由意志的神經學 習慣是讓我們能「第一次做一件困難的事，但很快那件事就會越來越簡單，最後有了充分的練習後，就可以半機械式地做下去，或是幾乎不需要任何的意識」 人們會朝他們練習的方式前進，就像一張紙，一旦被摺過，之後就容易折成相同的摺 附錄：習慣改造指南 方法架構 認出慣性行為 做實驗找出獎勵 那些造成習慣的渴望 用不同的行為來測試自己是否有滿足了 如果做完這件事，還是想重複原本的習慣，代表這個不是獎勵 篩選提示 事先選好要檢查哪種行為類別，可以歸為下列五大類 地點 時間 情緒狀態 其他人 緊接在前的行為 訂定計畫","tags":"Book","url":"https://wei-lee.me/posts/book/2015/11/the-power-of-habit","loc":"https://wei-lee.me/posts/book/2015/11/the-power-of-habit"},{"title":"[Book] 為什麼他接的案子比我多","text":"隨時趕在對方需要以前，讓他們大吃一驚 上司要求下午三點要東西，兩點就備妥 設計師要期待任何批評跟忠告的場合，能把你推到更高層次的意見是重要的 跟同事抱怨，除了放大問題外，沒有任何作用，往上呈報，有助於產生正向的轉機 搶救雷恩大兵 「跟上頭抱怨，不是跟手下」 開會應有的準備 準備好寫筆記 先看過題材，在腦中溫習主題 寫下幾個好問題，鼓起發問的勇氣 為了避免最後變成「一案各表」，可以先界定好這些規格 尺寸 構想 特色 功能 包含的內容 排除的內容 可修改次數 專案持續時間 腦力激盪的點子有九成的淘汰率，但為了那一成的好點子，我們仍然要去思考更多的點子 不管甚麼情況，隨即回復收到的 e-mail，是個好習慣 收到信了，謝謝 謝謝您的詢問，我目前無法回答，在像某人詢問後，在某時給您答覆 完成了 謝謝，您的回覆我們很受用 善意的告知進度，尤其在各階段時間拉得很長的時候 想像手術室的家屬，如果沒有護士告知進度會有多焦急 絕對不能讓客戶空等 如果趕不上，一定要事先告知 讓客戶空等，會急遽減低客戶對你的信賴 在有時差的地方，交件日期會受到時區影響 最好的方式是在當天早上，甚至前一天就交件 弄懂你的客戶關係圖，並且確保這些人滿意度很高，這些人脈變成金流的機會相當的高 不要使用帶有負面觀感的用詞，別用導致狀況升溫的用字遣詞 病人的狀況普普，還有許多需要即刻處置的地方 → 病人的狀況尚佳，有些地方需要積極的調整 修改 → 微調 or 修正 趕緊 → 積極處理 問題 → 要素 料想到顧客的需求，預先執行你的計畫，往往好過於問客戶笨問題 當你察覺到客戶花了一個鐘頭在談話，聲音有點沙啞，不要問要不要喝水，而是找個機會插話 :「你等一下，我去拿杯水」 撰寫提案時，絕對不能出現「等等」或「及其他等等」 詳細、清楚的界定各部份的細節 正常的合約應該兼顧雙方的利益。如果有一份奇怪的條款，別傻傻的簽下去，去問律師。放掉客戶往往比簽下不平等的條款好 不要過度假設客戶甚麼都知道，為「狀況外」的客戶提供指示和教學 e.g. 「期待收到您度商標樣搞的回饋意見」 → 「為了讓商標設計盡善盡美，請提供下列回饋意見。您喜歡的商標跟理由 ? 您不喜歡的商標跟理由 ? 哪個配色跟搭配最接近您的期望？您想不想混合、搭配不同商標上面的元素」 讓數字幫你說明 碰到不合理的要求，試著用數字算清楚，說明哪裡是不可行的，說不定一場火爆場面就化解了 訂好自己的「義工」守則 回饋社會 充實作品 一次一件： 不要讓自己身上扛太多免費案子 界定範圍： 作超過多少就超出免費範圍，是需要收費的 收成本價 不會只是「見面聊聊」 每次開會，你都應該準備好，做一場驚人的簡報 天有不測風雲，每天都要備份 !!! 創業的人會在工作上更有「彈性」，但肯定是不會更「自由」的 不管如何都別做尚未白紙黑字的工作，千萬不要！一定要先確認要做的是甚麼！ 替人幹活沒有白紙黑字，就像是在做善事 下一個籌錢日 銀行現金 + 應收款 + 當月剩餘請款 + 次月剩餘請款 * 稅金 ( 季稅金預留 ) * 救急金 = 現金流量 現金流量 / 每月經常開支 = 現金流量覆蓋月數 現金流量覆蓋月數 - 1 個月 = 下一個籌錢日 成功的全職接案者，在某些時間點，必須放手一搏雇用人手，來處理一些不必親自處理的簡單事務","tags":"Book","url":"https://wei-lee.me/posts/book/2015/11/burn-your-portfolio-stuff-they-don-t-teach-you-in-design-school-but-should","loc":"https://wei-lee.me/posts/book/2015/11/burn-your-portfolio-stuff-they-don-t-teach-you-in-design-school-but-should"},{"title":"在 jupyter 中同時使用 Python2 Python3","text":"先安裝 Python2 和 Python3 的 ipython notebook pip2 install ipython notebook pip3 install ipython notebook 分別用各自的 ipython 執行下面的指令 ipython2 kernelspec install-self ipython3 kernelspec install-self 就能在 ipython notebook 裡面同時使用兩種版本的 Python 了 Python2 上面是另一個也被 jupyter notebook 支援的語言 julia 最近才剛開始碰，有機會再來分享 julia 的心得 Reference Using both Python 2.x and Python 3.x in IPython Notebook","tags":"Tech","url":"https://wei-lee.me/posts/tech/2015/11/used-in-the-jupyter-python2-python3","loc":"https://wei-lee.me/posts/tech/2015/11/used-in-the-jupyter-python2-python3"},{"title":"No More Zero Day","text":"決定開始來寫些程式以外的內容 整理之前看過的書或文章，跟大家分享心得或書摘 反正都寫了，不分享一下也是蠻可惜的 (?) [分享] 走出零產出低潮:nonzero days 這是在 PTT 上看到一篇還不錯的文章 原作者還做了這麼一張圖激勵大家 1. 從今天開始不再有「零成就日」 零成就日 一整天什麼事情都沒做的日子 一整天都沒有任何對於你的目標而努力的日子 今天一整天啥都沒做，而現在已經是 23:58 了？ 寫一個句子。做一下伏地挺身。讀完課本一章節的其中一頁。 每天只要這樣做下去就有很大的差別 生產力來自於持續每天都維持在「非零狀態」 2. 對三個「我」心存感激 過去我、現在我、未來我 對「過去我」所做過任何正面的事情心存感激 昨天不是「零成就日」因為你寫了兩百（不過，這是你最大的能力了嗎？）字？謝謝過去的自己。存了一點錢而可以買你想要的好東西？謝謝過去的自己。 把「未來我」當作你最好的朋友，現在做任何事都要像是為你最好的朋友付出一樣拼命 你必須幫「未來我」一個忙，就像幫你最好的朋友一個忙一樣 累得要死但還是無法放下網路和電玩嗎？去你的，「現在我」，我現在要替「未來我」做點事了。 鬧鐘響了但是床太舒服？去你的，「現在我」，我現在要替我最好的朋友「未來我」做點事了，我要起來跑個 5 公里（或是 25 尺，無所謂，只要不是 0 就好）。 你現在能過的一點好生活都源自於過去的努力。這樣子「努力」和「感謝」的循環模式就是讓你維持生產力和感恩之心的源頭 3. 原諒自己 責備自己只會讓你更沒有生產力。 昨天試著想避免「零成就日」卻失敗了嗎？那又怎樣！ 過去的自己。我原諒你！ 但是今天呢？今天是要盡你最大的能力發揮「非零成就日」的威力 4. 書和運動 每天持續運動真的會讓你更聰明。當你運動時身體會釋放讓你快樂的物質 至於書？所有我們能想得到的想法，或是感受、經驗、體驗、欲望、或是想知道怎麼做某件事，不管是什麼東西，都已經被某個人想出來了 讀網路上關於減重的文章並將他納入你的運動準則中 閱讀就像是瑪莉歐電玩中的水管快速通道，他是你到達下一個層級的快速捷徑。","tags":"Gossiping","url":"https://wei-lee.me/posts/gossiping/2015/10/no-more-zero-day","loc":"https://wei-lee.me/posts/gossiping/2015/10/no-more-zero-day"},{"title":"[Book] 思考的技術","text":"解決問題不能只是把問題倒過來，就當作想到辦法了 e.g.「商品沒競爭力，所以要加強商品競爭力」 該如何增加商品競爭力才是重點！ 測試知識不再能判斷一個人是否能勝任工作，要測驗的是思考模式 得到正確答案也不見得該錄取，應該注重推理過程 先說前提，才說對策 e.g. 「如果明天要你去坦桑尼雅出差？只能帶一個背包，你會帶什麼？」 「我並不清楚坦桑尼雅在哪，但是如果以這是一個非洲的國家為前提，來回答這個問題的話 ......」 具備「有前提就有結論」的思考模式的人，不容易陷入恐慌 就算前提變了，還是能導出不同的結論，這就是麥肯錫需要的人才 投資自己最糟糕的就是半途而廢 會一點鋼琴、會一點小提琴，但卻都無法在他人面前演奏 能否突破的差別在於，遇到沒遇過的經驗時，是逃避選擇旁路，還是「不管如何先踏入再說，說不定會有些什麼」 Unlearn，或者「歸零」，這是很困難的，對於成績好的人尤其困難 抱持著謙遜的態度，重新學習，就像自己才剛上小學一樣，才能在這個時代生存 練習題 拿出去年的記事本，試著分析時間 除了睡覺以及吃飯的時間，統計一下你花了多少的時間在通勤及工作上 然後想想 「預定表上空白的時間，佔了多少醒著的時間？」 「在這些空白的時間裡，你做了什麼？」 「在接下來的一年裡，你還會用同樣的方法，運用你的時間嗎？」 為自己預算下一年的時間要怎麼分配，並研擬為自我投資計畫 試著在大腦裡描繪一年後自己的模樣 讀完每天的報紙後，提出五個疑問 接著提出自己可以運用怎樣的方式、進行怎樣的調查，是否可以提出完成度更高的報導內容","tags":"Book","url":"https://wei-lee.me/posts/book/2015/10/thinking-technique","loc":"https://wei-lee.me/posts/book/2015/10/thinking-technique"},{"title":"[Book] 創新是一種態度","text":"想解決問題，先突破框架 講師在安排課程的時候 第一種是講聽眾想聽的 更好的做法是講出那些聽眾需要的 給魚不如給釣竿 ? 那教他釣竿怎麼做呢 ? 或者教他甚麼是釣竿的原理 ? (bachelor) 為什麼一定要用釣竿 ? (master) 為什麼一定要吃魚 ? (doctor) PHD (Doctor of Philosophy) 博士要有自己的哲學和思想理念 不能只是把別人的東西做得很好 隱含假設 : 控制你思考方向的寄生蟲 「1+1=?」 「2」 ? 在自然數的系統下也許是 在 Computer Science 的布林邏輯運算則是 1 如果沒把隱含假設搞清楚的話，答案就不會是正確的，很容易變成雞同鴨講 上下文、環境關係與現實限制 上下文很重要 !!! 再看一段文章時，不用專牛角尖。先記下來，再繼續看下去，也許就懂了 漸進式創新 : 點子是可以偷來的 「先求有，再求好」反而可能變成「先求惡名昭彰，再來就沒下文了」 「人才是企業資產」不是口號 誰闖了禍不重要，重要的是誰能解決問題，更重要的是防止問題再發生 「誰的錯」 → 「我們的制度有甚麼問題」 曾有一個故事，IBM 一個經理人犯了重大錯誤，賠了公司兩百萬美金，他慚愧的像老闆辭職。老闆拍桌大罵 :「你這個人做事怎麼這麼沒責任感」還沒等他開口說自己是辭職以示負責，老闆就說「我們才花了兩百萬幫你上了一課，你現在就想跑」 機會成本，才是公司最大的成本 為了省辦公成本，去做限制，卻剝奪了員工可能產出公司營收的創新想法，這才是最浪費成本的事 台達電不會因為公司業務少了就砍人，而這麼作是為了在未來景氣回升的時候，能有更大的產能，擴大市占率","tags":"Book","url":"https://wei-lee.me/posts/book/2015/10/innovation-is-an-attitude","loc":"https://wei-lee.me/posts/book/2015/10/innovation-is-an-attitude"},{"title":"解決 django-admin 在 mac 找不到 django.core","text":"問題 在 mac 上，用 pip3 安裝完 django 1.8.1 後 執行 django-admin 出現了以下的錯誤訊息 Traceback (most recent call last): File \"/usr/local/bin/django-admin\", line 2, in <module> from django.core import management ImportError: No module named django.core 解決 找到 /usr/local/lib/python3.4/site-packages/django/bin/django-admin.py 把第一行的 #!/usr/bin/env python 改成 Python 的路徑 以我為例，我改成 #!/usr/local/bin/python3.4 之後就可以執行了","tags":"Tech","url":"https://wei-lee.me/posts/tech/2015/05/solve-django-admin-cant-find-the-djangocore-on-mac","loc":"https://wei-lee.me/posts/tech/2015/05/solve-django-admin-cant-find-the-djangocore-on-mac"},{"title":"rename - 批次更改檔名","text":"只是要改變一兩個檔案的檔名，只要 mv 就很夠用了 但如果要一次改很多相似的檔名就用到 rename 指令就會更有效率 安裝 Ubuntu, Linux Mint 預設就已經安裝好了 Mac brew install rename 使用 rename s/pattern1/pattern2/ files 把 files 中的檔案符合 pattern1 替代成 pattern2 files 要使用萬用字元，pattern 則是使用 regular expression 在改檔名之前，會想先看會改成什麼樣子 這時候就要加上參數 -n 需要特別注意要跳脫的字元 可以參考下面這篇文章整理需要跳脫的保留字 [Regular Expression] 使用正規表達時需要 escape 的保留字 保留原本檔名的片段 而在批量更改檔名時，常常會需要保留 pattern1 的某些片段 這就需要用到 regular expression 的 group 例如，我們希望把檔名從 01~05 這五個檔案改成 01A~05A 我們如果只用 rename -n s/\\[0-\\9]{2}/\\[0-9\\]{2}A/ * 就會錯誤 必須要改成像下面這樣 rename -n s/ \\(\\[ 0 - \\9 ]{ 2 } \\) / \\$ 1A/ * 扣除跳脫用的 \\ 這個例子在 [0-9]{2} 外面加上 () ，將他們視為群組 在 pattern2 用 $1 ，代替第一個 group Reference ubuntu linux 用 rename 指令批次改檔名 regular expression - Substitute text with sed and keep part of the original text - Unix & Linux Stack Exchange","tags":"Tech","url":"https://wei-lee.me/posts/tech/2015/02/rename","loc":"https://wei-lee.me/posts/tech/2015/02/rename"},{"title":"[Book] Zero to One","text":"Book 從 1 到 n，只是複製別人的做法 → 全球化 從 0 到 1，則是創新 → 科技的進步 「有什麼是你跟其他人有不同看法，但是你覺得很重要的事實？」 商業版：「哪些有價值的公司還沒創立」 新創產業運作的原則就是必須和其他人合作完成工作，而且組織要小到能讓所有事情順利運作 大膽冒險比無聊瑣碎好 壞計畫比沒計畫好 競爭市場賺不到錢 銷售與產品同樣重要 只有獨佔者能考慮賺錢以外的事 完全競爭下，企業會專注在今天的利潤，無法規劃場遠的未來 只有一件事可以讓企業超越求生的日常廝殺，創造新的東西，就是獨佔利潤 在完全競爭下，長期來看，沒有公司可以得到經濟利潤 有利可圖則新公司加入，促使大家降低利潤 反之，若無利可圖，則公司倒閉，利潤恢復。最終到無利潤的平衡 只有獨佔企業才能達到利潤最大化 如果想要創造、並長久留住價值，不該建立一個沒有差異化的商品模式 獨佔企業不會扼殺創新。新的獨佔事業會帶來改變 長達數十年的獨佔利潤提供強大的發明誘因 獨佔可以讓發明持續，因為利潤讓他們得以擬定長程計畫 在競爭的狀態下，公司無法花時間再創新的計畫 不要執著於競爭，競爭會讓大家在毫無機會的時候幻想機會存在 如果這場仗不值得打，每個人都是輸家 所謂一家有價值的企業，不但必須成長，還必須能夠 持續成長 這事業 10 年後還在嗎？ 許多創業家都僅專注在短期成長 藉口是「成長容易衡量，但持續就很難了」。 你可能聽過創業的「先發優勢」 但這只是種策略，而不是目標 真正重要的是能在未來產生現金流 如果有其他人會追上並超越你，就算你是第一個做的人也不會有好處 「做什麼不重要，做得好就行」這可能不是正確的 要做什麼很重要，你該全神貫注在擅長的事情上 在此之前，你要想清楚你擅長的是在未來是否有前景。 對於新創事業招募員工，一個要先問自己的問題「能到 Google 享受高新和地位的人為什麼會想加入你的公司成為第 20 位工程師」 工程問題： 你創造的是一個突破的科技，還是微幅改善的方法？ 你必須有比替代品好上 10 倍的專利技術。市面上常碰到誇大不實的廣告，你的微幅進步很難讓人相信。 時機問題： 現在是開始這個事業的正確時機嗎？ 獨佔問題： 你一開始就現在小型市場搶得高市佔率嗎？ 人員問題： 你有合適的團隊嗎？ 銷售問題： 你除了有開發產品的能力，還有銷售計劃嗎？ Speech Wow, Taiwan is his first stop. Speech content Don't outsource your future to a big institution. Figure it out yourself. It is large market share that matters instead of a big market. All happy companies are unique. The others are those who stuck in compete. Well defined, well differentiate jobs run away from big data or clouding XD What makes facebook valuable might not be purely social networking but real identity in social networking. Q&A Q: How to tell the different between crazy ideas and new ideas? It's hard to answer. Is the idea that no one does it or no one does it for good reason? Is it valuable and no others did it? Be honor yourself, don't be over-optimistic. Get to be the best in the world rather than best in Taipei or Taiwan. Q: Startup after having some working experience? It's true for business or management. Startup is something new and by definition, you will not learn from others. Thus, you might not be able to learn from working experience. Idea matters. Although management is important, when it compares to the new idea, it might be not that important. e.g., Twitter Somebody might say that they gonna startup 5 or 10 years later. However, that's rare. The fact is that most of these people would be stuck in many different problems and not that willing to take risks. There is no particular moment for one to startup. If you have a good idea, it's the time. Q: Why Thiel Fellowship support only drop-out students? It's stop-out instead drop-out. For one who wanna startup, full time working is needed. Q: Does there exist any character or special of entrepreneurs? Not easily give up, listen to others, and not to easily to be influenced. How well a team working together is important to a startup. The team members have to get along with each other. Thus, those who performs well in college aren't necessarily good entrepreneurs. Q: How to pick a startup team partner? No formula. It works best if you know they enough. Complementary skills and alike interests would be good. Q: Education problems. How about the flip classroom or MOOCS? It's education bubble. Peter cannot give an ultimate way to replace the university system. The suggestion is that don't get up the same or similar track. What makes education bubbles is that everyone treats university as church or religion. If you don't go into a college, your life would ruin. Such thought is the main problem. Q: How do startups in Taiwan get into the world and get resource? The first capital is the most difficult part and it's super difficult. This is the core challenge. Convincing people that your idea is real and gonna work is really hard. There are some great parts in Silicon Valley but also some bad parts. For example, office and hiring people there is expensive. Q: What the key point to convince peter to invest? ...... Q: Does Peter admire any other entrepreneurs? Mark Zuckerberg. ...... Q: Does Peter have any setback, failure? How to deal with that? It was the law school story wrote in the book. The interesting part is that this failure turns out to be not failure. Failure is overrated. The most important part of failure is not to give up.","tags":"Book","url":"https://wei-lee.me/posts/book/2015/02/zero-to-one","loc":"https://wei-lee.me/posts/book/2015/02/zero-to-one"},{"title":"vimspell - vim 檢查英文文法的套件","text":"vimspell 是一套提供 vim 根據字典來檢查文法的套件 有了 vimsepll，寫 Markdown 或 LaTeX 的時候，就不用再怕拼錯字了 用 vundle 安裝 在 vimrc 中加入下面這行 Bundle 'vimspell' 接著用 :BundleInstall 安裝 字典檔 下載字典檔 我下載的是 en_US.zip 解壓縮完後，用 vim 開啟街壓縮完的資料夾 應該會看到下面這樣 接著進入 vim 在 normal mode 輸入 : mkspell en en_US en 可以自己定義， en\\_US 必須是 .aff 和 .dic 的檔名 檢查一下 vim 資料夾下的 spell 資料夾有沒有新增字典檔，確定有了後就新增完成了 設定 首先要先定義要根據哪個字典檔 : set spelllang = en en 就是剛剛所定義的名稱 接著 :set spell 就可以開啟了 :set nospell 則是關閉 如果每次都要設定一次，就太麻煩了 我在 vimrc 加入了下面這些 set spelllang = en nmap < F7 > : setlocal spell !< cr > autocmd BufRead *.txt , *.md , *.tex setlocal spell 第二行是每次按 F7 就能開啟或關閉 vimspell，也可以換成自己想要的快捷鍵 第三行則是每次遇到副檔名是 txt, md, tex 時就自動開啟 vimspell 使用 vimspell 被開啟後，就會自動把拼錯的字反白起來 如果有其他的語言一樣會被反白起來 指令 ]s : 跳到下一個錯字 [s : 跳到上一個錯字 z= : 開啟建議，可以參考下面的圖，選擇完按 enter 後，就會替換原本的字 zg : 將目前游標上的字加入字典 新增的字都會被加到 ~/.vim/spell/en.utf-8.add ( 根據語言不同，檔名會不同 ) zug : 復原加入字典的字 (刪除) zw : 加入壞字字典，壞字也會被加入同樣的檔案中，最後面會另外加上 /! zuw : 復原加入壞字字典的字 (刪除) Reference Vim documentation: spell How to use spell check with vim [Reply] 如何在 vim 裡用拼字檢查 - iT 邦幫忙 ::IT 知識分享社群 Create a spell file for VIM vim - Automatically enabling spell checking in vimrc - Stack Overflow","tags":"Tech","url":"https://wei-lee.me/posts/tech/2015/02/vim-spell-check","loc":"https://wei-lee.me/posts/tech/2015/02/vim-spell-check"},{"title":"gitignore.io","text":"每次開一個 git 專案，要為它找適當的 .gitignore，都要上網找模板蠻麻煩的 能不能有個簡單的方法，我開什麼專案就產生怎樣的 .gitignore 然後我就發現了 gitignore.io 簡單來說 gitignore.io 提供各式各樣的 gitignore，而且可以自動合併成一個 file 最棒的是它有提供 api 讓我們在 command line 上使用 gitignore.io on command 這是 gitignore.io 的官方文件 doc 設定 以 mac 的 zsh 的使用者為例，只要在執行下面這段 echo \"function gi() { curl -L -s https://www.gitignore.io/api/\\$@ ;}\" >> ~/.zshrc && source ~/.zshrc 或者在 ~/.zshrc 加入下面這段後，執行 source ~/.zshrc function gi () { curl -L -s https://www.gitignore.io/api/ $@ ; } 設定完成後就可以使用 gi 的功能 使用 基本上只有兩種用法 首先當然要先看 gi 支援哪些 .gitignore gi list 執行完會看到一長串的結果 actionscript,ada,agda,android... 接著在 gi 後面輸入想產生的 .gitignore 的 types gi \"types\" 如果有超過一個必須用 , 隔開 e.g., gi vim,osx 不過這樣還不會產生 .gitignore，只會顯示在螢幕上 還要再使用 output redirection 才會有 .gitignore gi vim,osx >> .gitignore My Custom gi 但用起來還是有點小小的不順手 尤其每次要看 list 都要重新連上網抓一次，挺浪費時間 所以就自己寫了一個新的 gi 我把它放在我的 GitHub 上 gi_extension 那我的 Custom gi 到底多支援了什麼呢？ 線下查看 gitignore.io 支援的類型，用更適合閱讀當方式印出 將 output redirection 寫成一個 option 支援以空格作為類型的分隔 ( 逗號依然支援 ) e.g., vim,osx → vim osx 安裝 git clone https://github.com/Lee-W/gi_extension && cd gi_extension sudo cp gi_extension.sh /usr/bin/gi 如果之前有在 shell 的設定檔中，設定過 gitignore.io 提供的 gi 記得要把它註解掉，不然那個 gi 會蓋過我的 gi 如果想移除掉 git clone https://github.com/Lee-W/gi_extension && cd gi_extension sudo rm gi_extension.sh /usr/bin/gi 使用 第一次使用的時候要先下 gi -u 將原本 gi list 的 output，儲存到 ~/.gi_list 顯示支援類型 以表格的方式輸出支援的類型 目前設定一個 row 容納 5 個 column，每個 column 長度為 25 gi -l 以字母的順序輸出 gi -L 顯示 .gitignore 的內容 跟原本的 gi 一樣，只是多支援了以空白作為分隔 gi \"types\" # e.g., gi vim osx 輸出 .gitignore 將結果加入目前資料夾下的 .gitignore gi -a \"types\" # e.g., gi -a vim osx 在目前的資料夾產生一份新的 .gitignore 取代舊有的 gi -e \"types\" # e.g.,e.g.,, gi -e vim osx 更新本地端的支援列表 gi -u 其實每次 gi 被執行的時候，都會在 background 更新列表 但是這次的更新，下次才能被使用 所以如果想要強制更新就可以用上這個指令","tags":"Tech","url":"https://wei-lee.me/posts/tech/2015/02/gitignoreio","loc":"https://wei-lee.me/posts/tech/2015/02/gitignoreio"},{"title":"[Book] 點子都是偷來的","text":"Steal Like an Artist - 10 Things Nobody Told You about Being Creatvie 所有的建言都只是經驗談 1. Steal like an artist Wiliam Ralph Inge: 「什麼是原創？就是沒被人看出來的抄襲」 Garbage in Garbage out 藝術是搜集好的想法，但不是囤積狂 Save Your Theft for Latter 隨時都要養成紀錄的習慣。存在紀錄裡的東西是死的，只又讓它再重新被使用才會活過來 Steal from yourself. e.g. Dream, Memory 2. Don't wait until you know who you're until you get started. Fake it'til you make it 如果你只有受到某一個人的影響，大家會說你是下一個誰誰誰；但如果你偷學的對象有一百個，大家就會說你是渾然天成 3. Write the book you want to read 4. Use your hand 只有動腦的作品是不會出色的 5. Side projects and hobbies are important 如果你有兩、三樣熱情，不要覺得自己非得擇一不可。留著每一項熱情！ 讓各種興趣交流，就會產生變化 6. The Secret : Do good work and share it with people 一開始，不受注意是好事。一旦人們開始注意你，隨性的自由就不再復返。盡力享受和善用未成名的時期 Step 1: Wonder at Something. Step 2: Invite Others to Wonder with You. Howard Aiken: 「別擔心別人偷你的構想，若你的想法真的很棒，你會盡力說服別人接受」 Don't worry about people stealing your ideas. If your ideas are any good, you'll have to ram them down people's throats. 7. Geography is no longer our master. 在日常環境裡，大腦會開始變得安逸，所以你必須顛覆現狀 旅行讓世界變得新鮮，也能活化大腦運作 8. Be nice. (The world is a small town.) Stand Next to Talent ← Garbage in Garbage out Write Fan Letters 不用直接寫信給偶像。用行動、作品來像他致敬吧！ 9. Be boring. (It's the only way to get work done.) Gustave Flaubert: 「生活維持常態和規律」，工作上才有衝刺的動力和原創的靈感。 Make sure how much sleep you get. Get yourself a calendar. 在行事曆上記下每日的目標。完成後在行事曆畫一個叉，並且持續維持這個叉的連線 10. Creatvity is subtraction What's Next? Take a walk Start you swipe file Go to the library Buy a notebook and use it Get yourself and calendar Start your logbook Give a copy of this book away (?) Start a blog Take a nap","tags":"Book","url":"https://wei-lee.me/posts/book/2015/01/steal-like-an-artist-10-things-nobody-told-you-about-being-creatvie","loc":"https://wei-lee.me/posts/book/2015/01/steal-like-an-artist-10-things-nobody-told-you-about-being-creatvie"},{"title":"驅動 BCM43228 網卡在 Linux 的無線功能","text":"最近本來下定決心要來玩 arch linux 結果竟然被筆電的網卡搞死了 抓了官網的驅動竟然不能 build... 沒想到改成灌 Linux mint 17，依然有問題＝＝ 最後找到一個解決的辦法 先確定你的網卡是不是 BC43228 lspci | grep Network 如果是的話就能開始進行安裝了 sudo apt-get install linux-headers-generic sudo apt-get install --reinstall bcmwl-kernel-source 如果成功的話，Wifi 應該馬上就能用了 Reference Ubuntu14.04 Acer Aspire V5 571 Broadcom BCM43228 WiFi - BeyondLogic","tags":"Tech","url":"https://wei-lee.me/posts/tech/2015/01/enable-bcm43228-wifi-on-linux","loc":"https://wei-lee.me/posts/tech/2015/01/enable-bcm43228-wifi-on-linux"},{"title":"Gitbook on Command Line","text":"最近比較認真在寫 Gitbook，順便記錄一下該怎麼用 簡單來說 Gitbook 就是可以使用 Markdown 來寫書的平台，可以轉成各種電子書的格式 目前已經支援的有 html, pdf, ePUB, MOBI 之前寫了一本 Clean Code 的筆記 最近又開始寫一本 FreeBSD 和網管相關的 Gitbook 如果有興趣可以到 我的 Gitbook 上看看 XD 目前 Gitbook 主要支援網站上的 Editor，不過我比較習慣在本地端進行編輯 雖然有 Gitbook 編輯器，但有時候用起來還是會出點問題 所以最後還是決定來學如何用 command line + sublime 寫 Gitbook 安裝 Gitbook npm install gitbook -g 開始撰寫 Gitbook 一本 Gitbook 一般都會包含 SUMMARY.md , README.md , package.json , book.json 像我的 Learning Python 筆記的檔案架構大概長的是這樣 README.md 是這本書的簡介 package.json 是額外使用的 package 的定義和設定 book.json 是這本書的額外設定 這裡不會多做介紹，可以參考 Reference 的網站，裡面有很詳細的介紹 最重要的是 SUMMARY.md，它會定義整本 gitbook 的架構 每個章節下面都還可以給予更多的小節 下面是我 Learning Python 的 SUMMARY.md # Summary * [ Introduction ]( README.md ) * [ Getting Started ]( 1_getting_started/README.md ) * [ A Python Q&A Session ]( 1_getting_started/a_python_q&a_session.md ) * [ How Python Runs Programs ]( 1_getting_started/how_python_runs_programs.md ) * [ How You Run Programs ]( 1_getting_started/how_you_run_programs.md ) * [ Types and Operations ]( 2_types_and_operations/README.md ) * [ Introducing Python Object Types ]( 2_types_and_operations/introducing_python_object_types.md ) * [ Numeric Types ]( 2_types_and_operations/numeric_types.md ) * [ The Dynamic Typing Interlude ]( 2_types_and_operations/the_dynamic_typing_interlude.md ) 這是預覽的結果 下了這個指令後就會根據 SUMMARY.md 的定義，自動產生相對應資料夾和檔案 gitbook init 接著就可以開始編輯裡面的檔案了 預覽 寫完之後當然預覽一下 gitbook serve 用了這個指令後就會為目前的目錄開一個預覽 HTML 的 port 只要在瀏覽器上輸入 http://localhost:4000 就可以預覽剛剛寫的 Gitbook 只要有更新後存擋，重新整理就能看到更新後的結果 輸出 在 export 前，需要為 pdf, epub, mobi 三種格式多安裝程式才能使用 先到的官網下載 Calibre 以 mac 為例 需要下面這個指令，為 ebook-covert 建立一個捷徑，讓 gitbook 可以找到這個功能 ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin 以下的四個指令依序可以產生 html, pdf, epub, mobi gitbook build ./ gitbook pdf ./ gitbook epub ./ gitbook mobi ./ 後面可以多指定一個參數 --output=\"Directory\" \"Directory\" 換成你要的位置或檔名 如果不指定，預設 html 會 export 到 _book 裡面，其他檔案則會以 book 命名 Publish 到 Gitbook.com 上 先到 Gitbook 官網 上註冊帳號 接著 create a new book，到 setting 頁面往下拉，就會看到一個 URL 接下來的操作就跟 git 基本上是一樣的，init, add, commit ... 等 只有在 remote 的設定有點不同 git remote add gitbook \"URL\" git push -u gitbook 這裡要輸入的帳號、密碼是 gitbook 上的，不是與其連結的帳號的 如果還沒設定就要再去自己的 profile 內設定 Reference Gitbook GitBook Documentation 深入淺出 GitBook 寫作與自助出版，電子書也能多人協作","tags":"Tech","url":"https://wei-lee.me/posts/tech/2015/01/gitbook-on-command-line","loc":"https://wei-lee.me/posts/tech/2015/01/gitbook-on-command-line"},{"title":"[Book] Clean Coder","text":"如果非專業人事把事情搞砸了，收拾爛攤子的往往是僱主 而專業人事如果犯了錯，只好自己收拾殘局。 當然，你說的沒錯。軟體發展太複雜了，不可能沒什麼 bug 但很不幸，這個理由並不能為你開脫 人體太複雜了，不可能完全理解，但醫生仍誓言不傷害病人 如果他們都不拿人體的複雜性作託辭，我們又怎麼能拿上述的理由，開脫自己的責任呢？ 程式難免會出現 bug，但這並不意味著你不用對它們負責 沒人能寫出完美的軟體，但這並表示你不用對不完美負責 把自己沒把握的程式碼發送給 QA 這麼做本身就是不專業 每次 QA 找出問題時，或者更糟糕的是「用戶找出問題」時，你都該震驚羞愧，並決心以此為戒 如果你希望自己的軟體靈活可變，那就應該時常修改它！ 讓軟體保持固定並不變才是危險的！！ 如果一直不重構程式碼，等到最後不得不重構的時候，你就會發現程式碼已經「僵化了」 你應該計劃每週工作 60 小時 前 40 個小時是給僱主的，後 20 小時是給自己的 這剩餘的 20 小時裡，也就是每天 3 小時，你應該看書、練習、學習，或者做其他提升職業能力的事 那 20 小時你不用為僱主工作。相反，你該為自己的職業發展工作","tags":"Book","url":"https://wei-lee.me/posts/book/2015/01/Soft","loc":"https://wei-lee.me/posts/book/2015/01/Soft"},{"title":"[Book] 人月神話","text":"因為溝通的時間，人力和工時互換是不成立的，別用人月來衡量工作規模大小 溝通又可分為，訓練和相互交流 訓練的成本可以是線性關係，但相互交流花的時間可多了 所以為了趕上時程而增加的人力，通常不會只會讓進度更落後。 系統設計的時候，保有概念整體性是很重要的原則 寧可忽略掉新奇或更好的特色，來反映同一組設計理念 系統的目的是使用便利性，所以功能概念複雜度比才是系統設計的最終測試標準 好的設計不可以單獨偏重功能性，也不可只偏重簡單性 產品測試小組代表顧客，就是為了挑出產品毛病存在 隨著時間的投入，細心的產品測試人員將找出設計意圖並未正確傳達之處，也就是設計的決策沒有被正確了解或準確實作的地方 基於這個理由，測試小組絕對有必要與設計意念傳達的過程相結合，並且必須在造其跟根設計的工作一起同時進行 在大部分的專案中，第一次出爐的系統絕少是有用的 因此，無需考慮是否要做一個試探性的系統，然後把他丟棄，因為這是必然的問題 所以應該要預先規劃去做一個本來就要丟掉的試驗品 在規劃時程的時候，把必然的一次失敗納入正式計劃之中。 規劃軟體開發專案的文件 目標 產品規格 時程 預算 場地配置 組織編制圖 為使用程式而寫的文件 目的 程式主要功能為何？ 為什麼要寫這支程式？ 環境 程式要在哪種機器上跑？ 硬體和作業系統的組態該如何設定？ 輸入值域與輸出值域 程式輸入與輸出資料的合理範圍為何？ 欲達成的功能與使用的演算法 精確的說出程式到底要做什麼事情 ? 輸出入格式 要精確而完整的描述 執行過程中的指示 包括運行正常時，或因異常而終止時，在控制台或任何輸出裝置上應該要看得到的任何提示 選項 使用者在功能上有哪些選擇彈性？ 這些選項該如何正確的加以指定？ 執行時間 對於某個工作，在某個組態所指定的空件大小限制之下，程式要花多少時間來完成？ 輸出結果的精確度與檢驗方式 預期的結果必須精確到什麼程度？ 跟這種精確度相搭配的檢驗方式為何？ 將文件維護的負擔剪到最小 借助那些基於語言的要求而必須存在的語 儘可能容納更多訊息在裡頭 標籤、宣告、符號名稱都可以用來表達某些函意 善用留白或固定格式來增加可讀性，表現出從屬和巢狀的關係 以註解的形式在程式中加入一些註解 但許多程式為了這個逐行加入註解，這更會讓人感到困惑","tags":"Book","url":"https://wei-lee.me/posts/book/2015/01/the-mythical-man-month","loc":"https://wei-lee.me/posts/book/2015/01/the-mythical-man-month"},{"title":"MacBook Pro Retina 開箱","text":"這篇只是想給自己換 MacBook Pro Retina 留下一個紀念 順便紀錄一些從 Ubuntu 轉過來不習慣的地方 想要看更專業的開箱文就要再去翻別篇囉ＸＤ 先附上幾張照片 從 Ubuntu 轉過來 MacBook，不用一天就上手了 不過也可能是我常常把 Ubuntu 改得很像 MacBook 吧ＸＤ 轉過來 MacBook 最大的好處就是超強大的觸控板 不過還是有一些比較不習慣的地方 沒有 guake terminal guake terminal 實在太好用了啊ＸＤ 雖然可以用 iTerm2 做出類似的效果，但感覺還是不太對 SETUP ITERM2 TO BEHAVE LIKE GUAKE 不支援 NTFS 寫入 下面這裡提供一個在 PTT 找到的解決方案 不過寫入速度好像只有 USB 2.0 [軟體] NTFS for Mac OSX Yosemite 10.10 無法直接讀到 Android 手機的檔案 雖然可以用 Android File Transfer 解決，但不知道為什麼遇到我的手機很容易死當＝＝ Android File Transfer 總之我現在也是個 MacBook user 了 lol","tags":"Gossiping","url":"https://wei-lee.me/posts/gossiping/2015/01/mbpr-out-of-the-box","loc":"https://wei-lee.me/posts/gossiping/2015/01/mbpr-out-of-the-box"},{"title":"Android Studio + Genymotion 安裝","text":"Android Studio 最近 Google 在推行的 Android IDE，前身是 IntelliJ IDEA 它的檔案架構跟 eclipse 差蠻多的，所以用不同的 IDE 來協作會有點麻煩 就我的經驗 Android Studio 比 eclipse 來得穩定一些 反正現在還有 Google 在背後支持它，就來試試看吧 XD Android Studio 正式版已經發布了，現在好像完全無法把 sdk 放在 Android Studio 資料夾內 所以之前沒有把 sdk 獨立出來的，記得要獨立出來，不然可能會發生無法更新的問題 Installation Download Android Studio 先到 官網 下載 Android Studio ( 這篇文以 Windows 為例 ) 下載後會進入到下面的教學頁面 其實寫得還蠻清楚的，所以如果可以接受就可以跳過以下的教學了 XD Install JDK 在安裝 Android Studio 前，要先安裝好 JDK 現在最新的版本是 JDK 8，可以到 這個連結 下載 選好自己的作業系統 再來就是一直下一步囉 XD 設定環境變數 安裝完 JDK 後，我們還需要設定環境變數 以 Win7 為例 電腦 內容 → 進階系統設定 → 進階 → 環境變數 接著在 系統變數 這個欄位按下 新增 變數名稱 輸入 JAVA_HOME ( 可能會因為 Android Studio 的版本而不同 ) 變數值 輸入 你安裝 JDK 的路徑 (e.g. C:\\Program Files\\Java\\jdk1.8.0_20 ) Install Android Studio 安裝過程中會問要讓 目前使用者 使用還是 所有使用者 使用 再來會要你選安裝目錄 如果不想理它，就一直下一步吧 除了 Android Studio 外，可能還會安裝一些 Dependent 的套件 不過就放著讓他跑就可以了 Install SDK manager 自從 0.8.14 版之後，SDK Manager 就不會再跟 Android Studio 綁在一起 所以要額外 下載 SDK tools 如果是在 0.8.14 版前安裝的也不用擔心，更新後需要多做設定 Android Studio 會自動幫你把 SDK 的路徑設定到原本的位置 把網頁往下拉會看到 SDK Tools Only 下載完解壓縮到你要的路徑 之後設定 SDK manager 設定到這個路徑就可以了 開始 Android Studio Configure → Project Default → Project Structure 記得要把 SDK 的路徑改成剛剛安裝的路徑 SDK setup 接著我們要設定 SDK 現在最新的版本是 Android 5.0 (API 21) 先開啟 Android Studio，進入 Configure 進入 SDK Manager 把選單拉到 API 21 選起來 接著把選單拉到最後選 Android Support Repository Android support Library Coogle Play services Google Repository Google USB Driver Intel X86 Emulator Accelerator(HAXM installer) 最後的這個 HAXM 是為了讓模擬器加速用的，從 SDK manager 下載完之後，還有另外的安裝步驟 安裝到這裡 Android Studio 已經可以使用了 ，不過還可以再做一些設定讓手機模擬器跑得更快 Emulator Accelerator 在安裝 HAXM 前要先確定 Intel VT-x 是否有在你的 BIOS 被啟用 我沒遇到這個問題，所以我也不知道怎麼解決＠＠ 可以在 cmd 下 sc query intelhaxm 來看有沒有開啓，只要有看到 Running 應該就是沒問題了 再來到 Android Studio 的目錄下找到 HAXM 的安裝檔 它被放在 ...\\android-studio\\sdk\\extras\\intel\\Hardware_Accelerated_Execution_Manager ... 指的是安裝的目錄 看到 intelhaxm 按下去 ! 一直按下一步就大功告成了 不過 ... 這樣還是不夠快，我們需要更快的模擬器！ Genymotion ！！！ Genymotion 安裝 Genymotion 的模擬器前，我們必須先到 官網 註冊 Download 進入下載頁面後，往下拉會看到 Windows，mac 和 Liunx 版 Windows 只要直接安裝就可以了，它會連 Oracle Virtual Box 一起安裝 mac 和 Linux 還要額外先安裝 Oracle Virtual Box Install IDE plug-in 在下載頁面往下拉會看到 genymotion 在 IDE 上的 plugin，可以讓我們從 IDE 內直接開啟 Genymothion Android Studio 屬於 IntelliJ IDEA，所以我們就照著他上面的指示設定 開啟 Android Studio File → Settings 找到 Plungins ，接著點 Browse repositories 上方輸入 Genymotion 就可找到，接著就安裝它吧 安裝完記得重新啟動 Android Studio，就會在工具列看到多一個按鈕，Genymotion 就安裝完成囉 第一次使用會要求設定 Genymotion 安裝的資料夾 (e.g. C:\\Program Files\\Genymobile\\Genymotion ) 設定完就可以開始使用 Genymotion 了 Plugins IdeaVim: 如果你是重度 Vim 狂熱者，這絕對是你不能不裝的 plugin!!! MarkDown: 這個 Plugin 提供直接在 Android Studio 中，Preview Markdown 的功能","tags":"Tech","url":"https://wei-lee.me/posts/tech/2014/12/android-studio-and-genymotion-installation","loc":"https://wei-lee.me/posts/tech/2014/12/android-studio-and-genymotion-installation"},{"title":"Dual Boot FreeBSD Using GRUB2","text":"其實原本的標題是 Dual Boot FreeBSD with Ubuntu 這篇文章寫的都是用 Ubuntu 測試的 不過我想只要是 grub2 應該都差不多吧 XD 加入 FreeBSD 到 grub 開機選單 更改 grub 的設定檔 vi /etc/grub.d/40_Custom 加入下面這幾行 menuentry \"FreeBSD (/boot/loader)\" { insmod ufs2 set root=(hd0,1,a) kfreebsd /boot/loader } FreeBSD (/boot/loader) 是在開機時顯示的名稱 (hd0,1,a) 要根據你的 FreeBSD 灌在磁碟的哪一塊決定 更新 grub 設定檔 sudo update-grub 這樣就會在開機選單上看到 FreeBSD 了 其實還有一些其他的設定方法 可以參考 Set up Grub2 to boot Freebsd 換 grub 開機順序 如果希望改變預設的開機順序，就必須要修改下面的檔案 /etc/default/grub vi /etc/default/grub 會看到下面這串 GRUB_DEFAULT=0 #GRUB_HIDDEN_TIMEOUT=0 GRUB_HIDDEN_TIMEOUT_QUIET=true GRUB_TIMEOUT=10 GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian` GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash\" GRUB_CMDLINE_LINUX=\"\" 把第 1 行設定為多少 (注意是從 0 開始)，就會預設從那裡開機 在 ubuntu mount FreeBSD sudo mount -t ufs -r -o ufstype = ufs2 /dev/sda4 ~/freebsd","tags":"Tech","url":"https://wei-lee.me/posts/tech/2014/10/dual-boot-freebsd-using-grub2","loc":"https://wei-lee.me/posts/tech/2014/10/dual-boot-freebsd-using-grub2"},{"title":"powerline on zsh, vim, tmux","text":"用了 vim 的 powerline 後覺得很酷，就找了很多的 powerline 來玩 於是這篇文章產生了 XDD 這是各個 powerline 的預覽圖 vim tmux zsh powerline 字體 安裝這些 powerline 之前要先下載 powerline 字體 不然可能會無法正常顯示 在 powerline-fonts 下載後，之後安裝就完成了 記得要把終端機的字體條成這些有 powerline 結尾的字體，我當初就是沒用這個卡了很久 = = git clone https://github.com/Lokaltog/powerline-fonts /tmp/git/clone sudo mv /tmp/git-clone/powerline-fonts /usr/share/fonts/powerline-fonts sudo fc-cache -v -f zsh 其實 oh-my-zsh 本身就有 agnoster 了 但我更推薦 oh-my-zsh-powerline-theme 安裝完之後記得再 zshrc 中加入 ZSH_THEME=\"powerline\" 如果要更多客制化設定可以參考 repo 內的設定 git clone https://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme /tmp/oh-my-zsh-powerline-theme /tmp/oh-my-zsh-powerline-theme/oh-my-zsh-powerline-theme/install_in_omz.sh vim 其實我也不是用 vim-powerline 而是 vim-airline 不過基本上好像是差不多的東西，而且 vim-airline 比較輕量化 建議直接用 vundle 這類的套件管理安裝比較方便 vim-airline tmux tmux 有非常多的東西可以客製化設定 在各系統也有不同的安裝方式，就自己看 repo 的 readme 文件吧 XD tmux-powerline","tags":"Tech","url":"https://wei-lee.me/posts/tech/2014/07/powerline-on-zsh-vim-tmux","loc":"https://wei-lee.me/posts/tech/2014/07/powerline-on-zsh-vim-tmux"},{"title":"解決 Win 8、Ubuntu 雙系統無法掛載 NTFS 分割區問題","text":"現在安裝了 Win8 和 Ubuntu 雙系統 每次只要開 Win 8 ，再重新開機進到 Ubuntu 就會出現 file system 無法掛載的問題 然後我在兩個系統間共同的 data 分割區就會無法掛載 可是再重開一次 Win 8，問題就神祕的解決了 @@ 後來才發現原來是因為 Win 8 的 Fast Boot 造成的 解決 控制台 \\ 硬體和音效 \\ 電源選項 \\ 系統設定 只要把 開啟快速啟動 取消掉就可以了 Reference Cannot mount NTFS partition in Ubuntu 13.04 [duplicate]","tags":"Tech","url":"https://wei-lee.me/posts/tech/2014/02/solution-to-win-8-ubuntu-dual-system-cannot-mount-ntfs-parition-problem","loc":"https://wei-lee.me/posts/tech/2014/02/solution-to-win-8-ubuntu-dual-system-cannot-mount-ntfs-parition-problem"},{"title":"Git and Git Hub","text":"這份筆記已經是舊的版本了 請參考 新版 最近因為專題需要，所以寫了一份簡單的 Git 筆記 裡面大概就是我常用的指令 因為我也只是剛開始使用 Git 沒多久，內容不會太深入 Git and git hub from 唯 李","tags":"Tech","url":"https://wei-lee.me/posts/tech/2014/02/git-and-git-hub","loc":"https://wei-lee.me/posts/tech/2014/02/git-and-git-hub"},{"title":"Guake terminal","text":"隱藏在背景的 terminal 並且可以隨時呼叫 (預設是 F12) 安裝 Guake Terminal sudo apt-get install guake 設定 滑鼠一移開就自動隱藏 從「偏好設定 （Preferences)」勾選「Hide on lost focus」 開機就啟動 Guake Terminal 在「初始應用程式 （Startup Applications) 」把 guake terminal 加上去 Reference Ubuntu 安裝 Guake Terminal","tags":"Tech","url":"https://wei-lee.me/posts/tech/2014/02/guake-terminal","loc":"https://wei-lee.me/posts/tech/2014/02/guake-terminal"},{"title":"autojump - 在 terminal 中快速跳轉資料夾","text":"快速跳轉資料夾的工具 e.g., 有個資料夾是 /a/b/c/d/e/f/g/h 原本要輸入 cd /a/b/c/d/e/f/g/h 可是現在有了 autojump，而且你也去過這個 h 資料夾，你就可以 j h 很方便吧！！！ 安裝 cd /tmp git clone https://github.com/joelthelion/autojump cd autojump chmod +x install.py ./install.py 然後把下面這行加入 shell 的設定檔 (e.g. ~/.bashrc , ~/.zshrc) [[ -s ~/.autojump/etc/profile.d/autojump.sh ]] && . ~/.autojump/etc/profile.d/autojump.sh 最後只要重開 shell 就完成了 使用 最基本的功能當然就是跳轉囉 j word 如果有重複的名稱 (e.g. worda, wordb)，就在打一次同樣的指令，就會跳到下一個 list 現在 autojump 可以跳到的資料夾 j -s 刪除已經背改變路徑或刪除的紀錄 j --purge Reference autojump readme","tags":"Tech","url":"https://wei-lee.me/posts/tech/2014/02/autojump","loc":"https://wei-lee.me/posts/tech/2014/02/autojump"},{"title":"Linux 開機自動掛載分割區","text":"分割區的掛載資訊，存在 /etc/fstab 中，所以需要自動掛載分割區時可以針對此檔案做修改 需要注意的是，如果設定不好，可能會沒辦法開機的！！！ 我們先來看一下 /etc/fstab 內的東西 sudo cat /etc/fstab # /etc/fstab: static file system information. # # Use 'blkid' to print the universally unique identifier for a # device; this may be used with UUID= as a more robust way to name devices # that works even if disks are added and removed. See fstab(5). # # <file system> <mount point> <type> <options> <dump> <pass> # / was on /dev/sda1 during installation UUID=c5744283-f105-47e9-8a2e-21f477d895b7 / ext4 errors=remount-ro 0 1 # swap was on /dev/sda5 during installation UUID=72b6a10a-f0b6-43ef-927d-0d74673febe7 none swap sw 0 0 #data UUID=571F168F3D98D759 /media/lee/data ntfs auto,rw 0 2 # 是註解 最後六行是比較重要的 1~2 是 root 的掛載 3~4 是 swap 的掛載 5~6 是我自己的 data 的掛載 #data UUID=571F168F3D98D759 /media/lee/data ntfs auto,rw 0 2 總共有 6 個欄位 掛載硬碟的標籤 掛載硬碟的標籤我用的是 UUID 的標籤，可以用下面的指令查詢 ls -l /dev/disk/by-uuid/ 也可以直接使用 /dev/sda1 這樣的格式，只是如果硬碟的代號改變，就要再去手動改變比較麻煩 掛載位置 掛載的位置要是一個已經存在的位置，建議是一個空的資料夾 如果不是空的，裏面的東西應該都會被清空 另外，一個掛載點只能掛載一個 disk 另外，注意在 Linux 中大小寫是不同的 分隔區格式 而一般的檔案朝的分割驅格式都是都是 ntfs，不過也可以用指令來查詢 df 選項 是否被 dump 備份指令作用 是否以 fsck 檢驗磁區 基本上 4 5 6 我也沒去研究，如果有興趣的話可以在我最後面附上的參考資料中找到 測試 先看一下是否有掛載成功 df 檔案系統 1K-區段 已用 可用 已用 % 掛載點 /dev/sda1 103081248 9259936 88562048 10% / none 4 0 4 0% /sys/fs/cgroup udev 3992780 4 3992776 1% /dev tmpfs 801368 1168 800200 1% /run none 5120 0 5120 0% /run/lock none 4006840 1032 4005808 1% /run/shm none 102400 44 102356 1% /run/user /dev/sda6 459942908 229176172 230766736 50% /media/lee/data 像我的最後面就出現了 data 之後暫時將它卸載 (若 df 之後，分割區沒有出現，那就不用做這步了) sudo umount /dev/sda6 (/dev/sda6 要取代成你自己的位置 ) 接著再執行一次 df 剛剛的分割區應該會不見，然後執行 開機自動掛載分割區 sudo mount -a 如果沒有錯誤訊息，就在執行一次 df 如果掛載的分隔驅再裡面就是成功了 如果有任何異常，就去看一下 /etc/fstab 是不是有哪裡寫錯了 Reference 巴特的微花盆： 筆記： Linux 中設定開機時自動掛載分割區","tags":"Tech","url":"https://wei-lee.me/posts/tech/2014/02/auto-mount-disk-after-boot","loc":"https://wei-lee.me/posts/tech/2014/02/auto-mount-disk-after-boot"},{"title":"[C++] 如何 create thread","text":"之前因為作業需要使用到 multi-thread，就留下了這篇紀錄 這篇會稍微介紹 C++11 的 thread 函式庫，還有一點點和 pthread 要使用 C++11 的 thread 在編譯時要加上 -std=c++11 -pthread ( -std=c++ -lphread 好像也可以 ) e.g. g++ -o t thread.cpp -std=c++11 -pthread -std=c++11 : 是指定 c++ 的版本 -pthread ( 或 -lpthread )：使用 thread 的 liberary 下面有寫到 join 的部份 join 是開啟這個 thread 的上層程式必須等待到這個 thread 的工作結束了，才可以繼續下面的工作 也就是 join 以上的程式會與 thread 搶 CPU，join 以後的程式就會等待到 thread 結束才開始 那就直接來看 code 吧 C++ 11 thread 在 main 裡面直接開啟 thread 直接宣告 thread 型態的變數 thread 的 constructor 的第一個參數是函數名稱，第二個以後就是原本函數的參數 #include <iostream> #include <thread> using namespace std ; void fun1 () { cout << \"This is funtion1\" << endl ; } void fun2 ( int p1 , int p2 ) { cout << \"This is function2\" << p1 << p2 << endl ; } main (){ thread t1 ( fun1 ); thread t2 ( fun2 , 1 , 2 ); t1 . join (); t2 . join (); } 這樣就可以產生兩個 thread，他們會彼此搶 CPU 的資源 cout 似乎是每一個 << 會去搶一次，所以如果想要一次印完全部，可能可以考慮使用 printf 或者是 thread 的 lock 功能 在 class 內開啟 thread 用上面的方法直接呼叫同個 class 的 function 會出現錯誤 所以就必須用下面的方法 在宣告 thread 的時候 第 1 個參數必須是這個 function 的完整 reference 第 2 個用 this 第 3 個以後才是原本 function 的參數 p.s. 如果 fun1 是 static，則不用 this #include <iostream> #include <thread> using namespace std ; class A { public : void fun1 ( int p1 ) { cout << \"This is funtion1\" << endl ; } void fun2 () { thread t ( & example :: fun1 , this , 1 ); t . join (); } }; main () { A a ; a . fun2 (); } 最後是如何呼叫其他 class 的 function，這裡包含兩個例子 (main, class B) 想法跟上面那種很接近，只是第 2 個參數改成那個物件的實體 #include <iostream> #include <thread> using namespace std ; class A { public : void fun1 () { cout << \"This is funtion1\" << endl ; }; }; class B { public : void fun2 () { cout << \"This is function2\" << endl ; thread t ( & A :: fun1 , & a ); t . join (); } private : A a ; }; main () { B b ; b . fun2 (); A a ; thread t1 ( & A :: fun1 , & a ); t1 . join (); } 基本的 pthread 使用 #include <iostream> #include <pthread.h> using namespace std ; struct arg { int p1 ; }; void * fun1 ( void * a ) { arg * argument ; argument = ( arg * ) a ; cout << argument -> p1 << endl ; } main () { arg * argumentForFun1 = new arg ; argumentForFun1 -> p1 = 1 ; pthread_t t1 ; pthread_create ( & t1 , NULL , fun1 , argumentForFun1 ); pthread_join ( t1 , NULL ); } 至於 pthread 如何用在 class 的 function 上 可以將 function 加上 static 同樣第 3 個參數也要改成 &A::fun1 Reference 資訊小兵的胡言亂語 : [C++] Thread Function 相關測試 解析 Linux 中多線程編程並傳遞多個參數實例 linux 下 C/C++, 多线程 pthread","tags":"Tech","url":"https://wei-lee.me/posts/tech/2013/12/how-to-create-thread-in-c-plus-plus","loc":"https://wei-lee.me/posts/tech/2013/12/how-to-create-thread-in-c-plus-plus"}]};